{"version":3,"file":"4234.bundle.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/actions.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/celllist.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/default-toolbar.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/executionindicator.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/model.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/modelfactory.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/modestatus.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/notebooklspadapter.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/notebooktools.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/constants.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/windowing.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/notebookfooter.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/widget.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/panel.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/toc.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/searchprovider.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/tokens.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/tracker.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/truststatus.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@jupyterlab/notebook/lib/widgetfactory.js"],"sourcesContent":["// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Clipboard, Dialog, showDialog } from '@jupyterlab/apputils';\nimport { CodeCell, isMarkdownCellModel, isRawCellModel, MarkdownCell } from '@jupyterlab/cells';\nimport { signalToPromise } from '@jupyterlab/coreutils';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { every, findIndex } from '@lumino/algorithm';\nimport { JSONExt } from '@lumino/coreutils';\nimport { Signal } from '@lumino/signaling';\nimport * as React from 'react';\n/**\n * The mimetype used for Jupyter cell data.\n */\nconst JUPYTER_CELL_MIME = 'application/vnd.jupyter.cells';\nexport class KernelError extends Error {\n    /**\n     * Construct the kernel error.\n     */\n    constructor(content) {\n        const errorContent = content;\n        const errorName = errorContent.ename;\n        const errorValue = errorContent.evalue;\n        super(`KernelReplyNotOK: ${errorName} ${errorValue}`);\n        this.errorName = errorName;\n        this.errorValue = errorValue;\n        this.traceback = errorContent.traceback;\n        Object.setPrototypeOf(this, KernelError.prototype);\n    }\n}\n/**\n * A collection of actions that run against notebooks.\n *\n * #### Notes\n * All of the actions are a no-op if there is no model on the notebook.\n * The actions set the widget `mode` to `'command'` unless otherwise specified.\n * The actions will preserve the selection on the notebook widget unless\n * otherwise specified.\n */\nexport class NotebookActions {\n    /**\n     * A signal that emits whenever a cell completes execution.\n     */\n    static get executed() {\n        return Private.executed;\n    }\n    /**\n     * A signal that emits whenever a cell execution is scheduled.\n     */\n    static get executionScheduled() {\n        return Private.executionScheduled;\n    }\n    /**\n     * A signal that emits when one notebook's cells are all executed.\n     */\n    static get selectionExecuted() {\n        return Private.selectionExecuted;\n    }\n    /**\n     * A private constructor for the `NotebookActions` class.\n     *\n     * #### Notes\n     * This class can never be instantiated. Its static member `executed` will be\n     * merged with the `NotebookActions` namespace. The reason it exists as a\n     * standalone class is because at run time, the `Private.executed` variable\n     * does not yet exist, so it needs to be referenced via a getter.\n     */\n    constructor() {\n        // Intentionally empty.\n    }\n}\n/**\n * A namespace for `NotebookActions` static methods.\n */\n(function (NotebookActions) {\n    /**\n     * Split the active cell into two or more cells.\n     *\n     * @param notebook The target notebook widget.\n     *\n     * #### Notes\n     * It will preserve the existing mode.\n     * The last cell will be activated if no selection is found.\n     * If text was selected, the cell containing the selection will\n     * be activated.\n     * The existing selection will be cleared.\n     * The activated cell will have focus and the cursor will\n     * remain in the initial position.\n     * The leading whitespace in the second cell will be removed.\n     * If there is no content, two empty cells will be created.\n     * Both cells will have the same type as the original cell.\n     * This action can be undone.\n     */\n    function splitCell(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        // We force the notebook back in edit mode as splitting a cell\n        // requires using the cursor position within a cell (aka it was recently in edit mode)\n        // However the focus may be stolen if the action is triggered\n        // from the menu entry; switching the notebook in command mode.\n        notebook.mode = 'edit';\n        notebook.deselectAll();\n        const nbModel = notebook.model;\n        const index = notebook.activeCellIndex;\n        const child = notebook.widgets[index];\n        const editor = child.editor;\n        if (!editor) {\n            // TODO\n            return;\n        }\n        const selections = editor.getSelections();\n        const orig = child.model.sharedModel.getSource();\n        const offsets = [0];\n        let start = -1;\n        let end = -1;\n        for (let i = 0; i < selections.length; i++) {\n            // append start and end to handle selections\n            // cursors will have same start and end\n            start = editor.getOffsetAt(selections[i].start);\n            end = editor.getOffsetAt(selections[i].end);\n            if (start < end) {\n                offsets.push(start);\n                offsets.push(end);\n            }\n            else if (end < start) {\n                offsets.push(end);\n                offsets.push(start);\n            }\n            else {\n                offsets.push(start);\n            }\n        }\n        offsets.push(orig.length);\n        const clones = offsets.slice(0, -1).map((offset, offsetIdx) => {\n            const { cell_type, metadata } = child.model.sharedModel.toJSON();\n            return {\n                cell_type,\n                metadata,\n                source: orig\n                    .slice(offset, offsets[offsetIdx + 1])\n                    .replace(/^\\n+/, '')\n                    .replace(/\\n+$/, '')\n            };\n        });\n        nbModel.sharedModel.transact(() => {\n            nbModel.sharedModel.deleteCell(index);\n            nbModel.sharedModel.insertCells(index, clones);\n        });\n        // If there is a selection the selected cell will be activated\n        const activeCellDelta = start !== end ? 2 : 1;\n        notebook.activeCellIndex = index + clones.length - activeCellDelta;\n        notebook\n            .scrollToItem(notebook.activeCellIndex)\n            .then(() => {\n            var _a;\n            (_a = notebook.activeCell) === null || _a === void 0 ? void 0 : _a.editor.focus();\n        })\n            .catch(reason => {\n            // no-op\n        });\n        Private.handleState(notebook, state);\n    }\n    NotebookActions.splitCell = splitCell;\n    /**\n     * Merge the selected cells.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @param mergeAbove - If only one cell is selected, indicates whether to merge it\n     *    with the cell above (true) or below (false, default).\n     *\n     * #### Notes\n     * The widget mode will be preserved.\n     * If only one cell is selected and `mergeAbove` is true, the above cell will be selected.\n     * If only one cell is selected and `mergeAbove` is false, the below cell will be selected.\n     * If the active cell is a code cell, its outputs will be cleared.\n     * This action can be undone.\n     * The final cell will have the same type as the active cell.\n     * If the active cell is a markdown cell, it will be unrendered.\n     */\n    function mergeCells(notebook, mergeAbove = false) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        const toMerge = [];\n        const toDelete = [];\n        const model = notebook.model;\n        const cells = model.cells;\n        const primary = notebook.activeCell;\n        const active = notebook.activeCellIndex;\n        const attachments = {};\n        // Get the cells to merge.\n        notebook.widgets.forEach((child, index) => {\n            if (notebook.isSelectedOrActive(child)) {\n                toMerge.push(child.model.sharedModel.getSource());\n                if (index !== active) {\n                    toDelete.push(index);\n                }\n                // Collect attachments if the cell is a markdown cell or a raw cell\n                const model = child.model;\n                if (isRawCellModel(model) || isMarkdownCellModel(model)) {\n                    for (const key of model.attachments.keys) {\n                        attachments[key] = model.attachments.get(key).toJSON();\n                    }\n                }\n            }\n        });\n        // Check for only a single cell selected.\n        if (toMerge.length === 1) {\n            // Merge with the cell above when mergeAbove is true\n            if (mergeAbove === true) {\n                // Bail if it is the first cell.\n                if (active === 0) {\n                    return;\n                }\n                // Otherwise merge with the previous cell.\n                const cellModel = cells.get(active - 1);\n                toMerge.unshift(cellModel.sharedModel.getSource());\n                toDelete.push(active - 1);\n            }\n            else if (mergeAbove === false) {\n                // Bail if it is the last cell.\n                if (active === cells.length - 1) {\n                    return;\n                }\n                // Otherwise merge with the next cell.\n                const cellModel = cells.get(active + 1);\n                toMerge.push(cellModel.sharedModel.getSource());\n                toDelete.push(active + 1);\n            }\n        }\n        notebook.deselectAll();\n        const primaryModel = primary.model.sharedModel;\n        const { cell_type, metadata } = primaryModel.toJSON();\n        if (primaryModel.cell_type === 'code') {\n            // We can trust this cell because the outputs will be removed.\n            metadata.trusted = true;\n        }\n        const newModel = {\n            cell_type,\n            metadata,\n            source: toMerge.join('\\n\\n'),\n            attachments: primaryModel.cell_type === 'markdown' ||\n                primaryModel.cell_type === 'raw'\n                ? attachments\n                : undefined\n        };\n        // Make the changes while preserving history.\n        model.sharedModel.transact(() => {\n            model.sharedModel.deleteCell(active);\n            model.sharedModel.insertCell(active, newModel);\n            toDelete\n                .sort((a, b) => b - a)\n                .forEach(index => {\n                model.sharedModel.deleteCell(index);\n            });\n        });\n        // If the original cell is a markdown cell, make sure\n        // the new cell is unrendered.\n        if (primary instanceof MarkdownCell) {\n            notebook.activeCell.rendered = false;\n        }\n        Private.handleState(notebook, state);\n    }\n    NotebookActions.mergeCells = mergeCells;\n    /**\n     * Delete the selected cells.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * The cell after the last selected cell will be activated.\n     * It will add a code cell if all cells are deleted.\n     * This action can be undone.\n     */\n    function deleteCells(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        Private.deleteCells(notebook);\n        Private.handleState(notebook, state, true);\n    }\n    NotebookActions.deleteCells = deleteCells;\n    /**\n     * Insert a new code cell above the active cell or in index 0 if the notebook is empty.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * The widget mode will be preserved.\n     * This action can be undone.\n     * The existing selection will be cleared.\n     * The new cell will the active cell.\n     */\n    function insertAbove(notebook) {\n        if (!notebook.model) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        const model = notebook.model;\n        const newIndex = notebook.activeCell ? notebook.activeCellIndex : 0;\n        model.sharedModel.insertCell(newIndex, {\n            cell_type: notebook.notebookConfig.defaultCell,\n            metadata: notebook.notebookConfig.defaultCell === 'code'\n                ? {\n                    // This is an empty cell created by user, thus is trusted\n                    trusted: true\n                }\n                : {}\n        });\n        // Make the newly inserted cell active.\n        notebook.activeCellIndex = newIndex;\n        notebook.deselectAll();\n        Private.handleState(notebook, state, true);\n    }\n    NotebookActions.insertAbove = insertAbove;\n    /**\n     * Insert a new code cell below the active cell or in index 0 if the notebook is empty.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * The widget mode will be preserved.\n     * This action can be undone.\n     * The existing selection will be cleared.\n     * The new cell will be the active cell.\n     */\n    function insertBelow(notebook) {\n        if (!notebook.model) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        const model = notebook.model;\n        const newIndex = notebook.activeCell ? notebook.activeCellIndex + 1 : 0;\n        model.sharedModel.insertCell(newIndex, {\n            cell_type: notebook.notebookConfig.defaultCell,\n            metadata: notebook.notebookConfig.defaultCell === 'code'\n                ? {\n                    // This is an empty cell created by user, thus is trusted\n                    trusted: true\n                }\n                : {}\n        });\n        // Make the newly inserted cell active.\n        notebook.activeCellIndex = newIndex;\n        notebook.deselectAll();\n        Private.handleState(notebook, state, true);\n    }\n    NotebookActions.insertBelow = insertBelow;\n    function move(notebook, shift) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        const firstIndex = notebook.widgets.findIndex(w => notebook.isSelectedOrActive(w));\n        let lastIndex = notebook.widgets\n            .slice(firstIndex + 1)\n            .findIndex(w => !notebook.isSelectedOrActive(w));\n        if (lastIndex >= 0) {\n            lastIndex += firstIndex + 1;\n        }\n        else {\n            lastIndex = notebook.model.cells.length;\n        }\n        if (shift > 0) {\n            notebook.moveCell(firstIndex, lastIndex, lastIndex - firstIndex);\n        }\n        else {\n            notebook.moveCell(firstIndex, firstIndex + shift, lastIndex - firstIndex);\n        }\n        Private.handleState(notebook, state, true);\n    }\n    /**\n     * Move the selected cell(s) down.\n     *\n     * @param notebook = The target notebook widget.\n     */\n    function moveDown(notebook) {\n        move(notebook, 1);\n    }\n    NotebookActions.moveDown = moveDown;\n    /**\n     * Move the selected cell(s) up.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function moveUp(notebook) {\n        move(notebook, -1);\n    }\n    NotebookActions.moveUp = moveUp;\n    /**\n     * Change the selected cell type(s).\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @param value - The target cell type.\n     *\n     * #### Notes\n     * It should preserve the widget mode.\n     * This action can be undone.\n     * The existing selection will be cleared.\n     * Any cells converted to markdown will be unrendered.\n     */\n    function changeCellType(notebook, value) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        Private.changeCellType(notebook, value);\n        Private.handleState(notebook, state);\n    }\n    NotebookActions.changeCellType = changeCellType;\n    /**\n     * Run the selected cell(s).\n     *\n     * @param notebook - The target notebook widget.\n     * @param sessionContext - The client session object.\n     * @param sessionDialogs - The session dialogs.\n     * @param translator - The application translator.\n     *\n     * #### Notes\n     * The last selected cell will be activated, but not scrolled into view.\n     * The existing selection will be cleared.\n     * An execution error will prevent the remaining code cells from executing.\n     * All markdown cells will be rendered.\n     */\n    function run(notebook, sessionContext, sessionDialogs, translator) {\n        if (!notebook.model || !notebook.activeCell) {\n            return Promise.resolve(false);\n        }\n        const state = Private.getState(notebook);\n        const promise = Private.runSelected(notebook, sessionContext, sessionDialogs, translator);\n        Private.handleRunState(notebook, state, false);\n        return promise;\n    }\n    NotebookActions.run = run;\n    /**\n     * Run the selected cell(s) and advance to the next cell.\n     *\n     * @param notebook - The target notebook widget.\n     * @param sessionContext - The client session object.\n     * @param sessionDialogs - The session dialogs.\n     * @param translator - The application translator.\n     *\n     * #### Notes\n     * The existing selection will be cleared.\n     * The cell after the last selected cell will be activated and scrolled into view.\n     * An execution error will prevent the remaining code cells from executing.\n     * All markdown cells will be rendered.\n     * If the last selected cell is the last cell, a new code cell\n     * will be created in `'edit'` mode.  The new cell creation can be undone.\n     */\n    async function runAndAdvance(notebook, sessionContext, sessionDialogs, translator) {\n        var _a;\n        if (!notebook.model || !notebook.activeCell) {\n            return Promise.resolve(false);\n        }\n        const state = Private.getState(notebook);\n        const promise = Private.runSelected(notebook, sessionContext, sessionDialogs, translator);\n        const model = notebook.model;\n        if (notebook.activeCellIndex === notebook.widgets.length - 1) {\n            // Do not use push here, as we want an widget insertion\n            // to make sure no placeholder widget is rendered.\n            model.sharedModel.insertCell(notebook.widgets.length, {\n                cell_type: notebook.notebookConfig.defaultCell,\n                metadata: notebook.notebookConfig.defaultCell === 'code'\n                    ? {\n                        // This is an empty cell created by user, thus is trusted\n                        trusted: true\n                    }\n                    : {}\n            });\n            notebook.activeCellIndex++;\n            if (((_a = notebook.activeCell) === null || _a === void 0 ? void 0 : _a.inViewport) === false) {\n                await signalToPromise(notebook.activeCell.inViewportChanged, 200).catch(() => {\n                    // no-op\n                });\n            }\n            notebook.mode = 'edit';\n        }\n        else {\n            notebook.activeCellIndex++;\n        }\n        Private.handleState(notebook, state, true);\n        return promise;\n    }\n    NotebookActions.runAndAdvance = runAndAdvance;\n    /**\n     * Run the selected cell(s) and insert a new code cell.\n     *\n     * @param notebook - The target notebook widget.\n     * @param sessionContext - The client session object.\n     * @param sessionDialogs - The session dialogs.\n     * @param translator - The application translator.\n     *\n     * #### Notes\n     * An execution error will prevent the remaining code cells from executing.\n     * All markdown cells will be rendered.\n     * The widget mode will be set to `'edit'` after running.\n     * The existing selection will be cleared.\n     * The cell insert can be undone.\n     * The new cell will be scrolled into view.\n     */\n    async function runAndInsert(notebook, sessionContext, sessionDialogs, translator) {\n        var _a;\n        if (!notebook.model || !notebook.activeCell) {\n            return Promise.resolve(false);\n        }\n        const state = Private.getState(notebook);\n        const promise = Private.runSelected(notebook, sessionContext, sessionDialogs, translator);\n        const model = notebook.model;\n        model.sharedModel.insertCell(notebook.activeCellIndex + 1, {\n            cell_type: notebook.notebookConfig.defaultCell,\n            metadata: notebook.notebookConfig.defaultCell === 'code'\n                ? {\n                    // This is an empty cell created by user, thus is trusted\n                    trusted: true\n                }\n                : {}\n        });\n        notebook.activeCellIndex++;\n        if (((_a = notebook.activeCell) === null || _a === void 0 ? void 0 : _a.inViewport) === false) {\n            await signalToPromise(notebook.activeCell.inViewportChanged, 200).catch(() => {\n                // no-op\n            });\n        }\n        notebook.mode = 'edit';\n        Private.handleState(notebook, state, true);\n        return promise;\n    }\n    NotebookActions.runAndInsert = runAndInsert;\n    /**\n     * Run all of the cells in the notebook.\n     *\n     * @param notebook - The target notebook widget.\n     * @param sessionContext - The client session object.\n     * @param sessionDialogs - The session dialogs.\n     * @param translator - The application translator.\n     *\n     * #### Notes\n     * The existing selection will be cleared.\n     * An execution error will prevent the remaining code cells from executing.\n     * All markdown cells will be rendered.\n     * The last cell in the notebook will be activated and scrolled into view.\n     */\n    function runAll(notebook, sessionContext, sessionDialogs, translator) {\n        if (!notebook.model || !notebook.activeCell) {\n            return Promise.resolve(false);\n        }\n        const state = Private.getState(notebook);\n        notebook.widgets.forEach(child => {\n            notebook.select(child);\n        });\n        const promise = Private.runSelected(notebook, sessionContext, sessionDialogs, translator);\n        Private.handleRunState(notebook, state, true);\n        return promise;\n    }\n    NotebookActions.runAll = runAll;\n    function renderAllMarkdown(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return Promise.resolve(false);\n        }\n        const previousIndex = notebook.activeCellIndex;\n        const state = Private.getState(notebook);\n        notebook.widgets.forEach((child, index) => {\n            if (child.model.type === 'markdown') {\n                notebook.select(child);\n                // This is to make sure that the activeCell\n                // does not get executed\n                notebook.activeCellIndex = index;\n            }\n        });\n        if (notebook.activeCell.model.type !== 'markdown') {\n            return Promise.resolve(true);\n        }\n        const promise = Private.runSelected(notebook);\n        notebook.activeCellIndex = previousIndex;\n        Private.handleRunState(notebook, state, true);\n        return promise;\n    }\n    NotebookActions.renderAllMarkdown = renderAllMarkdown;\n    /**\n     * Run all of the cells before the currently active cell (exclusive).\n     *\n     * @param notebook - The target notebook widget.\n     * @param sessionContext - The client session object.\n     * @param sessionDialogs - The session dialogs.\n     * @param translator - The application translator.\n     *\n     * #### Notes\n     * The existing selection will be cleared.\n     * An execution error will prevent the remaining code cells from executing.\n     * All markdown cells will be rendered.\n     * The currently active cell will remain selected.\n     */\n    function runAllAbove(notebook, sessionContext, sessionDialogs, translator) {\n        const { activeCell, activeCellIndex, model } = notebook;\n        if (!model || !activeCell || activeCellIndex < 1) {\n            return Promise.resolve(false);\n        }\n        const state = Private.getState(notebook);\n        notebook.activeCellIndex--;\n        notebook.deselectAll();\n        for (let i = 0; i < notebook.activeCellIndex; ++i) {\n            notebook.select(notebook.widgets[i]);\n        }\n        const promise = Private.runSelected(notebook, sessionContext, sessionDialogs, translator);\n        notebook.activeCellIndex++;\n        Private.handleRunState(notebook, state, true);\n        return promise;\n    }\n    NotebookActions.runAllAbove = runAllAbove;\n    /**\n     * Run all of the cells after the currently active cell (inclusive).\n     *\n     * @param notebook - The target notebook widget.\n     * @param sessionContext - The client session object.\n     * @param sessionDialogs - The session dialogs.\n     * @param translator - The application translator.\n     *\n     * #### Notes\n     * The existing selection will be cleared.\n     * An execution error will prevent the remaining code cells from executing.\n     * All markdown cells will be rendered.\n     * The last cell in the notebook will be activated and scrolled into view.\n     */\n    function runAllBelow(notebook, sessionContext, sessionDialogs, translator) {\n        if (!notebook.model || !notebook.activeCell) {\n            return Promise.resolve(false);\n        }\n        const state = Private.getState(notebook);\n        notebook.deselectAll();\n        for (let i = notebook.activeCellIndex; i < notebook.widgets.length; ++i) {\n            notebook.select(notebook.widgets[i]);\n        }\n        const promise = Private.runSelected(notebook, sessionContext, sessionDialogs, translator);\n        Private.handleRunState(notebook, state, true);\n        return promise;\n    }\n    NotebookActions.runAllBelow = runAllBelow;\n    /**\n     * Replaces the selection in the active cell of the notebook.\n     *\n     * @param notebook - The target notebook widget.\n     * @param text - The text to replace the selection.\n     */\n    function replaceSelection(notebook, text) {\n        var _a, _b, _c;\n        if (!notebook.model || !((_a = notebook.activeCell) === null || _a === void 0 ? void 0 : _a.editor)) {\n            return;\n        }\n        (_c = (_b = notebook.activeCell.editor).replaceSelection) === null || _c === void 0 ? void 0 : _c.call(_b, text);\n    }\n    NotebookActions.replaceSelection = replaceSelection;\n    /**\n     * Select the above the active cell.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * The widget mode will be preserved.\n     * This is a no-op if the first cell is the active cell.\n     * This will skip any collapsed cells.\n     * The existing selection will be cleared.\n     */\n    function selectAbove(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        if (notebook.activeCellIndex === 0) {\n            return;\n        }\n        let possibleNextCellIndex = notebook.activeCellIndex - 1;\n        // find first non hidden cell above current cell\n        while (possibleNextCellIndex >= 0) {\n            const possibleNextCell = notebook.widgets[possibleNextCellIndex];\n            if (!possibleNextCell.inputHidden && !possibleNextCell.isHidden) {\n                break;\n            }\n            possibleNextCellIndex -= 1;\n        }\n        const state = Private.getState(notebook);\n        notebook.activeCellIndex = possibleNextCellIndex;\n        notebook.deselectAll();\n        Private.handleState(notebook, state, true);\n    }\n    NotebookActions.selectAbove = selectAbove;\n    /**\n     * Select the cell below the active cell.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * The widget mode will be preserved.\n     * This is a no-op if the last cell is the active cell.\n     * This will skip any collapsed cells.\n     * The existing selection will be cleared.\n     */\n    function selectBelow(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        let maxCellIndex = notebook.widgets.length - 1;\n        // Find last non-hidden cell\n        while (notebook.widgets[maxCellIndex].isHidden ||\n            notebook.widgets[maxCellIndex].inputHidden) {\n            maxCellIndex -= 1;\n        }\n        if (notebook.activeCellIndex === maxCellIndex) {\n            const footer = notebook.layout.footer;\n            footer === null || footer === void 0 ? void 0 : footer.node.focus();\n            return;\n        }\n        let possibleNextCellIndex = notebook.activeCellIndex + 1;\n        // find first non hidden cell below current cell\n        while (possibleNextCellIndex < maxCellIndex) {\n            let possibleNextCell = notebook.widgets[possibleNextCellIndex];\n            if (!possibleNextCell.inputHidden && !possibleNextCell.isHidden) {\n                break;\n            }\n            possibleNextCellIndex += 1;\n        }\n        const state = Private.getState(notebook);\n        notebook.activeCellIndex = possibleNextCellIndex;\n        notebook.deselectAll();\n        Private.handleState(notebook, state, true);\n    }\n    NotebookActions.selectBelow = selectBelow;\n    /** Insert new heading of same level above active cell.\n     *\n     * @param notebook - The target notebook widget\n     */\n    async function insertSameLevelHeadingAbove(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        let headingLevel = Private.Headings.determineHeadingLevel(notebook.activeCell, notebook);\n        if (headingLevel == -1) {\n            await Private.Headings.insertHeadingAboveCellIndex(0, 1, notebook);\n        }\n        else {\n            await Private.Headings.insertHeadingAboveCellIndex(notebook.activeCellIndex, headingLevel, notebook);\n        }\n    }\n    NotebookActions.insertSameLevelHeadingAbove = insertSameLevelHeadingAbove;\n    /** Insert new heading of same level at end of current section.\n     *\n     * @param notebook - The target notebook widget\n     */\n    async function insertSameLevelHeadingBelow(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        let headingLevel = Private.Headings.determineHeadingLevel(notebook.activeCell, notebook);\n        headingLevel = headingLevel > -1 ? headingLevel : 1;\n        let cellIdxOfHeadingBelow = Private.Headings.findLowerEqualLevelHeadingBelow(notebook.activeCell, notebook, true);\n        await Private.Headings.insertHeadingAboveCellIndex(cellIdxOfHeadingBelow == -1\n            ? notebook.model.cells.length\n            : cellIdxOfHeadingBelow, headingLevel, notebook);\n    }\n    NotebookActions.insertSameLevelHeadingBelow = insertSameLevelHeadingBelow;\n    /**\n     * Select the heading above the active cell or, if already at heading, collapse it.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * The widget mode will be preserved.\n     * This is a no-op if the active cell is the topmost heading in collapsed state\n     * The existing selection will be cleared.\n     */\n    function selectHeadingAboveOrCollapseHeading(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        let hInfoActiveCell = getHeadingInfo(notebook.activeCell);\n        // either collapse or find the right heading to jump to\n        if (hInfoActiveCell.isHeading && !hInfoActiveCell.collapsed) {\n            setHeadingCollapse(notebook.activeCell, true, notebook);\n        }\n        else {\n            let targetHeadingCellIdx = Private.Headings.findLowerEqualLevelParentHeadingAbove(notebook.activeCell, notebook, true);\n            if (targetHeadingCellIdx > -1) {\n                notebook.activeCellIndex = targetHeadingCellIdx;\n            }\n        }\n        // clear selection and handle state\n        notebook.deselectAll();\n        Private.handleState(notebook, state, true);\n    }\n    NotebookActions.selectHeadingAboveOrCollapseHeading = selectHeadingAboveOrCollapseHeading;\n    /**\n     * Select the heading below the active cell or, if already at heading, expand it.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * The widget mode will be preserved.\n     * This is a no-op if the active cell is the last heading in expanded state\n     * The existing selection will be cleared.\n     */\n    function selectHeadingBelowOrExpandHeading(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        let hInfo = getHeadingInfo(notebook.activeCell);\n        if (hInfo.isHeading && hInfo.collapsed) {\n            setHeadingCollapse(notebook.activeCell, false, notebook);\n        }\n        else {\n            let targetHeadingCellIdx = Private.Headings.findHeadingBelow(notebook.activeCell, notebook, true // return index of heading cell\n            );\n            if (targetHeadingCellIdx > -1) {\n                notebook.activeCellIndex = targetHeadingCellIdx;\n            }\n        }\n        notebook.deselectAll();\n        Private.handleState(notebook, state, true);\n    }\n    NotebookActions.selectHeadingBelowOrExpandHeading = selectHeadingBelowOrExpandHeading;\n    /**\n     * Extend the selection to the cell above.\n     *\n     * @param notebook - The target notebook widget.\n     * @param toTop - If true, denotes selection to extend to the top.\n     *\n     * #### Notes\n     * This is a no-op if the first cell is the active cell.\n     * The new cell will be activated.\n     */\n    function extendSelectionAbove(notebook, toTop = false) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        // Do not wrap around.\n        if (notebook.activeCellIndex === 0) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.mode = 'command';\n        // Check if toTop is true, if yes, selection is made to the top.\n        if (toTop) {\n            notebook.extendContiguousSelectionTo(0);\n        }\n        else {\n            notebook.extendContiguousSelectionTo(notebook.activeCellIndex - 1);\n        }\n        Private.handleState(notebook, state, true);\n    }\n    NotebookActions.extendSelectionAbove = extendSelectionAbove;\n    /**\n     * Extend the selection to the cell below.\n     *\n     * @param notebook - The target notebook widget.\n     * @param toBottom - If true, denotes selection to extend to the bottom.\n     *\n     * #### Notes\n     * This is a no-op if the last cell is the active cell.\n     * The new cell will be activated.\n     */\n    function extendSelectionBelow(notebook, toBottom = false) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        // Do not wrap around.\n        if (notebook.activeCellIndex === notebook.widgets.length - 1) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.mode = 'command';\n        // Check if toBottom is true, if yes selection is made to the bottom.\n        if (toBottom) {\n            notebook.extendContiguousSelectionTo(notebook.widgets.length - 1);\n        }\n        else {\n            notebook.extendContiguousSelectionTo(notebook.activeCellIndex + 1);\n        }\n        Private.handleState(notebook, state, true);\n    }\n    NotebookActions.extendSelectionBelow = extendSelectionBelow;\n    /**\n     * Select all of the cells of the notebook.\n     *\n     * @param notebook - the target notebook widget.\n     */\n    function selectAll(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        notebook.widgets.forEach(child => {\n            notebook.select(child);\n        });\n    }\n    NotebookActions.selectAll = selectAll;\n    /**\n     * Deselect all of the cells of the notebook.\n     *\n     * @param notebook - the target notebook widget.\n     */\n    function deselectAll(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        notebook.deselectAll();\n    }\n    NotebookActions.deselectAll = deselectAll;\n    /**\n     * Copy the selected cell(s) data to a clipboard.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function copy(notebook) {\n        Private.copyOrCut(notebook, false);\n    }\n    NotebookActions.copy = copy;\n    /**\n     * Cut the selected cell data to a clipboard.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * This action can be undone.\n     * A new code cell is added if all cells are cut.\n     */\n    function cut(notebook) {\n        Private.copyOrCut(notebook, true);\n    }\n    NotebookActions.cut = cut;\n    /**\n     * Paste cells from the application clipboard.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @param mode - the mode of adding cells:\n     *   'below' (default) adds cells below the active cell,\n     *   'belowSelected' adds cells below all selected cells,\n     *   'above' adds cells above the active cell, and\n     *   'replace' removes the currently selected cells and adds cells in their place.\n     *\n     * #### Notes\n     * The last pasted cell becomes the active cell.\n     * This is a no-op if there is no cell data on the clipboard.\n     * This action can be undone.\n     */\n    function paste(notebook, mode = 'below') {\n        const clipboard = Clipboard.getInstance();\n        if (!clipboard.hasData(JUPYTER_CELL_MIME)) {\n            return;\n        }\n        const values = clipboard.getData(JUPYTER_CELL_MIME);\n        addCells(notebook, mode, values, true);\n    }\n    NotebookActions.paste = paste;\n    /**\n     * Duplicate selected cells in the notebook without using the application clipboard.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @param mode - the mode of adding cells:\n     *   'below' (default) adds cells below the active cell,\n     *   'belowSelected' adds cells below all selected cells,\n     *   'above' adds cells above the active cell, and\n     *   'replace' removes the currently selected cells and adds cells in their place.\n     *\n     * #### Notes\n     * The last pasted cell becomes the active cell.\n     * This is a no-op if there is no cell data on the clipboard.\n     * This action can be undone.\n     */\n    function duplicate(notebook, mode = 'below') {\n        const values = Private.selectedCells(notebook);\n        if (!values || values.length === 0) {\n            return;\n        }\n        addCells(notebook, mode, values, false); // Cells not from the clipboard\n    }\n    NotebookActions.duplicate = duplicate;\n    /**\n     * Adds cells to the notebook.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @param mode - the mode of adding cells:\n     *   'below' (default) adds cells below the active cell,\n     *   'belowSelected' adds cells below all selected cells,\n     *   'above' adds cells above the active cell, and\n     *   'replace' removes the currently selected cells and adds cells in their place.\n     *\n     * @param values — The cells to add to the notebook.\n     *\n     * @param cellsFromClipboard — True if the cells were sourced from the clipboard.\n     *\n     * #### Notes\n     * The last added cell becomes the active cell.\n     * This is a no-op if values is an empty array.\n     * This action can be undone.\n     */\n    function addCells(notebook, mode = 'below', values, cellsFromClipboard = false) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        const model = notebook.model;\n        notebook.mode = 'command';\n        let index = 0;\n        const prevActiveCellIndex = notebook.activeCellIndex;\n        model.sharedModel.transact(() => {\n            // Set the starting index of the paste operation depending upon the mode.\n            switch (mode) {\n                case 'below':\n                    index = notebook.activeCellIndex + 1;\n                    break;\n                case 'belowSelected':\n                    notebook.widgets.forEach((child, childIndex) => {\n                        if (notebook.isSelectedOrActive(child)) {\n                            index = childIndex + 1;\n                        }\n                    });\n                    break;\n                case 'above':\n                    index = notebook.activeCellIndex;\n                    break;\n                case 'replace': {\n                    // Find the cells to delete.\n                    const toDelete = [];\n                    notebook.widgets.forEach((child, index) => {\n                        const deletable = child.model.sharedModel.getMetadata('deletable') !== false;\n                        if (notebook.isSelectedOrActive(child) && deletable) {\n                            toDelete.push(index);\n                        }\n                    });\n                    // If cells are not deletable, we may not have anything to delete.\n                    if (toDelete.length > 0) {\n                        // Delete the cells as one undo event.\n                        toDelete.reverse().forEach(i => {\n                            model.sharedModel.deleteCell(i);\n                        });\n                    }\n                    index = toDelete[0];\n                    break;\n                }\n                default:\n                    break;\n            }\n            model.sharedModel.insertCells(index, values.map(cell => {\n                cell.id =\n                    cell.cell_type === 'code' &&\n                        notebook.lastClipboardInteraction === 'cut' &&\n                        typeof cell.id === 'string'\n                        ? cell.id\n                        : undefined;\n                return cell;\n            }));\n        });\n        notebook.activeCellIndex = prevActiveCellIndex + values.length;\n        notebook.deselectAll();\n        if (cellsFromClipboard) {\n            notebook.lastClipboardInteraction = 'paste';\n        }\n        Private.handleState(notebook, state, true);\n    }\n    /**\n     * Undo a cell action.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * This is a no-op if there are no cell actions to undo.\n     */\n    function undo(notebook) {\n        if (!notebook.model) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.mode = 'command';\n        notebook.model.sharedModel.undo();\n        notebook.deselectAll();\n        Private.handleState(notebook, state);\n    }\n    NotebookActions.undo = undo;\n    /**\n     * Redo a cell action.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * This is a no-op if there are no cell actions to redo.\n     */\n    function redo(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.mode = 'command';\n        notebook.model.sharedModel.redo();\n        notebook.deselectAll();\n        Private.handleState(notebook, state);\n    }\n    NotebookActions.redo = redo;\n    /**\n     * Toggle the line number of all cells.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * The original state is based on the state of the active cell.\n     * The `mode` of the widget will be preserved.\n     */\n    function toggleAllLineNumbers(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        const config = notebook.editorConfig;\n        const lineNumbers = !(config.code.lineNumbers &&\n            config.markdown.lineNumbers &&\n            config.raw.lineNumbers);\n        const newConfig = {\n            code: { ...config.code, lineNumbers },\n            markdown: { ...config.markdown, lineNumbers },\n            raw: { ...config.raw, lineNumbers }\n        };\n        notebook.editorConfig = newConfig;\n        Private.handleState(notebook, state);\n    }\n    NotebookActions.toggleAllLineNumbers = toggleAllLineNumbers;\n    /**\n     * Clear the code outputs of the selected cells.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * The widget `mode` will be preserved.\n     */\n    function clearOutputs(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        let index = -1;\n        for (const cell of notebook.model.cells) {\n            const child = notebook.widgets[++index];\n            if (notebook.isSelectedOrActive(child) && cell.type === 'code') {\n                cell.sharedModel.transact(() => {\n                    cell.clearExecution();\n                    child.outputHidden = false;\n                }, false);\n            }\n        }\n        Private.handleState(notebook, state, true);\n    }\n    NotebookActions.clearOutputs = clearOutputs;\n    /**\n     * Clear all the code outputs on the widget.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * The widget `mode` will be preserved.\n     */\n    function clearAllOutputs(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        let index = -1;\n        for (const cell of notebook.model.cells) {\n            const child = notebook.widgets[++index];\n            if (cell.type === 'code') {\n                cell.sharedModel.transact(() => {\n                    cell.clearExecution();\n                    child.outputHidden = false;\n                }, false);\n            }\n        }\n        Private.handleState(notebook, state, true);\n    }\n    NotebookActions.clearAllOutputs = clearAllOutputs;\n    /**\n     * Hide the code on selected code cells.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function hideCode(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.widgets.forEach(cell => {\n            if (notebook.isSelectedOrActive(cell) && cell.model.type === 'code') {\n                cell.inputHidden = true;\n            }\n        });\n        Private.handleState(notebook, state);\n    }\n    NotebookActions.hideCode = hideCode;\n    /**\n     * Show the code on selected code cells.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function showCode(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.widgets.forEach(cell => {\n            if (notebook.isSelectedOrActive(cell) && cell.model.type === 'code') {\n                cell.inputHidden = false;\n            }\n        });\n        Private.handleState(notebook, state);\n    }\n    NotebookActions.showCode = showCode;\n    /**\n     * Hide the code on all code cells.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function hideAllCode(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.widgets.forEach(cell => {\n            if (cell.model.type === 'code') {\n                cell.inputHidden = true;\n            }\n        });\n        Private.handleState(notebook, state);\n    }\n    NotebookActions.hideAllCode = hideAllCode;\n    /**\n     * Show the code on all code cells.\n     *\n     * @param widget - The target notebook widget.\n     */\n    function showAllCode(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.widgets.forEach(cell => {\n            if (cell.model.type === 'code') {\n                cell.inputHidden = false;\n            }\n        });\n        Private.handleState(notebook, state);\n    }\n    NotebookActions.showAllCode = showAllCode;\n    /**\n     * Hide the output on selected code cells.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function hideOutput(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.widgets.forEach(cell => {\n            if (notebook.isSelectedOrActive(cell) && cell.model.type === 'code') {\n                cell.outputHidden = true;\n            }\n        });\n        Private.handleState(notebook, state, true);\n    }\n    NotebookActions.hideOutput = hideOutput;\n    /**\n     * Show the output on selected code cells.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function showOutput(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.widgets.forEach(cell => {\n            if (notebook.isSelectedOrActive(cell) && cell.model.type === 'code') {\n                cell.outputHidden = false;\n            }\n        });\n        Private.handleState(notebook, state);\n    }\n    NotebookActions.showOutput = showOutput;\n    /**\n     * Hide the output on all code cells.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function hideAllOutputs(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.widgets.forEach(cell => {\n            if (cell.model.type === 'code') {\n                cell.outputHidden = true;\n            }\n        });\n        Private.handleState(notebook, state, true);\n    }\n    NotebookActions.hideAllOutputs = hideAllOutputs;\n    /**\n     * Render side-by-side.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function renderSideBySide(notebook) {\n        notebook.renderingLayout = 'side-by-side';\n    }\n    NotebookActions.renderSideBySide = renderSideBySide;\n    /**\n     * Render not side-by-side.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function renderDefault(notebook) {\n        notebook.renderingLayout = 'default';\n    }\n    NotebookActions.renderDefault = renderDefault;\n    /**\n     * Show the output on all code cells.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function showAllOutputs(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.widgets.forEach(cell => {\n            if (cell.model.type === 'code') {\n                cell.outputHidden = false;\n            }\n        });\n        Private.handleState(notebook, state);\n    }\n    NotebookActions.showAllOutputs = showAllOutputs;\n    /**\n     * Enable output scrolling for all selected cells.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function enableOutputScrolling(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.widgets.forEach(cell => {\n            if (notebook.isSelectedOrActive(cell) && cell.model.type === 'code') {\n                cell.outputsScrolled = true;\n            }\n        });\n        Private.handleState(notebook, state, true);\n    }\n    NotebookActions.enableOutputScrolling = enableOutputScrolling;\n    /**\n     * Disable output scrolling for all selected cells.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function disableOutputScrolling(notebook) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        notebook.widgets.forEach(cell => {\n            if (notebook.isSelectedOrActive(cell) && cell.model.type === 'code') {\n                cell.outputsScrolled = false;\n            }\n        });\n        Private.handleState(notebook, state);\n    }\n    NotebookActions.disableOutputScrolling = disableOutputScrolling;\n    /**\n     * Go to the last cell that is run or current if it is running.\n     *\n     * Note: This requires execution timing to be toggled on or this will have\n     * no effect.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function selectLastRunCell(notebook) {\n        let latestTime = null;\n        let latestCellIdx = null;\n        notebook.widgets.forEach((cell, cellIndx) => {\n            if (cell.model.type === 'code') {\n                const execution = cell.model.getMetadata('execution');\n                if (execution &&\n                    JSONExt.isObject(execution) &&\n                    execution['iopub.status.busy'] !== undefined) {\n                    // The busy status is used as soon as a request is received:\n                    // https://jupyter-client.readthedocs.io/en/stable/messaging.html\n                    const timestamp = execution['iopub.status.busy'].toString();\n                    if (timestamp) {\n                        const startTime = new Date(timestamp);\n                        if (!latestTime || startTime >= latestTime) {\n                            latestTime = startTime;\n                            latestCellIdx = cellIndx;\n                        }\n                    }\n                }\n            }\n        });\n        if (latestCellIdx !== null) {\n            notebook.activeCellIndex = latestCellIdx;\n        }\n    }\n    NotebookActions.selectLastRunCell = selectLastRunCell;\n    /**\n     * Set the markdown header level.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @param level - The header level.\n     *\n     * #### Notes\n     * All selected cells will be switched to markdown.\n     * The level will be clamped between 1 and 6.\n     * If there is an existing header, it will be replaced.\n     * There will always be one blank space after the header.\n     * The cells will be unrendered.\n     */\n    function setMarkdownHeader(notebook, level) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = Private.getState(notebook);\n        const cells = notebook.model.cells;\n        level = Math.min(Math.max(level, 1), 6);\n        notebook.widgets.forEach((child, index) => {\n            if (notebook.isSelectedOrActive(child)) {\n                Private.setMarkdownHeader(cells.get(index), level);\n            }\n        });\n        Private.changeCellType(notebook, 'markdown');\n        Private.handleState(notebook, state);\n    }\n    NotebookActions.setMarkdownHeader = setMarkdownHeader;\n    /**\n     * Collapse all cells in given notebook.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function collapseAllHeadings(notebook) {\n        for (const cell of notebook.widgets) {\n            if (NotebookActions.getHeadingInfo(cell).isHeading) {\n                NotebookActions.setHeadingCollapse(cell, true, notebook);\n                NotebookActions.setCellCollapse(cell, true);\n            }\n        }\n    }\n    NotebookActions.collapseAllHeadings = collapseAllHeadings;\n    /**\n     * Un-collapse all cells in given notebook.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function expandAllHeadings(notebook) {\n        for (const cell of notebook.widgets) {\n            if (NotebookActions.getHeadingInfo(cell).isHeading) {\n                NotebookActions.setHeadingCollapse(cell, false, notebook);\n                // similar to collapseAll.\n                NotebookActions.setCellCollapse(cell, false);\n            }\n        }\n    }\n    NotebookActions.expandAllHeadings = expandAllHeadings;\n    function findNearestParentHeader(cell, notebook) {\n        const index = findIndex(notebook.widgets, (possibleCell, index) => {\n            return cell.model.id === possibleCell.model.id;\n        });\n        if (index === -1) {\n            return;\n        }\n        // Finds the nearest header above the given cell. If the cell is a header itself, it does not return itself;\n        // this can be checked directly by calling functions.\n        if (index >= notebook.widgets.length) {\n            return;\n        }\n        let childHeaderInfo = getHeadingInfo(notebook.widgets[index]);\n        for (let cellN = index - 1; cellN >= 0; cellN--) {\n            if (cellN < notebook.widgets.length) {\n                let hInfo = getHeadingInfo(notebook.widgets[cellN]);\n                if (hInfo.isHeading &&\n                    hInfo.headingLevel < childHeaderInfo.headingLevel) {\n                    return notebook.widgets[cellN];\n                }\n            }\n        }\n        // else no parent header found.\n        return;\n    }\n    /**\n     * Finds the \"parent\" heading of the given cell and expands.\n     * Used for the case that a cell becomes active that is within a collapsed heading.\n     * @param cell - \"Child\" cell that has become the active cell\n     * @param notebook - The target notebook widget.\n     */\n    function expandParent(cell, notebook) {\n        let nearestParentCell = findNearestParentHeader(cell, notebook);\n        if (!nearestParentCell) {\n            return;\n        }\n        if (!getHeadingInfo(nearestParentCell).collapsed &&\n            !nearestParentCell.isHidden) {\n            return;\n        }\n        if (nearestParentCell.isHidden) {\n            expandParent(nearestParentCell, notebook);\n        }\n        if (getHeadingInfo(nearestParentCell).collapsed) {\n            setHeadingCollapse(nearestParentCell, false, notebook);\n        }\n    }\n    NotebookActions.expandParent = expandParent;\n    /**\n     * Finds the next heading that isn't a child of the given markdown heading.\n     * @param cell - \"Child\" cell that has become the active cell\n     * @param notebook - The target notebook widget.\n     */\n    function findNextParentHeading(cell, notebook) {\n        let index = findIndex(notebook.widgets, (possibleCell, index) => {\n            return cell.model.id === possibleCell.model.id;\n        });\n        if (index === -1) {\n            return -1;\n        }\n        let childHeaderInfo = getHeadingInfo(cell);\n        for (index = index + 1; index < notebook.widgets.length; index++) {\n            let hInfo = getHeadingInfo(notebook.widgets[index]);\n            if (hInfo.isHeading &&\n                hInfo.headingLevel <= childHeaderInfo.headingLevel) {\n                return index;\n            }\n        }\n        // else no parent header found. return the index of the last cell\n        return notebook.widgets.length;\n    }\n    NotebookActions.findNextParentHeading = findNextParentHeading;\n    /**\n     * Set the given cell and ** all \"child\" cells **\n     * to the given collapse / expand if cell is\n     * a markdown header.\n     *\n     * @param cell - The cell\n     * @param collapsing - Whether to collapse or expand the cell\n     * @param notebook - The target notebook widget.\n     */\n    function setHeadingCollapse(cell, collapsing, notebook) {\n        const which = findIndex(notebook.widgets, (possibleCell, index) => {\n            return cell.model.id === possibleCell.model.id;\n        });\n        if (which === -1) {\n            return -1;\n        }\n        if (!notebook.widgets.length) {\n            return which + 1;\n        }\n        let selectedHeadingInfo = NotebookActions.getHeadingInfo(cell);\n        if (cell.isHidden ||\n            !(cell instanceof MarkdownCell) ||\n            !selectedHeadingInfo.isHeading) {\n            // otherwise collapsing and uncollapsing already hidden stuff can\n            // cause some funny looking bugs.\n            return which + 1;\n        }\n        let localCollapsed = false;\n        let localCollapsedLevel = 0;\n        // iterate through all cells after the active cell.\n        let cellNum;\n        for (cellNum = which + 1; cellNum < notebook.widgets.length; cellNum++) {\n            let subCell = notebook.widgets[cellNum];\n            let subCellHeadingInfo = NotebookActions.getHeadingInfo(subCell);\n            if (subCellHeadingInfo.isHeading &&\n                subCellHeadingInfo.headingLevel <= selectedHeadingInfo.headingLevel) {\n                // then reached an equivalent or higher heading level than the\n                // original the end of the collapse.\n                cellNum -= 1;\n                break;\n            }\n            if (localCollapsed &&\n                subCellHeadingInfo.isHeading &&\n                subCellHeadingInfo.headingLevel <= localCollapsedLevel) {\n                // then reached the end of the local collapsed, so unset NotebookActions.\n                localCollapsed = false;\n            }\n            if (collapsing || localCollapsed) {\n                // then no extra handling is needed for further locally collapsed\n                // headings.\n                subCell.setHidden(true);\n                continue;\n            }\n            if (subCellHeadingInfo.collapsed && subCellHeadingInfo.isHeading) {\n                localCollapsed = true;\n                localCollapsedLevel = subCellHeadingInfo.headingLevel;\n                // but don't collapse the locally collapsed heading, so continue to\n                // expand the heading. This will get noticed in the next round.\n            }\n            subCell.setHidden(false);\n        }\n        if (cellNum === notebook.widgets.length) {\n            cell.numberChildNodes = cellNum - which - 1;\n        }\n        else {\n            cell.numberChildNodes = cellNum - which;\n        }\n        NotebookActions.setCellCollapse(cell, collapsing);\n        return cellNum + 1;\n    }\n    NotebookActions.setHeadingCollapse = setHeadingCollapse;\n    /**\n     * Toggles the collapse state of the active cell of the given notebook\n     * and ** all of its \"child\" cells ** if the cell is a heading.\n     *\n     * @param notebook - The target notebook widget.\n     */\n    function toggleCurrentHeadingCollapse(notebook) {\n        if (!notebook.activeCell || notebook.activeCellIndex === undefined) {\n            return;\n        }\n        let headingInfo = NotebookActions.getHeadingInfo(notebook.activeCell);\n        if (headingInfo.isHeading) {\n            // Then toggle!\n            NotebookActions.setHeadingCollapse(notebook.activeCell, !headingInfo.collapsed, notebook);\n        }\n        notebook.scrollToItem(notebook.activeCellIndex).catch(reason => {\n            // no-op\n        });\n    }\n    NotebookActions.toggleCurrentHeadingCollapse = toggleCurrentHeadingCollapse;\n    /**\n     * If cell is a markdown heading, sets the headingCollapsed field,\n     * and otherwise hides the cell.\n     *\n     * @param cell - The cell to collapse / expand\n     * @param collapsing - Whether to collapse or expand the given cell\n     */\n    function setCellCollapse(cell, collapsing) {\n        if (cell instanceof MarkdownCell) {\n            cell.headingCollapsed = collapsing;\n        }\n        else {\n            cell.setHidden(collapsing);\n        }\n    }\n    NotebookActions.setCellCollapse = setCellCollapse;\n    /**\n     * If given cell is a markdown heading, returns the heading level.\n     * If given cell is not markdown, returns 7 (there are only 6 levels of markdown headings)\n     *\n     * @param cell - The target cell widget.\n     */\n    function getHeadingInfo(cell) {\n        if (!(cell instanceof MarkdownCell)) {\n            return { isHeading: false, headingLevel: 7 };\n        }\n        let level = cell.headingInfo.level;\n        let collapsed = cell.headingCollapsed;\n        return { isHeading: level > 0, headingLevel: level, collapsed: collapsed };\n    }\n    NotebookActions.getHeadingInfo = getHeadingInfo;\n    /**\n     * Trust the notebook after prompting the user.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @returns a promise that resolves when the transaction is finished.\n     *\n     * #### Notes\n     * No dialog will be presented if the notebook is already trusted.\n     */\n    function trust(notebook, translator) {\n        translator = translator || nullTranslator;\n        const trans = translator.load('jupyterlab');\n        if (!notebook.model) {\n            return Promise.resolve();\n        }\n        // Do nothing if already trusted.\n        const trusted = every(notebook.model.cells, cell => cell.trusted);\n        // FIXME\n        const trustMessage = (React.createElement(\"p\", null,\n            trans.__('A trusted Jupyter notebook may execute hidden malicious code when you open it.'),\n            React.createElement(\"br\", null),\n            trans.__('Selecting \"Trust\" will re-render this notebook in a trusted state.'),\n            React.createElement(\"br\", null),\n            trans.__('For more information, see'),\n            ' ',\n            React.createElement(\"a\", { href: \"https://jupyter-server.readthedocs.io/en/stable/operators/security.html\", target: \"_blank\", rel: \"noopener noreferrer\" }, trans.__('the Jupyter security documentation')),\n            \".\"));\n        if (trusted) {\n            return showDialog({\n                body: trans.__('Notebook is already trusted'),\n                buttons: [Dialog.okButton()]\n            }).then(() => undefined);\n        }\n        return showDialog({\n            body: trustMessage,\n            title: trans.__('Trust this notebook?'),\n            buttons: [\n                Dialog.cancelButton(),\n                Dialog.warnButton({\n                    label: trans.__('Trust'),\n                    ariaLabel: trans.__('Confirm Trusting this notebook')\n                })\n            ] // FIXME?\n        }).then(result => {\n            if (result.button.accept) {\n                if (notebook.model) {\n                    for (const cell of notebook.model.cells) {\n                        cell.trusted = true;\n                    }\n                }\n            }\n        });\n    }\n    NotebookActions.trust = trust;\n})(NotebookActions || (NotebookActions = {}));\n/**\n * A namespace for private data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * A signal that emits whenever a cell completes execution.\n     */\n    Private.executed = new Signal({});\n    /**\n     * A signal that emits whenever a cell execution is scheduled.\n     */\n    Private.executionScheduled = new Signal({});\n    /**\n     * A signal that emits when one notebook's cells are all executed.\n     */\n    Private.selectionExecuted = new Signal({});\n    /**\n     * Get the state of a widget before running an action.\n     */\n    function getState(notebook) {\n        var _a, _b;\n        return {\n            wasFocused: notebook.node.contains(document.activeElement),\n            activeCellId: (_b = (_a = notebook.activeCell) === null || _a === void 0 ? void 0 : _a.model.id) !== null && _b !== void 0 ? _b : null\n        };\n    }\n    Private.getState = getState;\n    /**\n     * Handle the state of a widget after running an action.\n     */\n    function handleState(notebook, state, scrollIfNeeded = false) {\n        const { activeCell, activeCellIndex } = notebook;\n        if (state.wasFocused || notebook.mode === 'edit') {\n            notebook.activate();\n        }\n        if (scrollIfNeeded && activeCell) {\n            notebook.scrollToItem(activeCellIndex, 'smart', 0.05).catch(reason => {\n                // no-op\n            });\n        }\n    }\n    Private.handleState = handleState;\n    /**\n     * Handle the state of a widget after running a run action.\n     */\n    function handleRunState(notebook, state, scroll = false) {\n        var _a;\n        if (state.wasFocused || notebook.mode === 'edit') {\n            notebook.activate();\n        }\n        if (scroll && state.activeCellId) {\n            const index = notebook.widgets.findIndex(w => w.model.id === state.activeCellId);\n            if ((_a = notebook.widgets[index]) === null || _a === void 0 ? void 0 : _a.inputArea) {\n                notebook.scrollToItem(index).catch(reason => {\n                    // no-op\n                });\n            }\n        }\n    }\n    Private.handleRunState = handleRunState;\n    /**\n     * Run the selected cells.\n     *\n     * @param notebook Notebook\n     * @param sessionContext Notebook session context\n     * @param sessionDialogs Session dialogs\n     * @param translator Application translator\n     */\n    function runSelected(notebook, sessionContext, sessionDialogs, translator) {\n        notebook.mode = 'command';\n        let lastIndex = notebook.activeCellIndex;\n        const selected = notebook.widgets.filter((child, index) => {\n            const active = notebook.isSelectedOrActive(child);\n            if (active) {\n                lastIndex = index;\n            }\n            return active;\n        });\n        notebook.activeCellIndex = lastIndex;\n        notebook.deselectAll();\n        return Promise.all(selected.map(child => runCell(notebook, child, sessionContext, sessionDialogs, translator)))\n            .then(results => {\n            if (notebook.isDisposed) {\n                return false;\n            }\n            Private.selectionExecuted.emit({\n                notebook,\n                lastCell: notebook.widgets[lastIndex]\n            });\n            // Post an update request.\n            notebook.update();\n            return results.every(result => result);\n        })\n            .catch(reason => {\n            if (reason.message.startsWith('KernelReplyNotOK')) {\n                selected.map(cell => {\n                    // Remove '*' prompt from cells that didn't execute\n                    if (cell.model.type === 'code' &&\n                        cell.model.executionCount == null) {\n                        cell.setPrompt('');\n                    }\n                });\n            }\n            else {\n                throw reason;\n            }\n            Private.selectionExecuted.emit({\n                notebook,\n                lastCell: notebook.widgets[lastIndex]\n            });\n            notebook.update();\n            return false;\n        });\n    }\n    Private.runSelected = runSelected;\n    /**\n     * Run a cell.\n     */\n    async function runCell(notebook, cell, sessionContext, sessionDialogs, translator) {\n        var _a, _b, _c;\n        translator = translator || nullTranslator;\n        const trans = translator.load('jupyterlab');\n        switch (cell.model.type) {\n            case 'markdown':\n                cell.rendered = true;\n                cell.inputHidden = false;\n                Private.executed.emit({ notebook, cell, success: true });\n                break;\n            case 'code':\n                if (sessionContext) {\n                    if (sessionContext.isTerminating) {\n                        await showDialog({\n                            title: trans.__('Kernel Terminating'),\n                            body: trans.__('The kernel for %1 appears to be terminating. You can not run any cell for now.', (_a = sessionContext.session) === null || _a === void 0 ? void 0 : _a.path),\n                            buttons: [Dialog.okButton()]\n                        });\n                        break;\n                    }\n                    if (sessionContext.pendingInput) {\n                        await showDialog({\n                            title: trans.__('Cell not executed due to pending input'),\n                            body: trans.__('The cell has not been executed to avoid kernel deadlock as there is another pending input! Submit your pending input and try again.'),\n                            buttons: [Dialog.okButton()]\n                        });\n                        return false;\n                    }\n                    if (sessionContext.hasNoKernel) {\n                        const shouldSelect = await sessionContext.startKernel();\n                        if (shouldSelect && sessionDialogs) {\n                            await sessionDialogs.selectKernel(sessionContext);\n                        }\n                    }\n                    if (sessionContext.hasNoKernel) {\n                        cell.model.sharedModel.transact(() => {\n                            cell.model.clearExecution();\n                        });\n                        return true;\n                    }\n                    const deletedCells = (_c = (_b = notebook.model) === null || _b === void 0 ? void 0 : _b.deletedCells) !== null && _c !== void 0 ? _c : [];\n                    Private.executionScheduled.emit({ notebook, cell });\n                    let ran = false;\n                    try {\n                        const reply = await CodeCell.execute(cell, sessionContext, {\n                            deletedCells,\n                            recordTiming: notebook.notebookConfig.recordTiming\n                        });\n                        deletedCells.splice(0, deletedCells.length);\n                        ran = (() => {\n                            if (cell.isDisposed) {\n                                return false;\n                            }\n                            if (!reply) {\n                                return true;\n                            }\n                            if (reply.content.status === 'ok') {\n                                const content = reply.content;\n                                if (content.payload && content.payload.length) {\n                                    handlePayload(content, notebook, cell);\n                                }\n                                return true;\n                            }\n                            else {\n                                throw new KernelError(reply.content);\n                            }\n                        })();\n                    }\n                    catch (reason) {\n                        if (cell.isDisposed || reason.message.startsWith('Canceled')) {\n                            ran = false;\n                        }\n                        else {\n                            Private.executed.emit({\n                                notebook,\n                                cell,\n                                success: false,\n                                error: reason\n                            });\n                            throw reason;\n                        }\n                    }\n                    if (ran) {\n                        Private.executed.emit({ notebook, cell, success: true });\n                    }\n                    return ran;\n                }\n                cell.model.sharedModel.transact(() => {\n                    cell.model.clearExecution();\n                }, false);\n                break;\n            default:\n                break;\n        }\n        return Promise.resolve(true);\n    }\n    /**\n     * Handle payloads from an execute reply.\n     *\n     * #### Notes\n     * Payloads are deprecated and there are no official interfaces for them in\n     * the kernel type definitions.\n     * See [Payloads (DEPRECATED)](https://jupyter-client.readthedocs.io/en/latest/messaging.html#payloads-deprecated).\n     */\n    function handlePayload(content, notebook, cell) {\n        var _a;\n        const setNextInput = (_a = content.payload) === null || _a === void 0 ? void 0 : _a.filter(i => {\n            return i.source === 'set_next_input';\n        })[0];\n        if (!setNextInput) {\n            return;\n        }\n        const text = setNextInput.text;\n        const replace = setNextInput.replace;\n        if (replace) {\n            cell.model.sharedModel.setSource(text);\n            return;\n        }\n        // Create a new code cell and add as the next cell.\n        const notebookModel = notebook.model.sharedModel;\n        const cells = notebook.model.cells;\n        const index = findIndex(cells, model => model === cell.model);\n        // While this cell has no outputs and could be trusted following the letter\n        // of Jupyter trust model, its content comes from kernel and hence is not\n        // necessarily controlled by the user; if we set it as trusted, a user\n        // executing cells in succession could end up with unwanted trusted output.\n        if (index === -1) {\n            notebookModel.insertCell(notebookModel.cells.length, {\n                cell_type: 'code',\n                source: text,\n                metadata: {\n                    trusted: false\n                }\n            });\n        }\n        else {\n            notebookModel.insertCell(index + 1, {\n                cell_type: 'code',\n                source: text,\n                metadata: {\n                    trusted: false\n                }\n            });\n        }\n    }\n    /**\n     * Get the selected cell(s) without affecting the clipboard.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @returns A list of 0 or more selected cells\n     */\n    function selectedCells(notebook) {\n        return notebook.widgets\n            .filter(cell => notebook.isSelectedOrActive(cell))\n            .map(cell => cell.model.toJSON())\n            .map(cellJSON => {\n            if (cellJSON.metadata.deletable !== undefined) {\n                delete cellJSON.metadata.deletable;\n            }\n            return cellJSON;\n        });\n    }\n    Private.selectedCells = selectedCells;\n    /**\n     * Copy or cut the selected cell data to the application clipboard.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @param cut - True if the cells should be cut, false if they should be copied.\n     */\n    function copyOrCut(notebook, cut) {\n        if (!notebook.model || !notebook.activeCell) {\n            return;\n        }\n        const state = getState(notebook);\n        const clipboard = Clipboard.getInstance();\n        notebook.mode = 'command';\n        clipboard.clear();\n        const data = Private.selectedCells(notebook);\n        clipboard.setData(JUPYTER_CELL_MIME, data);\n        if (cut) {\n            deleteCells(notebook);\n        }\n        else {\n            notebook.deselectAll();\n        }\n        if (cut) {\n            notebook.lastClipboardInteraction = 'cut';\n        }\n        else {\n            notebook.lastClipboardInteraction = 'copy';\n        }\n        handleState(notebook, state);\n    }\n    Private.copyOrCut = copyOrCut;\n    /**\n     * Change the selected cell type(s).\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * @param value - The target cell type.\n     *\n     * #### Notes\n     * It should preserve the widget mode.\n     * This action can be undone.\n     * The existing selection will be cleared.\n     * Any cells converted to markdown will be unrendered.\n     */\n    function changeCellType(notebook, value) {\n        const notebookSharedModel = notebook.model.sharedModel;\n        notebook.widgets.forEach((child, index) => {\n            if (!notebook.isSelectedOrActive(child)) {\n                return;\n            }\n            if (child.model.type !== value) {\n                const raw = child.model.toJSON();\n                notebookSharedModel.transact(() => {\n                    notebookSharedModel.deleteCell(index);\n                    if (value === 'code') {\n                        // After change of type outputs are deleted so cell can be trusted.\n                        raw.metadata.trusted = true;\n                    }\n                    else {\n                        // Otherwise clear the metadata as trusted is only \"valid\" on code\n                        // cells (since other cell types cannot have outputs).\n                        raw.metadata.trusted = undefined;\n                    }\n                    const newCell = notebookSharedModel.insertCell(index, {\n                        cell_type: value,\n                        source: raw.source,\n                        metadata: raw.metadata\n                    });\n                    if (raw.attachments && ['markdown', 'raw'].includes(value)) {\n                        newCell.attachments =\n                            raw.attachments;\n                    }\n                });\n            }\n            if (value === 'markdown') {\n                // Fetch the new widget and unrender it.\n                child = notebook.widgets[index];\n                child.rendered = false;\n            }\n        });\n        notebook.deselectAll();\n    }\n    Private.changeCellType = changeCellType;\n    /**\n     * Delete the selected cells.\n     *\n     * @param notebook - The target notebook widget.\n     *\n     * #### Notes\n     * The cell after the last selected cell will be activated.\n     * If the last cell is deleted, then the previous one will be activated.\n     * It will add a code cell if all cells are deleted.\n     * This action can be undone.\n     */\n    function deleteCells(notebook) {\n        const model = notebook.model;\n        const sharedModel = model.sharedModel;\n        const toDelete = [];\n        notebook.mode = 'command';\n        // Find the cells to delete.\n        notebook.widgets.forEach((child, index) => {\n            var _a;\n            const deletable = child.model.getMetadata('deletable') !== false;\n            if (notebook.isSelectedOrActive(child) && deletable) {\n                toDelete.push(index);\n                (_a = notebook.model) === null || _a === void 0 ? void 0 : _a.deletedCells.push(child.model.id);\n            }\n        });\n        // If cells are not deletable, we may not have anything to delete.\n        if (toDelete.length > 0) {\n            // Delete the cells as one undo event.\n            sharedModel.transact(() => {\n                // Delete cells in reverse order to maintain the correct indices.\n                toDelete.reverse().forEach(index => {\n                    sharedModel.deleteCell(index);\n                });\n                // Add a new cell if the notebook is empty. This is done\n                // within the compound operation to make the deletion of\n                // a notebook's last cell undoable.\n                if (sharedModel.cells.length == toDelete.length) {\n                    sharedModel.insertCell(0, {\n                        cell_type: notebook.notebookConfig.defaultCell,\n                        metadata: notebook.notebookConfig.defaultCell === 'code'\n                            ? {\n                                // This is an empty cell created in empty notebook, thus is trusted\n                                trusted: true\n                            }\n                            : {}\n                    });\n                }\n            });\n            // Select the *first* interior cell not deleted or the cell\n            // *after* the last selected cell.\n            // Note: The activeCellIndex is clamped to the available cells,\n            // so if the last cell is deleted the previous cell will be activated.\n            // The *first* index is the index of the last cell in the initial\n            // toDelete list due to the `reverse` operation above.\n            notebook.activeCellIndex = toDelete[0] - toDelete.length + 1;\n        }\n        // Deselect any remaining, undeletable cells. Do this even if we don't\n        // delete anything so that users are aware *something* happened.\n        notebook.deselectAll();\n    }\n    Private.deleteCells = deleteCells;\n    /**\n     * Set the markdown header level of a cell.\n     */\n    function setMarkdownHeader(cell, level) {\n        // Remove existing header or leading white space.\n        let source = cell.sharedModel.getSource();\n        const regex = /^(#+\\s*)|^(\\s*)/;\n        const newHeader = Array(level + 1).join('#') + ' ';\n        const matches = regex.exec(source);\n        if (matches) {\n            source = source.slice(matches[0].length);\n        }\n        cell.sharedModel.setSource(newHeader + source);\n    }\n    Private.setMarkdownHeader = setMarkdownHeader;\n    /** Functionality related to collapsible headings */\n    let Headings;\n    (function (Headings) {\n        /** Find the heading that is parent to cell.\n         *\n         * @param childCell - The cell that is child to the sought heading\n         * @param notebook - The target notebook widget\n         * @param includeChildCell [default=false] - if set to true and childCell is a heading itself, the childCell will be returned\n         * @param returnIndex [default=false] - if set to true, the cell index is returned rather than the cell object.\n         *\n         * @returns the (index | Cell object) of the parent heading or (-1 | null) if there is no parent heading.\n         */\n        function findParentHeading(childCell, notebook, includeChildCell = false, returnIndex = false) {\n            let cellIdx = notebook.widgets.indexOf(childCell) - (includeChildCell ? 1 : 0);\n            while (cellIdx >= 0) {\n                let headingInfo = NotebookActions.getHeadingInfo(notebook.widgets[cellIdx]);\n                if (headingInfo.isHeading) {\n                    return returnIndex ? cellIdx : notebook.widgets[cellIdx];\n                }\n                cellIdx--;\n            }\n            return returnIndex ? -1 : null;\n        }\n        Headings.findParentHeading = findParentHeading;\n        /** Find heading above with leq level than baseCell heading level.\n         *\n         * @param baseCell - cell relative to which so search\n         * @param notebook - target notebook widget\n         * @param returnIndex [default=false] - if set to true, the cell index is returned rather than the cell object.\n         *\n         * @returns the (index | Cell object) of the found heading or (-1 | null) if no heading found.\n         */\n        function findLowerEqualLevelParentHeadingAbove(baseCell, notebook, returnIndex = false) {\n            let baseHeadingLevel = Private.Headings.determineHeadingLevel(baseCell, notebook);\n            if (baseHeadingLevel == -1) {\n                baseHeadingLevel = 1; // if no heading level can be determined, assume we're on level 1\n            }\n            // find the heading above with heading level <= baseHeadingLevel and return its index\n            let cellIdx = notebook.widgets.indexOf(baseCell) - 1;\n            while (cellIdx >= 0) {\n                let cell = notebook.widgets[cellIdx];\n                let headingInfo = NotebookActions.getHeadingInfo(cell);\n                if (headingInfo.isHeading &&\n                    headingInfo.headingLevel <= baseHeadingLevel) {\n                    return returnIndex ? cellIdx : cell;\n                }\n                cellIdx--;\n            }\n            return returnIndex ? -1 : null; // no heading found\n        }\n        Headings.findLowerEqualLevelParentHeadingAbove = findLowerEqualLevelParentHeadingAbove;\n        /** Find next heading with equal or lower level.\n         *\n         * @param baseCell - cell relative to which so search\n         * @param notebook - target notebook widget\n         * @param returnIndex [default=false] - if set to true, the cell index is returned rather than the cell object.\n         *\n         * @returns the (index | Cell object) of the found heading or (-1 | null) if no heading found.\n         */\n        function findLowerEqualLevelHeadingBelow(baseCell, notebook, returnIndex = false) {\n            let baseHeadingLevel = Private.Headings.determineHeadingLevel(baseCell, notebook);\n            if (baseHeadingLevel == -1) {\n                baseHeadingLevel = 1; // if no heading level can be determined, assume we're on level 1\n            }\n            let cellIdx = notebook.widgets.indexOf(baseCell) + 1;\n            while (cellIdx < notebook.widgets.length) {\n                let cell = notebook.widgets[cellIdx];\n                let headingInfo = NotebookActions.getHeadingInfo(cell);\n                if (headingInfo.isHeading &&\n                    headingInfo.headingLevel <= baseHeadingLevel) {\n                    return returnIndex ? cellIdx : cell;\n                }\n                cellIdx++;\n            }\n            return returnIndex ? -1 : null;\n        }\n        Headings.findLowerEqualLevelHeadingBelow = findLowerEqualLevelHeadingBelow;\n        /** Find next heading.\n         *\n         * @param baseCell - cell relative to which so search\n         * @param notebook - target notebook widget\n         * @param returnIndex [default=false] - if set to true, the cell index is returned rather than the cell object.\n         *\n         * @returns the (index | Cell object) of the found heading or (-1 | null) if no heading found.\n         */\n        function findHeadingBelow(baseCell, notebook, returnIndex = false) {\n            let cellIdx = notebook.widgets.indexOf(baseCell) + 1;\n            while (cellIdx < notebook.widgets.length) {\n                let cell = notebook.widgets[cellIdx];\n                let headingInfo = NotebookActions.getHeadingInfo(cell);\n                if (headingInfo.isHeading) {\n                    return returnIndex ? cellIdx : cell;\n                }\n                cellIdx++;\n            }\n            return returnIndex ? -1 : null;\n        }\n        Headings.findHeadingBelow = findHeadingBelow;\n        /** Determine the heading level of a cell.\n         *\n         * @param baseCell - The cell of which the heading level shall be determined\n         * @param notebook - The target notebook widget\n         *\n         * @returns the heading level or -1 if there is no parent heading\n         *\n         * #### Notes\n         * If the baseCell is a heading itself, the heading level of baseCell is returned.\n         * If the baseCell is not a heading itself, the level of the parent heading is returned.\n         * If there is no parent heading, -1 is returned.\n         */\n        function determineHeadingLevel(baseCell, notebook) {\n            let headingInfoBaseCell = NotebookActions.getHeadingInfo(baseCell);\n            // fill baseHeadingLevel or return null if there is no heading at or above baseCell\n            if (headingInfoBaseCell.isHeading) {\n                return headingInfoBaseCell.headingLevel;\n            }\n            else {\n                let parentHeading = findParentHeading(baseCell, notebook, true);\n                if (parentHeading == null) {\n                    return -1;\n                }\n                return NotebookActions.getHeadingInfo(parentHeading).headingLevel;\n            }\n        }\n        Headings.determineHeadingLevel = determineHeadingLevel;\n        /** Insert a new heading cell at given position.\n         *\n         * @param cellIndex - where to insert\n         * @param headingLevel - level of the new heading\n         * @param notebook - target notebook\n         *\n         * #### Notes\n         * Enters edit mode after insert.\n         */\n        async function insertHeadingAboveCellIndex(cellIndex, headingLevel, notebook) {\n            var _a;\n            headingLevel = Math.min(Math.max(headingLevel, 1), 6);\n            const state = Private.getState(notebook);\n            const model = notebook.model;\n            const sharedModel = model.sharedModel;\n            sharedModel.insertCell(cellIndex, {\n                cell_type: 'markdown',\n                source: '#'.repeat(headingLevel) + ' '\n            });\n            notebook.activeCellIndex = cellIndex;\n            if (((_a = notebook.activeCell) === null || _a === void 0 ? void 0 : _a.inViewport) === false) {\n                await signalToPromise(notebook.activeCell.inViewportChanged, 200).catch(() => {\n                    // no-op\n                });\n            }\n            notebook.deselectAll();\n            Private.handleState(notebook, state, true);\n            notebook.mode = 'edit';\n            notebook.widgets[cellIndex].setHidden(false);\n        }\n        Headings.insertHeadingAboveCellIndex = insertHeadingAboveCellIndex;\n    })(Headings = Private.Headings || (Private.Headings = {}));\n})(Private || (Private = {}));\n//# sourceMappingURL=actions.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { CodeCellModel, MarkdownCellModel, RawCellModel } from '@jupyterlab/cells';\nimport { Signal } from '@lumino/signaling';\n/**\n * A cell list object that supports undo/redo.\n */\nexport class CellList {\n    /**\n     * Construct the cell list.\n     */\n    constructor(model) {\n        this.model = model;\n        this._cellMap = new WeakMap();\n        this._changed = new Signal(this);\n        this._isDisposed = false;\n        this._insertCells(0, this.model.cells);\n        this.model.changed.connect(this._onSharedModelChanged, this);\n    }\n    /**\n     * A signal emitted when the cell list has changed.\n     */\n    get changed() {\n        return this._changed;\n    }\n    /**\n     * Test whether the cell list has been disposed.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Get the length of the cell list.\n     *\n     * @returns The number of cells in the cell list.\n     */\n    get length() {\n        return this.model.cells.length;\n    }\n    /**\n     * Create an iterator over the cells in the cell list.\n     *\n     * @returns A new iterator starting at the front of the cell list.\n     */\n    *[Symbol.iterator]() {\n        for (const cell of this.model.cells) {\n            yield this._cellMap.get(cell);\n        }\n    }\n    /**\n     * Dispose of the resources held by the cell list.\n     */\n    dispose() {\n        var _a;\n        if (this._isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        // Clean up the cell map and cell order objects.\n        for (const cell of this.model.cells) {\n            (_a = this._cellMap.get(cell)) === null || _a === void 0 ? void 0 : _a.dispose();\n        }\n        Signal.clearData(this);\n    }\n    /**\n     * Get the cell at the specified index.\n     *\n     * @param index - The positive integer index of interest.\n     *\n     * @returns The cell at the specified index.\n     */\n    get(index) {\n        return this._cellMap.get(this.model.cells[index]);\n    }\n    _insertCells(index, cells) {\n        cells.forEach(sharedModel => {\n            let cellModel;\n            switch (sharedModel.cell_type) {\n                case 'code': {\n                    cellModel = new CodeCellModel({\n                        sharedModel: sharedModel\n                    });\n                    break;\n                }\n                case 'markdown': {\n                    cellModel = new MarkdownCellModel({\n                        sharedModel: sharedModel\n                    });\n                    break;\n                }\n                default: {\n                    cellModel = new RawCellModel({\n                        sharedModel: sharedModel\n                    });\n                }\n            }\n            this._cellMap.set(sharedModel, cellModel);\n            sharedModel.disposed.connect(() => {\n                cellModel.dispose();\n                this._cellMap.delete(sharedModel);\n            });\n        });\n        return this.length;\n    }\n    _onSharedModelChanged(self, change) {\n        var _a;\n        let currpos = 0;\n        // We differ emitting the list changes to ensure cell model for all current shared cell have been created.\n        const events = new Array();\n        (_a = change.cellsChange) === null || _a === void 0 ? void 0 : _a.forEach(delta => {\n            if (delta.insert != null) {\n                this._insertCells(currpos, delta.insert);\n                events.push({\n                    type: 'add',\n                    newIndex: currpos,\n                    newValues: delta.insert.map(c => this._cellMap.get(c)),\n                    oldIndex: -2,\n                    oldValues: []\n                });\n                currpos += delta.insert.length;\n            }\n            else if (delta.delete != null) {\n                events.push({\n                    type: 'remove',\n                    newIndex: -1,\n                    newValues: [],\n                    oldIndex: currpos,\n                    // Cells have been disposed, so we don't know which one are gone.\n                    oldValues: new Array(delta.delete).fill(undefined)\n                });\n            }\n            else if (delta.retain != null) {\n                currpos += delta.retain;\n            }\n        });\n        events.forEach(msg => this._changed.emit(msg));\n    }\n}\n//# sourceMappingURL=celllist.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Toolbar as AppToolbar, Dialog, SessionContextDialogs, showDialog } from '@jupyterlab/apputils';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { addIcon, addToolbarButtonClass, copyIcon, cutIcon, fastForwardIcon, HTMLSelect, pasteIcon, ReactWidget, runIcon, saveIcon, Toolbar, ToolbarButton, ToolbarButtonComponent, UseSignal } from '@jupyterlab/ui-components';\nimport * as React from 'react';\nimport { NotebookActions } from './actions';\n/**\n * The class name added to toolbar cell type dropdown wrapper.\n */\nconst TOOLBAR_CELLTYPE_CLASS = 'jp-Notebook-toolbarCellType';\n/**\n * The class name added to toolbar cell type dropdown.\n */\nconst TOOLBAR_CELLTYPE_DROPDOWN_CLASS = 'jp-Notebook-toolbarCellTypeDropdown';\n/**\n * A namespace for the default toolbar items.\n */\nexport var ToolbarItems;\n(function (ToolbarItems) {\n    /**\n     * Create save button toolbar item.\n     *\n     * @deprecated since v3.2\n     * This is dead code now.\n     */\n    function createSaveButton(panel, translator) {\n        const trans = (translator || nullTranslator).load('jupyterlab');\n        function onClick() {\n            if (panel.context.model.readOnly) {\n                return showDialog({\n                    title: trans.__('Cannot Save'),\n                    body: trans.__('Document is read-only'),\n                    buttons: [Dialog.okButton()]\n                });\n            }\n            void panel.context.save().then(() => {\n                if (!panel.isDisposed) {\n                    return panel.context.createCheckpoint();\n                }\n            });\n        }\n        return addToolbarButtonClass(ReactWidget.create(React.createElement(UseSignal, { signal: panel.context.fileChanged }, () => (React.createElement(ToolbarButtonComponent, { icon: saveIcon, onClick: onClick, tooltip: trans.__('Save the notebook contents and create checkpoint'), enabled: !!(panel &&\n                panel.context &&\n                panel.context.contentsModel &&\n                panel.context.contentsModel.writable) })))));\n    }\n    ToolbarItems.createSaveButton = createSaveButton;\n    /**\n     * Create an insert toolbar item.\n     *\n     * @deprecated since v3.2\n     * This is dead code now.\n     */\n    function createInsertButton(panel, translator) {\n        const trans = (translator || nullTranslator).load('jupyterlab');\n        return new ToolbarButton({\n            icon: addIcon,\n            onClick: () => {\n                NotebookActions.insertBelow(panel.content);\n            },\n            tooltip: trans.__('Insert a cell below')\n        });\n    }\n    ToolbarItems.createInsertButton = createInsertButton;\n    /**\n     * Create a cut toolbar item.\n     *\n     * @deprecated since v3.2\n     * This is dead code now.\n     */\n    function createCutButton(panel, translator) {\n        const trans = (translator || nullTranslator).load('jupyterlab');\n        return new ToolbarButton({\n            icon: cutIcon,\n            onClick: () => {\n                NotebookActions.cut(panel.content);\n            },\n            tooltip: trans.__('Cut the selected cells')\n        });\n    }\n    ToolbarItems.createCutButton = createCutButton;\n    /**\n     * Create a copy toolbar item.\n     *\n     * @deprecated since v3.2\n     * This is dead code now.\n     */\n    function createCopyButton(panel, translator) {\n        const trans = (translator || nullTranslator).load('jupyterlab');\n        return new ToolbarButton({\n            icon: copyIcon,\n            onClick: () => {\n                NotebookActions.copy(panel.content);\n            },\n            tooltip: trans.__('Copy the selected cells')\n        });\n    }\n    ToolbarItems.createCopyButton = createCopyButton;\n    /**\n     * Create a paste toolbar item.\n     *\n     * @deprecated since v3.2\n     * This is dead code now.\n     */\n    function createPasteButton(panel, translator) {\n        const trans = (translator || nullTranslator).load('jupyterlab');\n        return new ToolbarButton({\n            icon: pasteIcon,\n            onClick: () => {\n                NotebookActions.paste(panel.content);\n            },\n            tooltip: trans.__('Paste cells from the clipboard')\n        });\n    }\n    ToolbarItems.createPasteButton = createPasteButton;\n    /**\n     * Create a run toolbar item.\n     *\n     * @deprecated since v3.2\n     * This is dead code now.\n     */\n    function createRunButton(panel, sessionDialogs, translator) {\n        const trans = (translator !== null && translator !== void 0 ? translator : nullTranslator).load('jupyterlab');\n        return new ToolbarButton({\n            icon: runIcon,\n            onClick: () => {\n                void NotebookActions.runAndAdvance(panel.content, panel.sessionContext, sessionDialogs, translator);\n            },\n            tooltip: trans.__('Run the selected cells and advance')\n        });\n    }\n    ToolbarItems.createRunButton = createRunButton;\n    /**\n     * Create a restart run all toolbar item\n     *\n     * @deprecated since v3.2\n     * This is dead code now.\n     */\n    function createRestartRunAllButton(panel, dialogs, translator) {\n        const trans = (translator !== null && translator !== void 0 ? translator : nullTranslator).load('jupyterlab');\n        return new ToolbarButton({\n            icon: fastForwardIcon,\n            onClick: () => {\n                const dialogs_ = dialogs !== null && dialogs !== void 0 ? dialogs : new SessionContextDialogs({ translator });\n                void dialogs_.restart(panel.sessionContext).then(restarted => {\n                    if (restarted) {\n                        void NotebookActions.runAll(panel.content, panel.sessionContext, dialogs_, translator);\n                    }\n                    return restarted;\n                });\n            },\n            tooltip: trans.__('Restart the kernel, then re-run the whole notebook')\n        });\n    }\n    ToolbarItems.createRestartRunAllButton = createRestartRunAllButton;\n    /**\n     * Create a cell type switcher item.\n     *\n     * #### Notes\n     * It will display the type of the current active cell.\n     * If more than one cell is selected but are of different types,\n     * it will display `'-'`.\n     * When the user changes the cell type, it will change the\n     * cell types of the selected cells.\n     * It can handle a change to the context.\n     */\n    function createCellTypeItem(panel, translator) {\n        return new CellTypeSwitcher(panel.content, translator);\n    }\n    ToolbarItems.createCellTypeItem = createCellTypeItem;\n    /**\n     * Get the default toolbar items for panel\n     *\n     * @deprecated since v4\n     */\n    function getDefaultItems(panel, sessionDialogs, translator) {\n        return [\n            { name: 'save', widget: createSaveButton(panel, translator) },\n            { name: 'insert', widget: createInsertButton(panel, translator) },\n            { name: 'cut', widget: createCutButton(panel, translator) },\n            { name: 'copy', widget: createCopyButton(panel, translator) },\n            { name: 'paste', widget: createPasteButton(panel, translator) },\n            {\n                name: 'run',\n                widget: createRunButton(panel, sessionDialogs, translator)\n            },\n            {\n                name: 'interrupt',\n                widget: AppToolbar.createInterruptButton(panel.sessionContext, translator)\n            },\n            {\n                name: 'restart',\n                widget: AppToolbar.createRestartButton(panel.sessionContext, sessionDialogs, translator)\n            },\n            {\n                name: 'restart-and-run',\n                widget: createRestartRunAllButton(panel, sessionDialogs, translator)\n            },\n            { name: 'cellType', widget: createCellTypeItem(panel, translator) },\n            { name: 'spacer', widget: Toolbar.createSpacerItem() },\n            {\n                name: 'kernelName',\n                widget: AppToolbar.createKernelNameItem(panel.sessionContext, sessionDialogs, translator)\n            }\n        ];\n    }\n    ToolbarItems.getDefaultItems = getDefaultItems;\n})(ToolbarItems || (ToolbarItems = {}));\n/**\n * A toolbar widget that switches cell types.\n */\nexport class CellTypeSwitcher extends ReactWidget {\n    /**\n     * Construct a new cell type switcher.\n     */\n    constructor(widget, translator) {\n        super();\n        /**\n         * Handle `change` events for the HTMLSelect component.\n         */\n        this.handleChange = (event) => {\n            if (event.target.value !== '-') {\n                NotebookActions.changeCellType(this._notebook, event.target.value);\n                this._notebook.activate();\n            }\n        };\n        /**\n         * Handle `keydown` events for the HTMLSelect component.\n         */\n        this.handleKeyDown = (event) => {\n            if (event.keyCode === 13) {\n                this._notebook.activate();\n            }\n        };\n        this._trans = (translator || nullTranslator).load('jupyterlab');\n        this.addClass(TOOLBAR_CELLTYPE_CLASS);\n        this._notebook = widget;\n        if (widget.model) {\n            this.update();\n        }\n        widget.activeCellChanged.connect(this.update, this);\n        // Follow a change in the selection.\n        widget.selectionChanged.connect(this.update, this);\n    }\n    render() {\n        let value = '-';\n        if (this._notebook.activeCell) {\n            value = this._notebook.activeCell.model.type;\n        }\n        for (const widget of this._notebook.widgets) {\n            if (this._notebook.isSelectedOrActive(widget)) {\n                if (widget.model.type !== value) {\n                    value = '-';\n                    break;\n                }\n            }\n        }\n        return (React.createElement(HTMLSelect, { className: TOOLBAR_CELLTYPE_DROPDOWN_CLASS, onChange: this.handleChange, onKeyDown: this.handleKeyDown, value: value, \"aria-label\": this._trans.__('Cell type'), title: this._trans.__('Select the cell type') },\n            React.createElement(\"option\", { value: \"-\" }, \"-\"),\n            React.createElement(\"option\", { value: \"code\" }, this._trans.__('Code')),\n            React.createElement(\"option\", { value: \"markdown\" }, this._trans.__('Markdown')),\n            React.createElement(\"option\", { value: \"raw\" }, this._trans.__('Raw'))));\n    }\n}\n//# sourceMappingURL=default-toolbar.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { translateKernelStatuses } from '@jupyterlab/apputils';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport React from 'react';\nimport { ProgressCircle } from '@jupyterlab/statusbar';\nimport { circleIcon, offlineBoltIcon, VDomModel, VDomRenderer } from '@jupyterlab/ui-components';\nimport { KernelMessage } from '@jupyterlab/services';\n/**\n * A react functional component for rendering execution indicator.\n */\nexport function ExecutionIndicatorComponent(props) {\n    const translator = props.translator || nullTranslator;\n    const kernelStatuses = translateKernelStatuses(translator);\n    const trans = translator.load('jupyterlab');\n    const state = props.state;\n    const showOnToolBar = props.displayOption.showOnToolBar;\n    const showProgress = props.displayOption.showProgress;\n    const tooltipClass = showOnToolBar ? 'down' : 'up';\n    const emptyDiv = React.createElement(\"div\", null);\n    if (!state) {\n        return emptyDiv;\n    }\n    const kernelStatus = state.kernelStatus;\n    const circleIconProps = {\n        alignSelf: 'normal',\n        height: '24px'\n    };\n    const time = state.totalTime;\n    const scheduledCellNumber = state.scheduledCellNumber || 0;\n    const remainingCellNumber = state.scheduledCell.size || 0;\n    const executedCellNumber = scheduledCellNumber - remainingCellNumber;\n    let percentage = (100 * executedCellNumber) / scheduledCellNumber;\n    let displayClass = showProgress ? '' : 'hidden';\n    if (!showProgress && percentage < 100) {\n        percentage = 0;\n    }\n    const progressBar = (percentage) => (React.createElement(ProgressCircle, { progress: percentage, width: 16, height: 24, label: trans.__('Kernel status') }));\n    const titleFactory = (translatedStatus) => trans.__('Kernel status: %1', translatedStatus);\n    const reactElement = (status, circle, popup) => (React.createElement(\"div\", { className: 'jp-Notebook-ExecutionIndicator', title: showProgress ? '' : titleFactory(kernelStatuses[status]), \"data-status\": status },\n        circle,\n        React.createElement(\"div\", { className: `jp-Notebook-ExecutionIndicator-tooltip ${tooltipClass} ${displayClass}` },\n            React.createElement(\"span\", null,\n                \" \",\n                titleFactory(kernelStatuses[status]),\n                \" \"),\n            popup)));\n    if (state.kernelStatus === 'connecting' ||\n        state.kernelStatus === 'disconnected' ||\n        state.kernelStatus === 'unknown') {\n        return reactElement(kernelStatus, React.createElement(offlineBoltIcon.react, { ...circleIconProps }), []);\n    }\n    if (state.kernelStatus === 'starting' ||\n        state.kernelStatus === 'terminating' ||\n        state.kernelStatus === 'restarting' ||\n        state.kernelStatus === 'initializing') {\n        return reactElement(kernelStatus, React.createElement(circleIcon.react, { ...circleIconProps }), []);\n    }\n    if (state.executionStatus === 'busy') {\n        return reactElement('busy', progressBar(percentage), [\n            React.createElement(\"span\", { key: 0 }, trans.__(`Executed ${executedCellNumber}/${scheduledCellNumber} cells`)),\n            React.createElement(\"span\", { key: 1 }, trans._n('Elapsed time: %1 second', 'Elapsed time: %1 seconds', time))\n        ]);\n    }\n    else {\n        // No cell is scheduled, fall back to the status of kernel\n        const progress = state.kernelStatus === 'busy' ? 0 : 100;\n        const popup = state.kernelStatus === 'busy' || time === 0\n            ? []\n            : [\n                React.createElement(\"span\", { key: 0 }, trans._n('Executed %1 cell', 'Executed %1 cells', scheduledCellNumber)),\n                React.createElement(\"span\", { key: 1 }, trans._n('Elapsed time: %1 second', 'Elapsed time: %1 seconds', time))\n            ];\n        return reactElement(state.kernelStatus, progressBar(progress), popup);\n    }\n}\n/**\n * A VDomRenderer widget for displaying the execution status.\n */\nexport class ExecutionIndicator extends VDomRenderer {\n    /**\n     * Construct the kernel status widget.\n     */\n    constructor(translator, showProgress = true) {\n        super(new ExecutionIndicator.Model());\n        this.translator = translator || nullTranslator;\n        this.addClass('jp-mod-highlighted');\n    }\n    /**\n     * Render the execution status item.\n     */\n    render() {\n        if (this.model === null || !this.model.renderFlag) {\n            return React.createElement(\"div\", null);\n        }\n        else {\n            const nb = this.model.currentNotebook;\n            if (!nb) {\n                return (React.createElement(ExecutionIndicatorComponent, { displayOption: this.model.displayOption, state: undefined, translator: this.translator }));\n            }\n            return (React.createElement(ExecutionIndicatorComponent, { displayOption: this.model.displayOption, state: this.model.executionState(nb), translator: this.translator }));\n        }\n    }\n}\n/**\n * A namespace for ExecutionIndicator statics.\n */\n(function (ExecutionIndicator) {\n    /**\n     * A VDomModel for the execution status indicator.\n     */\n    class Model extends VDomModel {\n        constructor() {\n            super();\n            /**\n             * A weak map to hold execution status of multiple notebooks.\n             */\n            this._notebookExecutionProgress = new WeakMap();\n            this._displayOption = { showOnToolBar: true, showProgress: true };\n            this._renderFlag = true;\n        }\n        /**\n         * Attach a notebook with session context to model in order to keep\n         * track of multiple notebooks. If a session context is already\n         * attached, only set current activated notebook to input.\n         *\n         * @param data - The  notebook and session context to be attached to model\n         */\n        attachNotebook(data) {\n            var _a, _b, _c, _d;\n            if (data && data.content && data.context) {\n                const nb = data.content;\n                const context = data.context;\n                this._currentNotebook = nb;\n                if (!this._notebookExecutionProgress.has(nb)) {\n                    this._notebookExecutionProgress.set(nb, {\n                        executionStatus: 'idle',\n                        kernelStatus: 'idle',\n                        totalTime: 0,\n                        interval: 0,\n                        timeout: 0,\n                        scheduledCell: new Set(),\n                        scheduledCellNumber: 0,\n                        needReset: true\n                    });\n                    const state = this._notebookExecutionProgress.get(nb);\n                    const contextStatusChanged = (ctx) => {\n                        if (state) {\n                            state.kernelStatus = ctx.kernelDisplayStatus;\n                        }\n                        this.stateChanged.emit(void 0);\n                    };\n                    context.statusChanged.connect(contextStatusChanged, this);\n                    const contextConnectionStatusChanged = (ctx) => {\n                        if (state) {\n                            state.kernelStatus = ctx.kernelDisplayStatus;\n                        }\n                        this.stateChanged.emit(void 0);\n                    };\n                    context.connectionStatusChanged.connect(contextConnectionStatusChanged, this);\n                    context.disposed.connect(ctx => {\n                        ctx.connectionStatusChanged.disconnect(contextConnectionStatusChanged, this);\n                        ctx.statusChanged.disconnect(contextStatusChanged, this);\n                    });\n                    const handleKernelMsg = (sender, msg) => {\n                        const message = msg.msg;\n                        const msgId = message.header.msg_id;\n                        if (message.header.msg_type === 'execute_request') {\n                            // A cell code is scheduled for executing\n                            this._cellScheduledCallback(nb, msgId);\n                        }\n                        else if (KernelMessage.isStatusMsg(message) &&\n                            message.content.execution_state === 'idle') {\n                            // Idle status message case.\n                            const parentId = message.parent_header\n                                .msg_id;\n                            this._cellExecutedCallback(nb, parentId);\n                        }\n                        else if (KernelMessage.isStatusMsg(message) &&\n                            message.content.execution_state === 'restarting') {\n                            this._restartHandler(nb);\n                        }\n                        else if (message.header.msg_type === 'execute_input') {\n                            // A cell code starts executing.\n                            this._startTimer(nb);\n                        }\n                    };\n                    (_b = (_a = context.session) === null || _a === void 0 ? void 0 : _a.kernel) === null || _b === void 0 ? void 0 : _b.anyMessage.connect(handleKernelMsg);\n                    (_d = (_c = context.session) === null || _c === void 0 ? void 0 : _c.kernel) === null || _d === void 0 ? void 0 : _d.disposed.connect(kernel => kernel.anyMessage.disconnect(handleKernelMsg));\n                    const kernelChangedSlot = (_, kernelData) => {\n                        if (state) {\n                            this._resetTime(state);\n                            this.stateChanged.emit(void 0);\n                            if (kernelData.newValue) {\n                                kernelData.newValue.anyMessage.connect(handleKernelMsg);\n                            }\n                        }\n                    };\n                    context.kernelChanged.connect(kernelChangedSlot);\n                    context.disposed.connect(ctx => ctx.kernelChanged.disconnect(kernelChangedSlot));\n                }\n            }\n        }\n        /**\n         * The current activated notebook in model.\n         */\n        get currentNotebook() {\n            return this._currentNotebook;\n        }\n        /**\n         * The display options for progress bar and elapsed time.\n         */\n        get displayOption() {\n            return this._displayOption;\n        }\n        /**\n         * Set the display options for progress bar and elapsed time.\n         *\n         * @param options - Options to be used\n         */\n        set displayOption(options) {\n            this._displayOption = options;\n        }\n        /**\n         * Get the execution state associated with a notebook.\n         *\n         * @param nb - The notebook used to identify execution\n         * state.\n         *\n         * @returns - The associated execution state.\n         */\n        executionState(nb) {\n            return this._notebookExecutionProgress.get(nb);\n        }\n        /**\n         * Schedule switch to idle status and clearing of the timer.\n         *\n         * ### Note\n         *\n         * To keep track of cells executed under 1 second,\n         * the execution state is marked as `needReset` 1 second after executing\n         * these cells. This `Timeout` will be cleared if there is any cell\n         * scheduled after that.\n         */\n        _scheduleSwitchToIdle(state) {\n            window.setTimeout(() => {\n                state.executionStatus = 'idle';\n                clearInterval(state.interval);\n                this.stateChanged.emit(void 0);\n            }, 150);\n            state.timeout = window.setTimeout(() => {\n                state.needReset = true;\n            }, 1000);\n        }\n        /**\n         * The function is called on kernel's idle status message.\n         * It is used to keep track of number of executed\n         * cells or Comm custom messages and the status of kernel.\n         *\n         * @param nb - The notebook which contains the executed code cell.\n         * @param msg_id - The id of message.\n         */\n        _cellExecutedCallback(nb, msg_id) {\n            const state = this._notebookExecutionProgress.get(nb);\n            if (state && state.scheduledCell.has(msg_id)) {\n                state.scheduledCell.delete(msg_id);\n                if (state.scheduledCell.size === 0) {\n                    this._scheduleSwitchToIdle(state);\n                }\n            }\n        }\n        /**\n         * The function is called on kernel's restarting status message.\n         * It is used to clear the state tracking the number of executed\n         * cells.\n         *\n         * @param nb - The notebook which contains the executed code cell.\n         */\n        _restartHandler(nb) {\n            const state = this._notebookExecutionProgress.get(nb);\n            if (state) {\n                state.scheduledCell.clear();\n                this._scheduleSwitchToIdle(state);\n            }\n        }\n        /**\n         * This function is called on kernel's `execute_input` message to start\n         * the elapsed time counter.\n         *\n         * @param  nb - The notebook which contains the scheduled execution request.\n         */\n        _startTimer(nb) {\n            const state = this._notebookExecutionProgress.get(nb);\n            if (!state) {\n                return;\n            }\n            if (state.scheduledCell.size > 0) {\n                if (state.executionStatus !== 'busy') {\n                    state.executionStatus = 'busy';\n                    clearTimeout(state.timeout);\n                    this.stateChanged.emit(void 0);\n                    state.interval = window.setInterval(() => {\n                        this._tick(state);\n                    }, 1000);\n                }\n            }\n            else {\n                this._resetTime(state);\n            }\n        }\n        /**\n         * The function is called on kernel's `execute_request` message or Comm message, it is\n         * used to keep track number of scheduled cell or Comm execution message\n         * and the status of kernel.\n         *\n         * @param  nb - The notebook which contains the scheduled code.\n         * cell\n         * @param  msg_id - The id of message.\n         */\n        _cellScheduledCallback(nb, msg_id) {\n            const state = this._notebookExecutionProgress.get(nb);\n            if (state && !state.scheduledCell.has(msg_id)) {\n                if (state.needReset) {\n                    this._resetTime(state);\n                }\n                state.scheduledCell.add(msg_id);\n                state.scheduledCellNumber += 1;\n            }\n        }\n        /**\n         * Increment the executed time of input execution state\n         * and emit `stateChanged` signal to re-render the indicator.\n         *\n         * @param  data - the state to be updated.\n         */\n        _tick(data) {\n            data.totalTime += 1;\n            this.stateChanged.emit(void 0);\n        }\n        /**\n         * Reset the input execution state.\n         *\n         * @param  data - the state to be rested.\n         */\n        _resetTime(data) {\n            data.totalTime = 0;\n            data.scheduledCellNumber = 0;\n            data.executionStatus = 'idle';\n            data.scheduledCell = new Set();\n            clearTimeout(data.timeout);\n            clearInterval(data.interval);\n            data.needReset = false;\n        }\n        get renderFlag() {\n            return this._renderFlag;\n        }\n        updateRenderOption(options) {\n            if (this.displayOption.showOnToolBar) {\n                if (!options.showOnToolBar) {\n                    this._renderFlag = false;\n                }\n                else {\n                    this._renderFlag = true;\n                }\n            }\n            this.displayOption.showProgress = options.showProgress;\n            this.stateChanged.emit(void 0);\n        }\n    }\n    ExecutionIndicator.Model = Model;\n    function createExecutionIndicatorItem(panel, translator, loadSettings) {\n        const toolbarItem = new ExecutionIndicator(translator);\n        toolbarItem.model.displayOption = {\n            showOnToolBar: true,\n            showProgress: true\n        };\n        toolbarItem.model.attachNotebook({\n            content: panel.content,\n            context: panel.sessionContext\n        });\n        if (loadSettings) {\n            loadSettings\n                .then(settings => {\n                const updateSettings = (newSettings) => {\n                    toolbarItem.model.updateRenderOption(getSettingValue(newSettings));\n                };\n                settings.changed.connect(updateSettings);\n                updateSettings(settings);\n                toolbarItem.disposed.connect(() => {\n                    settings.changed.disconnect(updateSettings);\n                });\n            })\n                .catch((reason) => {\n                console.error(reason.message);\n            });\n        }\n        return toolbarItem;\n    }\n    ExecutionIndicator.createExecutionIndicatorItem = createExecutionIndicatorItem;\n    function getSettingValue(settings) {\n        let showOnToolBar = true;\n        let showProgress = true;\n        const configValues = settings.get('kernelStatus').composite;\n        if (configValues) {\n            showOnToolBar = !configValues.showOnStatusBar;\n            showProgress = configValues.showProgress;\n        }\n        return { showOnToolBar, showProgress };\n    }\n    ExecutionIndicator.getSettingValue = getSettingValue;\n})(ExecutionIndicator || (ExecutionIndicator = {}));\n//# sourceMappingURL=executionindicator.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Dialog, showDialog } from '@jupyterlab/apputils';\nimport * as nbformat from '@jupyterlab/nbformat';\nimport { YNotebook } from '@jupyter/ydoc';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { JSONExt } from '@lumino/coreutils';\nimport { Signal } from '@lumino/signaling';\nimport { CellList } from './celllist';\n/**\n * An implementation of a notebook Model.\n */\nexport class NotebookModel {\n    /**\n     * Construct a new notebook model.\n     */\n    constructor(options = {}) {\n        var _a, _b;\n        /**\n         * Whether the model should disposed the shared model on disposal or not.\n         */\n        this.standaloneModel = false;\n        this._dirty = false;\n        this._readOnly = false;\n        this._contentChanged = new Signal(this);\n        this._stateChanged = new Signal(this);\n        this._isDisposed = false;\n        this._metadataChanged = new Signal(this);\n        this.standaloneModel = typeof options.sharedModel === 'undefined';\n        if (options.sharedModel) {\n            this.sharedModel = options.sharedModel;\n        }\n        else {\n            this.sharedModel = YNotebook.create({\n                disableDocumentWideUndoRedo: (_a = options.disableDocumentWideUndoRedo) !== null && _a !== void 0 ? _a : true,\n                data: {\n                    nbformat: nbformat.MAJOR_VERSION,\n                    nbformat_minor: nbformat.MINOR_VERSION,\n                    metadata: {\n                        kernelspec: { name: '', display_name: '' },\n                        language_info: { name: (_b = options.languagePreference) !== null && _b !== void 0 ? _b : '' }\n                    }\n                }\n            });\n        }\n        this._cells = new CellList(this.sharedModel);\n        this._trans = (options.translator || nullTranslator).load('jupyterlab');\n        this._deletedCells = [];\n        this._collaborationEnabled = !!(options === null || options === void 0 ? void 0 : options.collaborationEnabled);\n        this._cells.changed.connect(this._onCellsChanged, this);\n        this.sharedModel.changed.connect(this._onStateChanged, this);\n        this.sharedModel.metadataChanged.connect(this._onMetadataChanged, this);\n    }\n    /**\n     * A signal emitted when the document content changes.\n     */\n    get contentChanged() {\n        return this._contentChanged;\n    }\n    /**\n     * Signal emitted when notebook metadata changes.\n     */\n    get metadataChanged() {\n        return this._metadataChanged;\n    }\n    /**\n     * A signal emitted when the document state changes.\n     */\n    get stateChanged() {\n        return this._stateChanged;\n    }\n    /**\n     * Get the observable list of notebook cells.\n     */\n    get cells() {\n        return this._cells;\n    }\n    /**\n     * The dirty state of the document.\n     */\n    get dirty() {\n        return this._dirty;\n    }\n    set dirty(newValue) {\n        const oldValue = this._dirty;\n        if (newValue === oldValue) {\n            return;\n        }\n        this._dirty = newValue;\n        this.triggerStateChange({\n            name: 'dirty',\n            oldValue,\n            newValue\n        });\n    }\n    /**\n     * The read only state of the document.\n     */\n    get readOnly() {\n        return this._readOnly;\n    }\n    set readOnly(newValue) {\n        if (newValue === this._readOnly) {\n            return;\n        }\n        const oldValue = this._readOnly;\n        this._readOnly = newValue;\n        this.triggerStateChange({ name: 'readOnly', oldValue, newValue });\n    }\n    /**\n     * The metadata associated with the notebook.\n     *\n     * ### Notes\n     * This is a copy of the metadata. Changing a part of it\n     * won't affect the model.\n     * As this returns a copy of all metadata, it is advised to\n     * use `getMetadata` to speed up the process of getting a single key.\n     */\n    get metadata() {\n        return this.sharedModel.metadata;\n    }\n    /**\n     * The major version number of the nbformat.\n     */\n    get nbformat() {\n        return this.sharedModel.nbformat;\n    }\n    /**\n     * The minor version number of the nbformat.\n     */\n    get nbformatMinor() {\n        return this.sharedModel.nbformat_minor;\n    }\n    /**\n     * The default kernel name of the document.\n     */\n    get defaultKernelName() {\n        var _a;\n        const spec = this.getMetadata('kernelspec');\n        return (_a = spec === null || spec === void 0 ? void 0 : spec.name) !== null && _a !== void 0 ? _a : '';\n    }\n    /**\n     * A list of deleted cells for the notebook..\n     */\n    get deletedCells() {\n        return this._deletedCells;\n    }\n    /**\n     * The default kernel language of the document.\n     */\n    get defaultKernelLanguage() {\n        var _a;\n        const info = this.getMetadata('language_info');\n        return (_a = info === null || info === void 0 ? void 0 : info.name) !== null && _a !== void 0 ? _a : '';\n    }\n    /**\n     * Whether the model is collaborative or not.\n     */\n    get collaborative() {\n        return this._collaborationEnabled;\n    }\n    /**\n     * Dispose of the resources held by the model.\n     */\n    dispose() {\n        // Do nothing if already disposed.\n        if (this.isDisposed) {\n            return;\n        }\n        this._isDisposed = true;\n        const cells = this.cells;\n        this._cells = null;\n        cells.dispose();\n        if (this.standaloneModel) {\n            this.sharedModel.dispose();\n        }\n        Signal.clearData(this);\n    }\n    /**\n     * Delete a metadata\n     *\n     * @param key Metadata key\n     */\n    deleteMetadata(key) {\n        return this.sharedModel.deleteMetadata(key);\n    }\n    /**\n     * Get a metadata\n     *\n     * ### Notes\n     * This returns a copy of the key value.\n     *\n     * @param key Metadata key\n     */\n    getMetadata(key) {\n        return this.sharedModel.getMetadata(key);\n    }\n    /**\n     * Set a metadata\n     *\n     * @param key Metadata key\n     * @param value Metadata value\n     */\n    setMetadata(key, value) {\n        if (typeof value === 'undefined') {\n            this.sharedModel.deleteMetadata(key);\n        }\n        else {\n            this.sharedModel.setMetadata(key, value);\n        }\n    }\n    /**\n     * Serialize the model to a string.\n     */\n    toString() {\n        return JSON.stringify(this.toJSON());\n    }\n    /**\n     * Deserialize the model from a string.\n     *\n     * #### Notes\n     * Should emit a [contentChanged] signal.\n     */\n    fromString(value) {\n        this.fromJSON(JSON.parse(value));\n    }\n    /**\n     * Serialize the model to JSON.\n     */\n    toJSON() {\n        this._ensureMetadata();\n        return this.sharedModel.toJSON();\n    }\n    /**\n     * Deserialize the model from JSON.\n     *\n     * #### Notes\n     * Should emit a [contentChanged] signal.\n     */\n    fromJSON(value) {\n        var _a, _b;\n        const copy = JSONExt.deepCopy(value);\n        const origNbformat = value.metadata.orig_nbformat;\n        // Alert the user if the format changes.\n        copy.nbformat = Math.max(value.nbformat, nbformat.MAJOR_VERSION);\n        if (copy.nbformat !== value.nbformat ||\n            copy.nbformat_minor < nbformat.MINOR_VERSION) {\n            copy.nbformat_minor = nbformat.MINOR_VERSION;\n        }\n        if (origNbformat !== undefined && copy.nbformat !== origNbformat) {\n            const newer = copy.nbformat > origNbformat;\n            let msg;\n            if (newer) {\n                msg = this._trans.__(`This notebook has been converted from an older notebook format (v%1)\nto the current notebook format (v%2).\nThe next time you save this notebook, the current notebook format (v%2) will be used.\n'Older versions of Jupyter may not be able to read the new format.' To preserve the original format version,\nclose the notebook without saving it.`, origNbformat, copy.nbformat);\n            }\n            else {\n                msg = this._trans.__(`This notebook has been converted from an newer notebook format (v%1)\nto the current notebook format (v%2).\nThe next time you save this notebook, the current notebook format (v%2) will be used.\nSome features of the original notebook may not be available.' To preserve the original format version,\nclose the notebook without saving it.`, origNbformat, copy.nbformat);\n            }\n            void showDialog({\n                title: this._trans.__('Notebook converted'),\n                body: msg,\n                buttons: [Dialog.okButton({ label: this._trans.__('Ok') })]\n            });\n        }\n        // Ensure there is at least one cell\n        if (((_b = (_a = copy.cells) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) === 0) {\n            copy['cells'] = [\n                { cell_type: 'code', source: '', metadata: { trusted: true } }\n            ];\n        }\n        this.sharedModel.fromJSON(copy);\n        this._ensureMetadata();\n        this.dirty = true;\n    }\n    /**\n     * Handle a change in the cells list.\n     */\n    _onCellsChanged(list, change) {\n        switch (change.type) {\n            case 'add':\n                change.newValues.forEach(cell => {\n                    cell.contentChanged.connect(this.triggerContentChange, this);\n                });\n                break;\n            case 'remove':\n                break;\n            case 'set':\n                change.newValues.forEach(cell => {\n                    cell.contentChanged.connect(this.triggerContentChange, this);\n                });\n                break;\n            default:\n                break;\n        }\n        this.triggerContentChange();\n    }\n    _onMetadataChanged(sender, changes) {\n        this._metadataChanged.emit(changes);\n        this.triggerContentChange();\n    }\n    _onStateChanged(sender, changes) {\n        if (changes.stateChange) {\n            changes.stateChange.forEach(value => {\n                if (value.name === 'dirty') {\n                    // Setting `dirty` will trigger the state change.\n                    // We always set `dirty` because the shared model state\n                    // and the local attribute are synchronized one way shared model -> _dirty\n                    this.dirty = value.newValue;\n                }\n                else if (value.oldValue !== value.newValue) {\n                    this.triggerStateChange({\n                        newValue: undefined,\n                        oldValue: undefined,\n                        ...value\n                    });\n                }\n            });\n        }\n    }\n    /**\n     * Make sure we have the required metadata fields.\n     */\n    _ensureMetadata(languageName = '') {\n        if (!this.getMetadata('language_info')) {\n            this.sharedModel.setMetadata('language_info', { name: languageName });\n        }\n        if (!this.getMetadata('kernelspec')) {\n            this.sharedModel.setMetadata('kernelspec', {\n                name: '',\n                display_name: ''\n            });\n        }\n    }\n    /**\n     * Trigger a state change signal.\n     */\n    triggerStateChange(args) {\n        this._stateChanged.emit(args);\n    }\n    /**\n     * Trigger a content changed signal.\n     */\n    triggerContentChange() {\n        this._contentChanged.emit(void 0);\n        this.dirty = true;\n    }\n    /**\n     * Whether the model is disposed.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n}\n//# sourceMappingURL=model.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { NotebookModel } from './model';\n/**\n * A model factory for notebooks.\n */\nexport class NotebookModelFactory {\n    /**\n     * Construct a new notebook model factory.\n     */\n    constructor(options = {}) {\n        var _a, _b;\n        this._disposed = false;\n        this._disableDocumentWideUndoRedo =\n            (_a = options.disableDocumentWideUndoRedo) !== null && _a !== void 0 ? _a : true;\n        this._collaborative = (_b = options.collaborative) !== null && _b !== void 0 ? _b : true;\n    }\n    /**\n     * Define the disableDocumentWideUndoRedo property.\n     *\n     * @experimental\n     * @alpha\n     */\n    get disableDocumentWideUndoRedo() {\n        return this._disableDocumentWideUndoRedo;\n    }\n    set disableDocumentWideUndoRedo(disableDocumentWideUndoRedo) {\n        this._disableDocumentWideUndoRedo = disableDocumentWideUndoRedo;\n    }\n    /**\n     * The name of the model.\n     */\n    get name() {\n        return 'notebook';\n    }\n    /**\n     * The content type of the file.\n     */\n    get contentType() {\n        return 'notebook';\n    }\n    /**\n     * The format of the file.\n     */\n    get fileFormat() {\n        return 'json';\n    }\n    /**\n     * Whether the model is collaborative or not.\n     */\n    get collaborative() {\n        return this._collaborative;\n    }\n    /**\n     * Get whether the model factory has been disposed.\n     */\n    get isDisposed() {\n        return this._disposed;\n    }\n    /**\n     * Dispose of the model factory.\n     */\n    dispose() {\n        this._disposed = true;\n    }\n    /**\n     * Create a new model for a given path.\n     *\n     * @param languagePreference - An optional kernel language preference.\n     *\n     * @returns A new document model.\n     */\n    createNew(options = {}) {\n        return new NotebookModel({\n            languagePreference: options.languagePreference,\n            sharedModel: options.sharedModel,\n            collaborationEnabled: options.collaborationEnabled && this.collaborative,\n            disableDocumentWideUndoRedo: this._disableDocumentWideUndoRedo\n        });\n    }\n    /**\n     * Get the preferred kernel language given a path.\n     */\n    preferredLanguage(path) {\n        return '';\n    }\n}\n//# sourceMappingURL=modelfactory.js.map","/*\n * Copyright (c) Jupyter Development Team.\n * Distributed under the terms of the Modified BSD License.\n */\nimport { TextItem } from '@jupyterlab/statusbar';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { VDomModel, VDomRenderer } from '@jupyterlab/ui-components';\nimport * as React from 'react';\n/**\n * A pure function for rendering a Command/Edit mode component.\n *\n * @param props: the props for rendering the component.\n *\n * @returns a tsx component for command/edit mode.\n */\nfunction CommandEditComponent(props) {\n    const trans = (props.translator || nullTranslator).load('jupyterlab');\n    return (React.createElement(TextItem, { source: trans.__('Mode: %1', props.modeNames[props.notebookMode]) }));\n}\n/**\n * StatusBar item to display which notebook mode user is in.\n */\nexport class CommandEditStatus extends VDomRenderer {\n    /**\n     * Construct a new CommandEdit status item.\n     */\n    constructor(translator) {\n        super(new CommandEditStatus.Model());\n        this.translator = translator || nullTranslator;\n        this._trans = this.translator.load('jupyterlab');\n        this._modeNames = {\n            command: this._trans.__('Command'),\n            edit: this._trans.__('Edit')\n        };\n    }\n    /**\n     * Render the CommandEdit status item.\n     */\n    render() {\n        if (!this.model) {\n            return null;\n        }\n        this.node.title = this._trans.__('Notebook is in %1 mode', this._modeNames[this.model.notebookMode]);\n        return (React.createElement(CommandEditComponent, { notebookMode: this.model.notebookMode, translator: this.translator, modeNames: this._modeNames }));\n    }\n}\n/**\n * A namespace for CommandEdit statics.\n */\n(function (CommandEditStatus) {\n    /**\n     * A VDomModel for the CommandEdit renderer.\n     */\n    class Model extends VDomModel {\n        constructor() {\n            super(...arguments);\n            /**\n             * On a change to the notebook, update the mode.\n             */\n            this._onChanged = (_notebook) => {\n                const oldMode = this._notebookMode;\n                if (this._notebook) {\n                    this._notebookMode = _notebook.mode;\n                }\n                else {\n                    this._notebookMode = 'command';\n                }\n                this._triggerChange(oldMode, this._notebookMode);\n            };\n            this._notebookMode = 'command';\n            this._notebook = null;\n        }\n        /**\n         * The current mode of the current notebook.\n         */\n        get notebookMode() {\n            return this._notebookMode;\n        }\n        /**\n         * Set the current notebook for the model.\n         */\n        set notebook(notebook) {\n            const oldNotebook = this._notebook;\n            if (oldNotebook !== null) {\n                oldNotebook.stateChanged.disconnect(this._onChanged, this);\n                oldNotebook.activeCellChanged.disconnect(this._onChanged, this);\n                oldNotebook.modelContentChanged.disconnect(this._onChanged, this);\n            }\n            const oldMode = this._notebookMode;\n            this._notebook = notebook;\n            if (this._notebook === null) {\n                this._notebookMode = 'command';\n            }\n            else {\n                this._notebookMode = this._notebook.mode;\n                this._notebook.stateChanged.connect(this._onChanged, this);\n                this._notebook.activeCellChanged.connect(this._onChanged, this);\n                this._notebook.modelContentChanged.connect(this._onChanged, this);\n            }\n            this._triggerChange(oldMode, this._notebookMode);\n        }\n        /**\n         * Trigger a state change for the renderer.\n         */\n        _triggerChange(oldState, newState) {\n            if (oldState !== newState) {\n                this.stateChanged.emit(void 0);\n            }\n        }\n    }\n    CommandEditStatus.Model = Model;\n})(CommandEditStatus || (CommandEditStatus = {}));\n//# sourceMappingURL=modestatus.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { untilReady, VirtualDocument, WidgetLSPAdapter } from '@jupyterlab/lsp';\nimport { PromiseDelegate } from '@lumino/coreutils';\nimport { Signal } from '@lumino/signaling';\nexport class NotebookAdapter extends WidgetLSPAdapter {\n    constructor(editorWidget, options) {\n        super(editorWidget, options);\n        this.editorWidget = editorWidget;\n        this.options = options;\n        this._type = 'code';\n        this._readyDelegate = new PromiseDelegate();\n        this._editorToCell = new Map();\n        this.editor = editorWidget.content;\n        this._cellToEditor = new WeakMap();\n        Promise.all([\n            this.widget.context.sessionContext.ready,\n            this.connectionManager.ready\n        ])\n            .then(async () => {\n            await this.initOnceReady();\n            this._readyDelegate.resolve();\n        })\n            .catch(console.error);\n    }\n    /**\n     * Get current path of the document.\n     */\n    get documentPath() {\n        return this.widget.context.path;\n    }\n    /**\n     * Get the mime type of the document.\n     */\n    get mimeType() {\n        var _a;\n        let mimeType;\n        let languageMetadata = this.language_info();\n        if (!languageMetadata || !languageMetadata.mimetype) {\n            // fallback to the code cell mime type if no kernel in use\n            mimeType = this.widget.content.codeMimetype;\n        }\n        else {\n            mimeType = languageMetadata.mimetype;\n        }\n        return Array.isArray(mimeType) ? (_a = mimeType[0]) !== null && _a !== void 0 ? _a : 'text/plain' : mimeType;\n    }\n    /**\n     * Get the file extension of the document.\n     */\n    get languageFileExtension() {\n        let languageMetadata = this.language_info();\n        if (!languageMetadata || !languageMetadata.file_extension) {\n            return;\n        }\n        return languageMetadata.file_extension.replace('.', '');\n    }\n    /**\n     * Get the inner HTMLElement of the document widget.\n     */\n    get wrapperElement() {\n        return this.widget.node;\n    }\n    /**\n     *  Get the list of CM editor with its type in the document,\n     */\n    get editors() {\n        if (this.isDisposed) {\n            return [];\n        }\n        let notebook = this.widget.content;\n        this._editorToCell.clear();\n        if (notebook.isDisposed) {\n            return [];\n        }\n        return notebook.widgets.map(cell => {\n            return {\n                ceEditor: this._getCellEditor(cell),\n                type: cell.model.type,\n                value: cell.model.sharedModel.getSource()\n            };\n        });\n    }\n    /**\n     * Get the activated CM editor.\n     */\n    get activeEditor() {\n        return this.editor.activeCell\n            ? this._getCellEditor(this.editor.activeCell)\n            : undefined;\n    }\n    /**\n     * Promise that resolves once the adapter is initialized\n     */\n    get ready() {\n        return this._readyDelegate.promise;\n    }\n    /**\n     * Get the index of editor from the cursor position in the virtual\n     * document.\n     *\n     * @param position - the position of cursor in the virtual document.\n     */\n    getEditorIndexAt(position) {\n        let cell = this._getCellAt(position);\n        let notebook = this.widget.content;\n        return notebook.widgets.findIndex(otherCell => {\n            return cell === otherCell;\n        });\n    }\n    /**\n     * Get the index of input editor\n     *\n     * @param ceEditor - instance of the code editor\n     */\n    getEditorIndex(ceEditor) {\n        let cell = this._editorToCell.get(ceEditor);\n        return this.editor.widgets.findIndex(otherCell => {\n            return cell === otherCell;\n        });\n    }\n    /**\n     * Get the wrapper of input editor.\n     *\n     * @param ceEditor - instance of the code editor\n     */\n    getEditorWrapper(ceEditor) {\n        let cell = this._editorToCell.get(ceEditor);\n        return cell.node;\n    }\n    /**\n     * Callback on kernel changed event, it will disconnect the\n     * document with the language server and then reconnect.\n     *\n     * @param _session - Session context of changed kernel\n     * @param change - Changed data\n     */\n    async onKernelChanged(_session, change) {\n        if (!change.newValue) {\n            return;\n        }\n        try {\n            // note: we need to wait until ready before updating language info\n            const oldLanguageInfo = this._languageInfo;\n            await untilReady(this.isReady, -1);\n            await this._updateLanguageInfo();\n            const newLanguageInfo = this._languageInfo;\n            if ((oldLanguageInfo === null || oldLanguageInfo === void 0 ? void 0 : oldLanguageInfo.name) != newLanguageInfo.name ||\n                (oldLanguageInfo === null || oldLanguageInfo === void 0 ? void 0 : oldLanguageInfo.mimetype) != (newLanguageInfo === null || newLanguageInfo === void 0 ? void 0 : newLanguageInfo.mimetype) ||\n                (oldLanguageInfo === null || oldLanguageInfo === void 0 ? void 0 : oldLanguageInfo.file_extension) != (newLanguageInfo === null || newLanguageInfo === void 0 ? void 0 : newLanguageInfo.file_extension)) {\n                console.log(`Changed to ${this._languageInfo.name} kernel, reconnecting`);\n                this.reloadConnection();\n            }\n            else {\n                console.log('Keeping old LSP connection as the new kernel uses the same langauge');\n            }\n        }\n        catch (err) {\n            console.warn(err);\n            // try to reconnect anyway\n            this.reloadConnection();\n        }\n    }\n    /**\n     * Dispose the widget.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this.widget.context.sessionContext.kernelChanged.disconnect(this.onKernelChanged, this);\n        this.widget.content.activeCellChanged.disconnect(this._activeCellChanged, this);\n        super.dispose();\n        // editors are needed for the parent dispose() to unbind signals, so they are the last to go\n        this._editorToCell.clear();\n        Signal.clearData(this);\n    }\n    /**\n     * Method to check if the notebook context is ready.\n     */\n    isReady() {\n        var _a;\n        return (!this.widget.isDisposed &&\n            this.widget.context.isReady &&\n            this.widget.content.isVisible &&\n            this.widget.content.widgets.length > 0 &&\n            ((_a = this.widget.context.sessionContext.session) === null || _a === void 0 ? void 0 : _a.kernel) != null);\n    }\n    /**\n     * Update the virtual document on cell changing event.\n     *\n     * @param cells - Observable list of changed cells\n     * @param change - Changed data\n     */\n    async handleCellChange(cells, change) {\n        let cellsAdded = [];\n        let cellsRemoved = [];\n        const type = this._type;\n        if (change.type === 'set') {\n            // handling of conversions is important, because the editors get re-used and their handlers inherited,\n            // so we need to clear our handlers from editors of e.g. markdown cells which previously were code cells.\n            let convertedToMarkdownOrRaw = [];\n            let convertedToCode = [];\n            if (change.newValues.length === change.oldValues.length) {\n                // during conversion the cells should not get deleted nor added\n                for (let i = 0; i < change.newValues.length; i++) {\n                    if (change.oldValues[i].type === type &&\n                        change.newValues[i].type !== type) {\n                        convertedToMarkdownOrRaw.push(change.newValues[i]);\n                    }\n                    else if (change.oldValues[i].type !== type &&\n                        change.newValues[i].type === type) {\n                        convertedToCode.push(change.newValues[i]);\n                    }\n                }\n                cellsAdded = convertedToCode;\n                cellsRemoved = convertedToMarkdownOrRaw;\n            }\n        }\n        else if (change.type == 'add') {\n            cellsAdded = change.newValues.filter(cellModel => cellModel.type === type);\n        }\n        // note: editorRemoved is not emitted for removal of cells by change of type 'remove' (but only during cell type conversion)\n        // because there is no easy way to get the widget associated with the removed cell(s) - because it is no\n        // longer in the notebook widget list! It would need to be tracked on our side, but it is not necessary\n        // as (except for a tiny memory leak) it should not impact the functionality in any way\n        if (cellsRemoved.length ||\n            cellsAdded.length ||\n            change.type === 'set' ||\n            change.type === 'move' ||\n            change.type === 'remove') {\n            // in contrast to the file editor document which can be only changed by the modification of the editor content,\n            // the notebook document cna also get modified by a change in the number or arrangement of editors themselves;\n            // for this reason each change has to trigger documents update (so that LSP mirror is in sync).\n            await this.updateDocuments();\n        }\n        for (let cellModel of cellsAdded) {\n            let cellWidget = this.widget.content.widgets.find(cell => cell.model.id === cellModel.id);\n            if (!cellWidget) {\n                console.warn(`Widget for added cell with ID: ${cellModel.id} not found!`);\n                continue;\n            }\n            // Add editor to the mapping if needed\n            this._getCellEditor(cellWidget);\n        }\n    }\n    /**\n     * Generate the virtual document associated with the document.\n     */\n    createVirtualDocument() {\n        return new VirtualDocument({\n            language: this.language,\n            foreignCodeExtractors: this.options.foreignCodeExtractorsManager,\n            path: this.documentPath,\n            fileExtension: this.languageFileExtension,\n            // notebooks are continuous, each cell is dependent on the previous one\n            standalone: false,\n            // notebooks are not supported by LSP servers\n            hasLspSupportedFile: false\n        });\n    }\n    /**\n     * Get the metadata of notebook.\n     */\n    language_info() {\n        return this._languageInfo;\n    }\n    /**\n     * Initialization function called once the editor and the LSP connection\n     * manager is ready. This function will create the virtual document and\n     * connect various signals.\n     */\n    async initOnceReady() {\n        await untilReady(this.isReady.bind(this), -1);\n        await this._updateLanguageInfo();\n        this.initVirtual();\n        // connect the document, but do not open it as the adapter will handle this\n        // after registering all features\n        this.connectDocument(this.virtualDocument, false).catch(console.warn);\n        this.widget.context.sessionContext.kernelChanged.connect(this.onKernelChanged, this);\n        this.widget.content.activeCellChanged.connect(this._activeCellChanged, this);\n        this._connectModelSignals(this.widget);\n        this.editor.modelChanged.connect(notebook => {\n            // note: this should not usually happen;\n            // there is no default action that would trigger this,\n            // its just a failsafe in case if another extension decides\n            // to swap the notebook model\n            console.warn('Model changed, connecting cell change handler; this is not something we were expecting');\n            this._connectModelSignals(notebook);\n        });\n    }\n    /**\n     * Connect the cell changed event to its handler\n     *\n     * @param  notebook - The notebook that emitted event.\n     */\n    _connectModelSignals(notebook) {\n        if (notebook.model === null) {\n            console.warn(`Model is missing for notebook ${notebook}, cannot connect cell changed signal!`);\n        }\n        else {\n            notebook.model.cells.changed.connect(this.handleCellChange, this);\n        }\n    }\n    /**\n     * Update the stored language info with the one from the notebook.\n     */\n    async _updateLanguageInfo() {\n        var _a, _b, _c, _d;\n        const language_info = (_d = (await ((_c = (_b = (_a = this.widget.context.sessionContext) === null || _a === void 0 ? void 0 : _a.session) === null || _b === void 0 ? void 0 : _b.kernel) === null || _c === void 0 ? void 0 : _c.info))) === null || _d === void 0 ? void 0 : _d.language_info;\n        if (language_info) {\n            this._languageInfo = language_info;\n        }\n        else {\n            throw new Error('Language info update failed (no session, kernel, or info available)');\n        }\n    }\n    /**\n     * Handle the cell changed event\n     * @param  notebook - The notebook that emitted event\n     * @param cell - Changed cell.\n     */\n    _activeCellChanged(notebook, cell) {\n        if (!cell || cell.model.type !== this._type) {\n            return;\n        }\n        this._activeEditorChanged.emit({\n            editor: this._getCellEditor(cell)\n        });\n    }\n    /**\n     * Get the cell at the cursor position of the virtual document.\n     * @param  pos - Position in the virtual document.\n     */\n    _getCellAt(pos) {\n        let editor = this.virtualDocument.getEditorAtVirtualLine(pos);\n        return this._editorToCell.get(editor);\n    }\n    /**\n     * Get the cell editor and add new ones to the mappings.\n     *\n     * @param cell Cell widget\n     * @returns Cell editor accessor\n     */\n    _getCellEditor(cell) {\n        if (!this._cellToEditor.has(cell)) {\n            const editor = Object.freeze({\n                getEditor: () => cell.editor,\n                ready: async () => {\n                    await cell.ready;\n                    return cell.editor;\n                },\n                reveal: async () => {\n                    await this.editor.scrollToCell(cell);\n                    return cell.editor;\n                }\n            });\n            this._cellToEditor.set(cell, editor);\n            this._editorToCell.set(editor, cell);\n            cell.disposed.connect(() => {\n                this._cellToEditor.delete(cell);\n                this._editorToCell.delete(editor);\n                this._editorRemoved.emit({\n                    editor\n                });\n            });\n            this._editorAdded.emit({\n                editor\n            });\n        }\n        return this._cellToEditor.get(cell);\n    }\n}\n//# sourceMappingURL=notebooklspadapter.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { JSONEditor } from '@jupyterlab/codeeditor';\nimport { ObservableJSON } from '@jupyterlab/observables';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { Collapser } from '@jupyterlab/ui-components';\nimport { ArrayExt } from '@lumino/algorithm';\nimport { ConflatableMessage, MessageLoop } from '@lumino/messaging';\nimport { PanelLayout, Widget } from '@lumino/widgets';\nclass RankedPanel extends Widget {\n    constructor() {\n        super();\n        this._items = [];\n        this.layout = new PanelLayout();\n        this.addClass('jp-RankedPanel');\n    }\n    addWidget(widget, rank) {\n        const rankItem = { widget, rank };\n        const index = ArrayExt.upperBound(this._items, rankItem, Private.itemCmp);\n        ArrayExt.insert(this._items, index, rankItem);\n        const layout = this.layout;\n        layout.insertWidget(index, widget);\n    }\n    /**\n     * Handle the removal of a child\n     *\n     */\n    onChildRemoved(msg) {\n        const index = ArrayExt.findFirstIndex(this._items, item => item.widget === msg.child);\n        if (index !== -1) {\n            ArrayExt.removeAt(this._items, index);\n        }\n    }\n}\n/**\n * A widget that provides metadata tools.\n */\nexport class NotebookTools extends Widget {\n    /**\n     * Construct a new NotebookTools object.\n     */\n    constructor(options) {\n        super();\n        this.addClass('jp-NotebookTools');\n        this.translator = options.translator || nullTranslator;\n        this._tools = [];\n        this.layout = new PanelLayout();\n        this._tracker = options.tracker;\n        this._tracker.currentChanged.connect(this._onActiveNotebookPanelChanged, this);\n        this._tracker.activeCellChanged.connect(this._onActiveCellChanged, this);\n        this._tracker.selectionChanged.connect(this._onSelectionChanged, this);\n        this._onActiveNotebookPanelChanged();\n        this._onActiveCellChanged();\n        this._onSelectionChanged();\n    }\n    /**\n     * The active cell widget.\n     */\n    get activeCell() {\n        return this._tracker.activeCell;\n    }\n    /**\n     * The currently selected cells.\n     */\n    get selectedCells() {\n        const panel = this._tracker.currentWidget;\n        if (!panel) {\n            return [];\n        }\n        const notebook = panel.content;\n        return notebook.widgets.filter(cell => notebook.isSelectedOrActive(cell));\n    }\n    /**\n     * The current notebook.\n     */\n    get activeNotebookPanel() {\n        return this._tracker.currentWidget;\n    }\n    /**\n     * Add a cell tool item.\n     */\n    addItem(options) {\n        var _a;\n        const tool = options.tool;\n        const rank = (_a = options.rank) !== null && _a !== void 0 ? _a : 100;\n        let section;\n        const extendedTool = this._tools.find(extendedTool => extendedTool.section === options.section);\n        if (extendedTool)\n            section = extendedTool.panel;\n        else {\n            throw new Error(`The section ${options.section} does not exist`);\n        }\n        tool.addClass('jp-NotebookTools-tool');\n        section.addWidget(tool, rank);\n        // TODO: perhaps the necessary notebookTools functionality should be\n        // consolidated into a single object, rather than a broad reference to this.\n        tool.notebookTools = this;\n        // Trigger the tool to update its active notebook and cell.\n        MessageLoop.sendMessage(tool, NotebookTools.ActiveNotebookPanelMessage);\n        MessageLoop.sendMessage(tool, NotebookTools.ActiveCellMessage);\n    }\n    /*\n     * Add a section to the notebook tool with its widget\n     */\n    addSection(options) {\n        var _a;\n        const sectionName = options.sectionName;\n        const label = options.label || options.sectionName;\n        const widget = options.tool;\n        let rank = (_a = options.rank) !== null && _a !== void 0 ? _a : null;\n        const newSection = new RankedPanel();\n        newSection.title.label = label;\n        if (widget)\n            newSection.addWidget(widget, 0);\n        this._tools.push({\n            section: sectionName,\n            panel: newSection,\n            rank: rank\n        });\n        if (rank != null)\n            this.layout.insertWidget(rank, new Collapser({ widget: newSection }));\n        else {\n            // If no rank is provided, try to add the new section before the AdvancedTools.\n            let advancedToolsRank = null;\n            const layout = this.layout;\n            for (let i = 0; i < layout.widgets.length; i++) {\n                let w = layout.widgets[i];\n                if (w instanceof Collapser) {\n                    if (w.widget.id === 'advancedToolsSection') {\n                        advancedToolsRank = i;\n                        break;\n                    }\n                }\n            }\n            if (advancedToolsRank !== null)\n                this.layout.insertWidget(advancedToolsRank, new Collapser({ widget: newSection }));\n            else\n                this.layout.addWidget(new Collapser({ widget: newSection }));\n        }\n    }\n    /**\n     * Handle a change to the notebook panel.\n     */\n    _onActiveNotebookPanelChanged() {\n        if (this._prevActiveNotebookModel &&\n            !this._prevActiveNotebookModel.isDisposed) {\n            this._prevActiveNotebookModel.metadataChanged.disconnect(this._onActiveNotebookPanelMetadataChanged, this);\n        }\n        const activeNBModel = this.activeNotebookPanel && this.activeNotebookPanel.content\n            ? this.activeNotebookPanel.content.model\n            : null;\n        this._prevActiveNotebookModel = activeNBModel;\n        if (activeNBModel) {\n            activeNBModel.metadataChanged.connect(this._onActiveNotebookPanelMetadataChanged, this);\n        }\n        for (const widget of this._toolChildren()) {\n            MessageLoop.sendMessage(widget, NotebookTools.ActiveNotebookPanelMessage);\n        }\n    }\n    /**\n     * Handle a change to the active cell.\n     */\n    _onActiveCellChanged() {\n        if (this._prevActiveCell && !this._prevActiveCell.isDisposed) {\n            this._prevActiveCell.metadataChanged.disconnect(this._onActiveCellMetadataChanged, this);\n        }\n        const activeCell = this.activeCell ? this.activeCell.model : null;\n        this._prevActiveCell = activeCell;\n        if (activeCell) {\n            activeCell.metadataChanged.connect(this._onActiveCellMetadataChanged, this);\n        }\n        for (const widget of this._toolChildren()) {\n            MessageLoop.sendMessage(widget, NotebookTools.ActiveCellMessage);\n        }\n    }\n    /**\n     * Handle a change in the selection.\n     */\n    _onSelectionChanged() {\n        for (const widget of this._toolChildren()) {\n            MessageLoop.sendMessage(widget, NotebookTools.SelectionMessage);\n        }\n    }\n    /**\n     * Handle a change in the active cell metadata.\n     */\n    _onActiveNotebookPanelMetadataChanged(sender, args) {\n        const message = new ObservableJSON.ChangeMessage('activenotebookpanel-metadata-changed', { oldValue: undefined, newValue: undefined, ...args });\n        for (const widget of this._toolChildren()) {\n            MessageLoop.sendMessage(widget, message);\n        }\n    }\n    /**\n     * Handle a change in the notebook model metadata.\n     */\n    _onActiveCellMetadataChanged(sender, args) {\n        const message = new ObservableJSON.ChangeMessage('activecell-metadata-changed', { newValue: undefined, oldValue: undefined, ...args });\n        for (const widget of this._toolChildren()) {\n            MessageLoop.sendMessage(widget, message);\n        }\n    }\n    *_toolChildren() {\n        for (let tool of this._tools) {\n            yield* tool.panel.children();\n        }\n    }\n}\n/**\n * The namespace for NotebookTools class statics.\n */\n(function (NotebookTools) {\n    /**\n     * A singleton conflatable `'activenotebookpanel-changed'` message.\n     */\n    NotebookTools.ActiveNotebookPanelMessage = new ConflatableMessage('activenotebookpanel-changed');\n    /**\n     * A singleton conflatable `'activecell-changed'` message.\n     */\n    NotebookTools.ActiveCellMessage = new ConflatableMessage('activecell-changed');\n    /**\n     * A singleton conflatable `'selection-changed'` message.\n     */\n    NotebookTools.SelectionMessage = new ConflatableMessage('selection-changed');\n    /**\n     * The base notebook tool, meant to be subclassed.\n     */\n    class Tool extends Widget {\n        dispose() {\n            super.dispose();\n            if (this.notebookTools) {\n                this.notebookTools = null;\n            }\n        }\n        /**\n         * Process a message sent to the widget.\n         *\n         * @param msg - The message sent to the widget.\n         */\n        processMessage(msg) {\n            super.processMessage(msg);\n            switch (msg.type) {\n                case 'activenotebookpanel-changed':\n                    this.onActiveNotebookPanelChanged(msg);\n                    break;\n                case 'activecell-changed':\n                    this.onActiveCellChanged(msg);\n                    break;\n                case 'selection-changed':\n                    this.onSelectionChanged(msg);\n                    break;\n                case 'activecell-metadata-changed':\n                    this.onActiveCellMetadataChanged(msg);\n                    break;\n                case 'activenotebookpanel-metadata-changed':\n                    this.onActiveNotebookPanelMetadataChanged(msg);\n                    break;\n                default:\n                    break;\n            }\n        }\n        /**\n         * Handle a change to the notebook panel.\n         *\n         * #### Notes\n         * The default implementation is a no-op.\n         */\n        onActiveNotebookPanelChanged(msg) {\n            /* no-op */\n        }\n        /**\n         * Handle a change to the active cell.\n         *\n         * #### Notes\n         * The default implementation is a no-op.\n         */\n        onActiveCellChanged(msg) {\n            /* no-op */\n        }\n        /**\n         * Handle a change to the selection.\n         *\n         * #### Notes\n         * The default implementation is a no-op.\n         */\n        onSelectionChanged(msg) {\n            /* no-op */\n        }\n        /**\n         * Handle a change to the metadata of the active cell.\n         *\n         * #### Notes\n         * The default implementation is a no-op.\n         */\n        onActiveCellMetadataChanged(msg) {\n            /* no-op */\n        }\n        /**\n         * Handle a change to the metadata of the active cell.\n         *\n         * #### Notes\n         * The default implementation is a no-op.\n         */\n        onActiveNotebookPanelMetadataChanged(msg) {\n            /* no-op */\n        }\n    }\n    NotebookTools.Tool = Tool;\n    /**\n     * A raw metadata editor.\n     */\n    class MetadataEditorTool extends Tool {\n        /**\n         * Construct a new raw metadata tool.\n         */\n        constructor(options) {\n            super();\n            const { editorFactory } = options;\n            this.addClass('jp-MetadataEditorTool');\n            const layout = (this.layout = new PanelLayout());\n            this._editorFactory = editorFactory;\n            this._editorLabel = options.label || 'Edit Metadata';\n            this.createEditor();\n            const titleNode = new Widget({ node: document.createElement('label') });\n            titleNode.node.textContent = options.label || 'Edit Metadata';\n            layout.addWidget(titleNode);\n            layout.addWidget(this.editor);\n        }\n        /**\n         * The editor used by the tool.\n         */\n        get editor() {\n            return this._editor;\n        }\n        /**\n         * Handle a change to the notebook.\n         */\n        onActiveNotebookPanelChanged(msg) {\n            this.editor.dispose();\n            if (this.notebookTools.activeNotebookPanel) {\n                this.createEditor();\n            }\n        }\n        createEditor() {\n            this._editor = new JSONEditor({\n                editorFactory: this._editorFactory\n            });\n            this.editor.title.label = this._editorLabel;\n            this.layout.addWidget(this.editor);\n        }\n    }\n    NotebookTools.MetadataEditorTool = MetadataEditorTool;\n})(NotebookTools || (NotebookTools = {}));\n/**\n * A namespace for private data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * A comparator function for widget rank items.\n     */\n    function itemCmp(first, second) {\n        return first.rank - second.rank;\n    }\n    Private.itemCmp = itemCmp;\n})(Private || (Private = {}));\n//# sourceMappingURL=notebooktools.js.map","/*\n * Copyright (c) Jupyter Development Team.\n * Distributed under the terms of the Modified BSD License.\n */\n/**\n * The class name added to a drop target.\n */\nexport const DROP_TARGET_CLASS = 'jp-mod-dropTarget';\n/**\n * The class name added to a drop source.\n */\nexport const DROP_SOURCE_CLASS = 'jp-mod-dropSource';\n//# sourceMappingURL=constants.js.map","/*\n * Copyright (c) Jupyter Development Team.\n * Distributed under the terms of the Modified BSD License.\n */\nimport { CodeCell } from '@jupyterlab/cells';\nimport { WindowedLayout, WindowedListModel } from '@jupyterlab/ui-components';\nimport { MessageLoop } from '@lumino/messaging';\nimport { Widget } from '@lumino/widgets';\nimport { DROP_SOURCE_CLASS, DROP_TARGET_CLASS } from './constants';\n/**\n * Notebook view model for the windowed list.\n */\nclass NotebookViewModel extends WindowedListModel {\n    /**\n     * Construct a notebook windowed list model.\n     */\n    constructor(cells, options) {\n        super(options);\n        this.cells = cells;\n        /**\n         * Cell size estimator\n         *\n         * @param index Cell index\n         * @returns Cell height in pixels\n         */\n        this.estimateWidgetSize = (index) => {\n            // TODO could be improved, takes only into account the editor height\n            const nLines = this.cells[index].model.sharedModel\n                .getSource()\n                .split('\\n').length;\n            return (NotebookViewModel.DEFAULT_EDITOR_LINE_HEIGHT * nLines +\n                NotebookViewModel.DEFAULT_CELL_MARGIN);\n        };\n        /**\n         * Render the cell at index.\n         *\n         * @param index Cell index\n         * @returns Cell widget\n         */\n        this.widgetRenderer = (index) => {\n            return this.cells[index];\n        };\n        // Set default cell size\n        this._estimatedWidgetSize = NotebookViewModel.DEFAULT_CELL_SIZE;\n    }\n}\n/**\n * Default cell height\n */\nNotebookViewModel.DEFAULT_CELL_SIZE = 39;\n/**\n * Default editor line height\n */\nNotebookViewModel.DEFAULT_EDITOR_LINE_HEIGHT = 17;\n/**\n * Default cell margin (top + bottom)\n */\nNotebookViewModel.DEFAULT_CELL_MARGIN = 22;\nexport { NotebookViewModel };\n/**\n * Windowed list layout for the notebook.\n */\nexport class NotebookWindowedLayout extends WindowedLayout {\n    constructor() {\n        super(...arguments);\n        this._header = null;\n        this._footer = null;\n        this._willBeRemoved = null;\n        this._topHiddenCodeCells = -1;\n    }\n    /**\n     * Notebook's header\n     */\n    get header() {\n        return this._header;\n    }\n    set header(header) {\n        var _a;\n        if (this._header && this._header.isAttached) {\n            Widget.detach(this._header);\n        }\n        this._header = header;\n        if (this._header && ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isAttached)) {\n            Widget.attach(this._header, this.parent.node);\n        }\n    }\n    /**\n     * Notebook widget's footer\n     */\n    get footer() {\n        return this._footer;\n    }\n    set footer(footer) {\n        var _a;\n        if (this._footer && this._footer.isAttached) {\n            Widget.detach(this._footer);\n        }\n        this._footer = footer;\n        if (this._footer && ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isAttached)) {\n            Widget.attach(this._footer, this.parent.node);\n        }\n    }\n    /**\n     * Dispose the layout\n     * */\n    dispose() {\n        var _a, _b;\n        if (this.isDisposed) {\n            return;\n        }\n        (_a = this._header) === null || _a === void 0 ? void 0 : _a.dispose();\n        (_b = this._footer) === null || _b === void 0 ? void 0 : _b.dispose();\n        super.dispose();\n    }\n    /**\n     * * A message handler invoked on a `'child-removed'` message.\n     * *\n     * @param widget - The widget to remove from the layout.\n     *\n     * #### Notes\n     * A widget is automatically removed from the layout when its `parent`\n     * is set to `null`. This method should only be invoked directly when\n     * removing a widget from a layout which has yet to be installed on a\n     * parent widget.\n     *\n     * This method does *not* modify the widget's `parent`.\n     */\n    removeWidget(widget) {\n        const index = this.widgets.indexOf(widget);\n        // We need to deal with code cell widget not in viewport (aka not in this.widgets) but still\n        // partly attached\n        if (index >= 0) {\n            this.removeWidgetAt(index);\n        } // If the layout is parented, detach the widget from the DOM.\n        else if (widget === this._willBeRemoved && this.parent) {\n            this.detachWidget(index, widget);\n        }\n    }\n    /**\n     * Attach a widget to the parent's DOM node.\n     *\n     * @param index - The current index of the widget in the layout.\n     *\n     * @param widget - The widget to attach to the parent.\n     *\n     * #### Notes\n     * This method is called automatically by the panel layout at the\n     * appropriate time. It should not be called directly by user code.\n     *\n     * The default implementation adds the widgets's node to the parent's\n     * node at the proper location, and sends the appropriate attach\n     * messages to the widget if the parent is attached to the DOM.\n     *\n     * Subclasses may reimplement this method to control how the widget's\n     * node is added to the parent's node.\n     */\n    attachWidget(index, widget) {\n        // Status may change in onBeforeAttach\n        const wasPlaceholder = widget.isPlaceholder();\n        // Initialized sub-widgets or attached them for CodeCell\n        if (this.parent.isAttached) {\n            MessageLoop.sendMessage(widget, Widget.Msg.BeforeAttach);\n        }\n        if (!wasPlaceholder &&\n            widget instanceof CodeCell &&\n            widget.node.parentElement) {\n            // We don't remove code cells to preserve outputs internal state\n            widget.node.style.display = '';\n            // Reset cache\n            this._topHiddenCodeCells = -1;\n        }\n        else {\n            // Look up the next sibling reference node.\n            const siblingIndex = this._findNearestChildBinarySearch(this.parent.viewportNode.childElementCount - 1, 0, parseInt(widget.dataset.windowedListIndex, 10) + 1);\n            let ref = this.parent.viewportNode.children[siblingIndex];\n            // Insert the widget's node before the sibling.\n            this.parent.viewportNode.insertBefore(widget.node, ref);\n            // Send an `'after-attach'` message if the parent is attached.\n            // Event listeners will be added here\n            // Some widgets are updating/resetting when attached, so\n            // we should not recall this each time a cell move into the\n            // viewport.\n            if (this.parent.isAttached) {\n                MessageLoop.sendMessage(widget, Widget.Msg.AfterAttach);\n            }\n        }\n        widget.inViewport = true;\n    }\n    /**\n     * Detach a widget from the parent's DOM node.\n     *\n     * @param index - The previous index of the widget in the layout.\n     *\n     * @param widget - The widget to detach from the parent.\n     *\n     * #### Notes\n     * This method is called automatically by the panel layout at the\n     * appropriate time. It should not be called directly by user code.\n     *\n     * The default implementation removes the widget's node from the\n     * parent's node, and sends the appropriate detach messages to the\n     * widget if the parent is attached to the DOM.\n     *\n     * Subclasses may reimplement this method to control how the widget's\n     * node is removed from the parent's node.\n     */\n    detachWidget(index, widget) {\n        widget.inViewport = false;\n        // TODO we could improve this further by discarding also the code cell without outputs\n        if (widget instanceof CodeCell &&\n            // We detach the code cell currently dragged otherwise it won't be attached at the correct position\n            !widget.node.classList.contains(DROP_SOURCE_CLASS) &&\n            widget !== this._willBeRemoved) {\n            // We don't remove code cells to preserve outputs internal state\n            // Transform does not work because the widget height is kept (at lease in FF)\n            widget.node.style.display = 'none';\n            // Reset cache\n            this._topHiddenCodeCells = -1;\n        }\n        else {\n            // Send a `'before-detach'` message if the parent is attached.\n            // This should not be called every time a cell leaves the viewport\n            // as it will remove listeners that won't be added back as afterAttach\n            // is shunted to avoid unwanted update/reset.\n            if (this.parent.isAttached) {\n                // Event listeners will be removed here\n                MessageLoop.sendMessage(widget, Widget.Msg.BeforeDetach);\n            }\n            // Remove the widget's node from the parent.\n            this.parent.viewportNode.removeChild(widget.node);\n            // Ensure to clean up drop target class if the widget move out of the viewport\n            widget.node.classList.remove(DROP_TARGET_CLASS);\n        }\n        if (this.parent.isAttached) {\n            // Detach sub widget of CodeCell except the OutputAreaWrapper\n            MessageLoop.sendMessage(widget, Widget.Msg.AfterDetach);\n        }\n    }\n    /**\n     * Move a widget in the parent's DOM node.\n     *\n     * @param fromIndex - The previous index of the widget in the layout.\n     *\n     * @param toIndex - The current index of the widget in the layout.\n     *\n     * @param widget - The widget to move in the parent.\n     *\n     * #### Notes\n     * This method is called automatically by the panel layout at the\n     * appropriate time. It should not be called directly by user code.\n     *\n     * The default implementation moves the widget's node to the proper\n     * location in the parent's node and sends the appropriate attach and\n     * detach messages to the widget if the parent is attached to the DOM.\n     *\n     * Subclasses may reimplement this method to control how the widget's\n     * node is moved in the parent's node.\n     */\n    moveWidget(fromIndex, toIndex, widget) {\n        // Optimize move without de-/attaching as motion appends with parent attached\n        // Case fromIndex === toIndex, already checked in PanelLayout.insertWidget\n        if (this._topHiddenCodeCells < 0) {\n            this._topHiddenCodeCells = 0;\n            for (let idx = 0; idx < this.parent.viewportNode.children.length; idx++) {\n                const n = this.parent.viewportNode.children[idx];\n                if (n.style.display == 'none') {\n                    this._topHiddenCodeCells++;\n                }\n                else {\n                    break;\n                }\n            }\n        }\n        const ref = this.parent.viewportNode.children[toIndex + this._topHiddenCodeCells];\n        if (fromIndex < toIndex) {\n            ref.insertAdjacentElement('afterend', widget.node);\n        }\n        else {\n            ref.insertAdjacentElement('beforebegin', widget.node);\n        }\n    }\n    onAfterAttach(msg) {\n        super.onAfterAttach(msg);\n        if (this._header && !this._header.isAttached) {\n            Widget.attach(this._header, this.parent.node, this.parent.node.firstElementChild);\n        }\n        if (this._footer && !this._footer.isAttached) {\n            Widget.attach(this._footer, this.parent.node);\n        }\n    }\n    onBeforeDetach(msg) {\n        var _a, _b;\n        if ((_a = this._header) === null || _a === void 0 ? void 0 : _a.isAttached) {\n            Widget.detach(this._header);\n        }\n        if ((_b = this._footer) === null || _b === void 0 ? void 0 : _b.isAttached) {\n            Widget.detach(this._footer);\n        }\n        super.onBeforeDetach(msg);\n    }\n    /**\n     * A message handler invoked on a `'child-removed'` message.\n     *\n     * @param msg Message\n     */\n    onChildRemoved(msg) {\n        this._willBeRemoved = msg.child;\n        super.onChildRemoved(msg);\n        this._willBeRemoved = null;\n    }\n    _findNearestChildBinarySearch(high, low, index) {\n        while (low <= high) {\n            const middle = low + Math.floor((high - low) / 2);\n            const currentIndex = parseInt(this.parent.viewportNode.children[middle].dataset\n                .windowedListIndex, 10);\n            if (currentIndex === index) {\n                return middle;\n            }\n            else if (currentIndex < index) {\n                low = middle + 1;\n            }\n            else if (currentIndex > index) {\n                high = middle - 1;\n            }\n        }\n        if (low > 0) {\n            return low;\n        }\n        else {\n            return 0;\n        }\n    }\n}\n//# sourceMappingURL=windowing.js.map","/*\n * Copyright (c) Jupyter Development Team.\n * Distributed under the terms of the Modified BSD License.\n */\nimport { Widget } from '@lumino/widgets';\nimport { NotebookActions } from './actions';\nconst NOTEBOOK_FOOTER_CLASS = 'jp-Notebook-footer';\n/**\n * A footer widget added after the last cell of the notebook.\n */\nexport class NotebookFooter extends Widget {\n    /**\n     * Construct a footer widget.\n     */\n    constructor(notebook) {\n        super({ node: document.createElement('button') });\n        this.notebook = notebook;\n        const trans = notebook.translator.load('jupyterlab');\n        this.addClass(NOTEBOOK_FOOTER_CLASS);\n        this.node.innerText = trans.__('Click to add a cell.');\n    }\n    /**\n     * Handle incoming events.\n     */\n    handleEvent(event) {\n        switch (event.type) {\n            case 'click':\n                this.onClick();\n                break;\n            case 'keydown':\n                if (event.key === 'ArrowUp') {\n                    this.onArrowUp();\n                    break;\n                }\n        }\n    }\n    /**\n     * On single click (mouse event), insert a cell below (at the end of the notebook as default behavior).\n     */\n    onClick() {\n        if (this.notebook.widgets.length > 0) {\n            this.notebook.activeCellIndex = this.notebook.widgets.length - 1;\n        }\n        NotebookActions.insertBelow(this.notebook);\n    }\n    /**\n     * On arrow up key pressed (keydown keyboard event), blur the footer and switch to command mode.\n     */\n    onArrowUp() {\n        this.node.blur();\n        this.notebook.mode = 'command';\n    }\n    /*\n     * Handle `after-detach` messages for the widget.\n     */\n    onAfterAttach(msg) {\n        super.onAfterAttach(msg);\n        this.node.addEventListener('click', this);\n        this.node.addEventListener('keydown', this);\n    }\n    /**\n     * Handle `before-detach` messages for the widget.\n     */\n    onBeforeDetach(msg) {\n        this.node.removeEventListener('click', this);\n        this.node.removeEventListener('keydown', this);\n        super.onBeforeDetach(msg);\n    }\n}\n//# sourceMappingURL=notebookfooter.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Cell, CodeCell, MarkdownCell, RawCell } from '@jupyterlab/cells';\nimport { TableOfContentsUtils } from '@jupyterlab/toc';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { WindowedList } from '@jupyterlab/ui-components';\nimport { ArrayExt, findIndex } from '@lumino/algorithm';\nimport { MimeData } from '@lumino/coreutils';\nimport { ElementExt } from '@lumino/domutils';\nimport { Drag } from '@lumino/dragdrop';\nimport { AttachedProperty } from '@lumino/properties';\nimport { Signal } from '@lumino/signaling';\nimport { h, VirtualDOM } from '@lumino/virtualdom';\nimport { PanelLayout, Widget } from '@lumino/widgets';\nimport { NotebookActions } from './actions';\nimport { DROP_SOURCE_CLASS, DROP_TARGET_CLASS } from './constants';\nimport { NotebookViewModel, NotebookWindowedLayout } from './windowing';\nimport { NotebookFooter } from './notebookfooter';\n/**\n * The data attribute added to a widget that has an active kernel.\n */\nconst KERNEL_USER = 'jpKernelUser';\n/**\n * The data attribute added to a widget that can run code.\n */\nconst CODE_RUNNER = 'jpCodeRunner';\n/**\n * The data attribute added to a widget that can undo.\n */\nconst UNDOER = 'jpUndoer';\n/**\n * The class name added to notebook widgets.\n */\nconst NB_CLASS = 'jp-Notebook';\n/**\n * The class name added to notebook widget cells.\n */\nconst NB_CELL_CLASS = 'jp-Notebook-cell';\n/**\n * The class name added to a notebook in edit mode.\n */\nconst EDIT_CLASS = 'jp-mod-editMode';\n/**\n * The class name added to a notebook in command mode.\n */\nconst COMMAND_CLASS = 'jp-mod-commandMode';\n/**\n * The class name added to the active cell.\n */\nconst ACTIVE_CLASS = 'jp-mod-active';\n/**\n * The class name added to selected cells.\n */\nconst SELECTED_CLASS = 'jp-mod-selected';\n/**\n * The class name added to an active cell when there are other selected cells.\n */\nconst OTHER_SELECTED_CLASS = 'jp-mod-multiSelected';\n/**\n * The class name added to unconfined images.\n */\nconst UNCONFINED_CLASS = 'jp-mod-unconfined';\n/**\n * The class name added to drag images.\n */\nconst DRAG_IMAGE_CLASS = 'jp-dragImage';\n/**\n * The class name added to singular drag images\n */\nconst SINGLE_DRAG_IMAGE_CLASS = 'jp-dragImage-singlePrompt';\n/**\n * The class name added to the drag image cell content.\n */\nconst CELL_DRAG_CONTENT_CLASS = 'jp-dragImage-content';\n/**\n * The class name added to the drag image cell content.\n */\nconst CELL_DRAG_PROMPT_CLASS = 'jp-dragImage-prompt';\n/**\n * The class name added to the drag image cell content.\n */\nconst CELL_DRAG_MULTIPLE_BACK = 'jp-dragImage-multipleBack';\n/**\n * The mimetype used for Jupyter cell data.\n */\nconst JUPYTER_CELL_MIME = 'application/vnd.jupyter.cells';\n/**\n * The threshold in pixels to start a drag event.\n */\nconst DRAG_THRESHOLD = 5;\n/**\n * Maximal remaining time for idle callback\n *\n * Ref: https://developer.mozilla.org/en-US/docs/Web/API/Background_Tasks_API#getting_the_most_out_of_idle_callbacks\n */\nconst MAXIMUM_TIME_REMAINING = 50;\n/**\n * The class attached to the heading collapser button\n */\nconst HEADING_COLLAPSER_CLASS = 'jp-collapseHeadingButton';\n/**\n * The class that controls the visibility of \"heading collapser\" and \"show hidden cells\" buttons.\n */\nconst HEADING_COLLAPSER_VISBILITY_CONTROL_CLASS = 'jp-mod-showHiddenCellsButton';\nconst SIDE_BY_SIDE_CLASS = 'jp-mod-sideBySide';\nif (window.requestIdleCallback === undefined) {\n    // On Safari, requestIdleCallback is not available, so we use replacement functions for `idleCallbacks`\n    // See: https://developer.mozilla.org/en-US/docs/Web/API/Background_Tasks_API#falling_back_to_settimeout\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    window.requestIdleCallback = function (handler) {\n        let startTime = Date.now();\n        return setTimeout(function () {\n            handler({\n                didTimeout: false,\n                timeRemaining: function () {\n                    return Math.max(0, 50.0 - (Date.now() - startTime));\n                }\n            });\n        }, 1);\n    };\n    window.cancelIdleCallback = function (id) {\n        clearTimeout(id);\n    };\n}\n/**\n * A widget which renders static non-interactive notebooks.\n *\n * #### Notes\n * The widget model must be set separately and can be changed\n * at any time.  Consumers of the widget must account for a\n * `null` model, and may want to listen to the `modelChanged`\n * signal.\n */\nexport class StaticNotebook extends WindowedList {\n    /**\n     * Construct a notebook widget.\n     */\n    constructor(options) {\n        var _a, _b, _c, _d, _e;\n        const cells = new Array();\n        super({\n            model: new NotebookViewModel(cells, {\n                overscanCount: (_b = (_a = options.notebookConfig) === null || _a === void 0 ? void 0 : _a.overscanCount) !== null && _b !== void 0 ? _b : StaticNotebook.defaultNotebookConfig.overscanCount,\n                windowingActive: ((_d = (_c = options.notebookConfig) === null || _c === void 0 ? void 0 : _c.windowingMode) !== null && _d !== void 0 ? _d : StaticNotebook.defaultNotebookConfig.windowingMode) === 'full'\n            }),\n            layout: new NotebookWindowedLayout()\n        });\n        this._cellCollapsed = new Signal(this);\n        this._cellInViewportChanged = new Signal(this);\n        this._renderingLayoutChanged = new Signal(this);\n        this.addClass(NB_CLASS);\n        this.cellsArray = cells;\n        this._idleCallBack = null;\n        this._editorConfig = StaticNotebook.defaultEditorConfig;\n        this._notebookConfig = StaticNotebook.defaultNotebookConfig;\n        this._mimetype = 'text/plain';\n        this._notebookModel = null;\n        this._modelChanged = new Signal(this);\n        this._modelContentChanged = new Signal(this);\n        this.node.dataset[KERNEL_USER] = 'true';\n        this.node.dataset[UNDOER] = 'true';\n        this.node.dataset[CODE_RUNNER] = 'true';\n        this.rendermime = options.rendermime;\n        this.translator = options.translator || nullTranslator;\n        this.contentFactory = options.contentFactory;\n        this.editorConfig =\n            options.editorConfig || StaticNotebook.defaultEditorConfig;\n        this.notebookConfig =\n            options.notebookConfig || StaticNotebook.defaultNotebookConfig;\n        this._updateNotebookConfig();\n        this._mimetypeService = options.mimeTypeService;\n        this.renderingLayout = (_e = options.notebookConfig) === null || _e === void 0 ? void 0 : _e.renderingLayout;\n    }\n    get cellCollapsed() {\n        return this._cellCollapsed;\n    }\n    get cellInViewportChanged() {\n        return this._cellInViewportChanged;\n    }\n    /**\n     * A signal emitted when the model of the notebook changes.\n     */\n    get modelChanged() {\n        return this._modelChanged;\n    }\n    /**\n     * A signal emitted when the model content changes.\n     *\n     * #### Notes\n     * This is a convenience signal that follows the current model.\n     */\n    get modelContentChanged() {\n        return this._modelContentChanged;\n    }\n    /**\n     * A signal emitted when the rendering layout of the notebook changes.\n     */\n    get renderingLayoutChanged() {\n        return this._renderingLayoutChanged;\n    }\n    /**\n     * The model for the widget.\n     */\n    get model() {\n        return this._notebookModel;\n    }\n    set model(newValue) {\n        var _a;\n        newValue = newValue || null;\n        if (this._notebookModel === newValue) {\n            return;\n        }\n        const oldValue = this._notebookModel;\n        this._notebookModel = newValue;\n        // Trigger private, protected, and public changes.\n        this._onModelChanged(oldValue, newValue);\n        this.onModelChanged(oldValue, newValue);\n        this._modelChanged.emit(void 0);\n        // Trigger state change\n        this.viewModel.itemsList = (_a = newValue === null || newValue === void 0 ? void 0 : newValue.cells) !== null && _a !== void 0 ? _a : null;\n    }\n    /**\n     * Get the mimetype for code cells.\n     */\n    get codeMimetype() {\n        return this._mimetype;\n    }\n    /**\n     * A read-only sequence of the widgets in the notebook.\n     */\n    get widgets() {\n        return this.cellsArray;\n    }\n    /**\n     * A configuration object for cell editor settings.\n     */\n    get editorConfig() {\n        return this._editorConfig;\n    }\n    set editorConfig(value) {\n        this._editorConfig = value;\n        this._updateEditorConfig();\n    }\n    /**\n     * A configuration object for notebook settings.\n     */\n    get notebookConfig() {\n        return this._notebookConfig;\n    }\n    set notebookConfig(value) {\n        this._notebookConfig = value;\n        this._updateNotebookConfig();\n    }\n    get renderingLayout() {\n        return this._renderingLayout;\n    }\n    set renderingLayout(value) {\n        var _a;\n        this._renderingLayout = value;\n        if (this._renderingLayout === 'side-by-side') {\n            this.node.classList.add(SIDE_BY_SIDE_CLASS);\n        }\n        else {\n            this.node.classList.remove(SIDE_BY_SIDE_CLASS);\n        }\n        this._renderingLayoutChanged.emit((_a = this._renderingLayout) !== null && _a !== void 0 ? _a : 'default');\n    }\n    /**\n     * Dispose of the resources held by the widget.\n     */\n    dispose() {\n        var _a;\n        // Do nothing if already disposed.\n        if (this.isDisposed) {\n            return;\n        }\n        this._notebookModel = null;\n        (_a = this.layout.header) === null || _a === void 0 ? void 0 : _a.dispose();\n        super.dispose();\n    }\n    /**\n     * Move cells preserving widget view state.\n     *\n     * #### Notes\n     * This is required because at the model level a move is a deletion\n     * followed by an insertion. Hence the view state is not preserved.\n     *\n     * @param from The index of the cell to move\n     * @param to The new index of the cell\n     * @param n Number of cells to move\n     */\n    moveCell(from, to, n = 1) {\n        if (!this.model) {\n            return;\n        }\n        const boundedTo = Math.min(this.model.cells.length - 1, Math.max(0, to));\n        if (boundedTo === from) {\n            return;\n        }\n        const viewModel = new Array(n);\n        for (let i = 0; i < n; i++) {\n            viewModel[i] = {};\n            const oldCell = this.widgets[from + i];\n            if (oldCell.model.type === 'markdown') {\n                for (const k of ['rendered', 'headingCollapsed']) {\n                    // @ts-expect-error Cell has no index signature\n                    viewModel[i][k] = oldCell[k];\n                }\n            }\n        }\n        this.model.sharedModel.moveCells(from, boundedTo, n);\n        for (let i = 0; i < n; i++) {\n            const newCell = this.widgets[to + i];\n            const view = viewModel[i];\n            for (const state in view) {\n                // @ts-expect-error Cell has no index signature\n                newCell[state] = view[state];\n            }\n        }\n    }\n    /**\n     * Force rendering the cell outputs of a given cell if it is still a placeholder.\n     *\n     * #### Notes\n     * The goal of this method is to allow search on cell outputs (that is based\n     * on DOM tree introspection).\n     *\n     * @param index The cell index\n     */\n    renderCellOutputs(index) {\n        const cell = this.viewModel.widgetRenderer(index);\n        if (cell instanceof CodeCell && cell.isPlaceholder()) {\n            cell.dataset.windowedListIndex = `${index}`;\n            this.layout.insertWidget(index, cell);\n            if (this.notebookConfig.windowingMode === 'full') {\n                // We need to delay slightly the removal to let codemirror properly initialize\n                requestAnimationFrame(() => {\n                    this.layout.removeWidget(cell);\n                });\n            }\n        }\n    }\n    /**\n     * Adds a message to the notebook as a header.\n     */\n    addHeader() {\n        const trans = this.translator.load('jupyterlab');\n        const info = new Widget();\n        info.node.textContent = trans.__('The notebook is empty. Click the + button on the toolbar to add a new cell.');\n        this.layout.header = info;\n    }\n    /**\n     * Removes the header.\n     */\n    removeHeader() {\n        var _a;\n        (_a = this.layout.header) === null || _a === void 0 ? void 0 : _a.dispose();\n        this.layout.header = null;\n    }\n    /**\n     * Handle a new model.\n     *\n     * #### Notes\n     * This method is called after the model change has been handled\n     * internally and before the `modelChanged` signal is emitted.\n     * The default implementation is a no-op.\n     */\n    onModelChanged(oldValue, newValue) {\n        // No-op.\n    }\n    /**\n     * Handle changes to the notebook model content.\n     *\n     * #### Notes\n     * The default implementation emits the `modelContentChanged` signal.\n     */\n    onModelContentChanged(model, args) {\n        this._modelContentChanged.emit(void 0);\n    }\n    /**\n     * Handle changes to the notebook model metadata.\n     *\n     * #### Notes\n     * The default implementation updates the mimetypes of the code cells\n     * when the `language_info` metadata changes.\n     */\n    onMetadataChanged(sender, args) {\n        switch (args.key) {\n            case 'language_info':\n                this._updateMimetype();\n                break;\n            default:\n                break;\n        }\n    }\n    /**\n     * Handle a cell being inserted.\n     *\n     * The default implementation is a no-op\n     */\n    onCellInserted(index, cell) {\n        // This is a no-op.\n    }\n    /**\n     * Handle a cell being removed.\n     *\n     * The default implementation is a no-op\n     */\n    onCellRemoved(index, cell) {\n        // This is a no-op.\n    }\n    /**\n     * A message handler invoked on an `'update-request'` message.\n     *\n     * #### Notes\n     * The default implementation of this handler is a no-op.\n     */\n    onUpdateRequest(msg) {\n        if (this.notebookConfig.windowingMode === 'defer') {\n            void this._runOnIdleTime();\n        }\n        else {\n            super.onUpdateRequest(msg);\n        }\n    }\n    /**\n     * Handle a new model on the widget.\n     */\n    _onModelChanged(oldValue, newValue) {\n        var _a;\n        if (oldValue) {\n            oldValue.contentChanged.disconnect(this.onModelContentChanged, this);\n            oldValue.metadataChanged.disconnect(this.onMetadataChanged, this);\n            oldValue.cells.changed.disconnect(this._onCellsChanged, this);\n            while (this.cellsArray.length) {\n                this._removeCell(0);\n            }\n        }\n        if (!newValue) {\n            this._mimetype = 'text/plain';\n            return;\n        }\n        this._updateMimetype();\n        const cells = newValue.cells;\n        const collab = (_a = newValue.collaborative) !== null && _a !== void 0 ? _a : false;\n        if (!collab && !cells.length) {\n            newValue.sharedModel.insertCell(0, {\n                cell_type: this.notebookConfig.defaultCell,\n                metadata: this.notebookConfig.defaultCell === 'code'\n                    ? {\n                        // This is an empty cell created in empty notebook, thus is trusted\n                        trusted: true\n                    }\n                    : {}\n            });\n        }\n        let index = -1;\n        for (const cell of cells) {\n            this._insertCell(++index, cell);\n        }\n        newValue.cells.changed.connect(this._onCellsChanged, this);\n        newValue.metadataChanged.connect(this.onMetadataChanged, this);\n        newValue.contentChanged.connect(this.onModelContentChanged, this);\n    }\n    /**\n     * Handle a change cells event.\n     */\n    _onCellsChanged(sender, args) {\n        this.removeHeader();\n        switch (args.type) {\n            case 'add': {\n                let index = 0;\n                index = args.newIndex;\n                for (const value of args.newValues) {\n                    this._insertCell(index++, value);\n                }\n                this._updateDataWindowedListIndex(args.newIndex, this.model.cells.length, args.newValues.length);\n                break;\n            }\n            case 'remove':\n                for (let length = args.oldValues.length; length > 0; length--) {\n                    this._removeCell(args.oldIndex);\n                }\n                this._updateDataWindowedListIndex(args.oldIndex, this.model.cells.length + args.oldValues.length, -1 * args.oldValues.length);\n                // Add default cell if there are no cells remaining.\n                if (!sender.length) {\n                    const model = this.model;\n                    // Add the cell in a new context to avoid triggering another\n                    // cell changed event during the handling of this signal.\n                    requestAnimationFrame(() => {\n                        if (model && !model.isDisposed && !model.sharedModel.cells.length) {\n                            model.sharedModel.insertCell(0, {\n                                cell_type: this.notebookConfig.defaultCell,\n                                metadata: this.notebookConfig.defaultCell === 'code'\n                                    ? {\n                                        // This is an empty cell created in empty notebook, thus is trusted\n                                        trusted: true\n                                    }\n                                    : {}\n                            });\n                        }\n                    });\n                }\n                break;\n            default:\n                return;\n        }\n        if (!this.model.sharedModel.cells.length) {\n            this.addHeader();\n        }\n        this.update();\n    }\n    /**\n     * Create a cell widget and insert into the notebook.\n     */\n    _insertCell(index, cell) {\n        let widget;\n        switch (cell.type) {\n            case 'code':\n                widget = this._createCodeCell(cell);\n                widget.model.mimeType = this._mimetype;\n                break;\n            case 'markdown':\n                widget = this._createMarkdownCell(cell);\n                if (cell.sharedModel.getSource() === '') {\n                    widget.rendered = false;\n                }\n                break;\n            default:\n                widget = this._createRawCell(cell);\n        }\n        widget.inViewportChanged.connect(this._onCellInViewportChanged, this);\n        widget.addClass(NB_CELL_CLASS);\n        ArrayExt.insert(this.cellsArray, index, widget);\n        this.onCellInserted(index, widget);\n        this._scheduleCellRenderOnIdle();\n    }\n    /**\n     * Create a code cell widget from a code cell model.\n     */\n    _createCodeCell(model) {\n        const rendermime = this.rendermime;\n        const contentFactory = this.contentFactory;\n        const editorConfig = this.editorConfig.code;\n        const options = {\n            contentFactory,\n            editorConfig,\n            inputHistoryScope: this.notebookConfig.inputHistoryScope,\n            maxNumberOutputs: this.notebookConfig.maxNumberOutputs,\n            model,\n            placeholder: this._notebookConfig.windowingMode !== 'none',\n            rendermime,\n            translator: this.translator\n        };\n        const cell = this.contentFactory.createCodeCell(options);\n        cell.syncCollapse = true;\n        cell.syncEditable = true;\n        cell.syncScrolled = true;\n        cell.outputArea.inputRequested.connect(() => {\n            this._onInputRequested(cell).catch(reason => {\n                console.error('Failed to scroll to cell requesting input.', reason);\n            });\n        });\n        return cell;\n    }\n    /**\n     * Create a markdown cell widget from a markdown cell model.\n     */\n    _createMarkdownCell(model) {\n        const rendermime = this.rendermime;\n        const contentFactory = this.contentFactory;\n        const editorConfig = this.editorConfig.markdown;\n        const options = {\n            contentFactory,\n            editorConfig,\n            model,\n            placeholder: this._notebookConfig.windowingMode !== 'none',\n            rendermime,\n            showEditorForReadOnlyMarkdown: this._notebookConfig.showEditorForReadOnlyMarkdown\n        };\n        const cell = this.contentFactory.createMarkdownCell(options);\n        cell.syncCollapse = true;\n        cell.syncEditable = true;\n        // Connect collapsed signal for each markdown cell widget\n        cell.headingCollapsedChanged.connect(this._onCellCollapsed, this);\n        return cell;\n    }\n    /**\n     * Create a raw cell widget from a raw cell model.\n     */\n    _createRawCell(model) {\n        const contentFactory = this.contentFactory;\n        const editorConfig = this.editorConfig.raw;\n        const options = {\n            editorConfig,\n            model,\n            contentFactory,\n            placeholder: this._notebookConfig.windowingMode !== 'none'\n        };\n        const cell = this.contentFactory.createRawCell(options);\n        cell.syncCollapse = true;\n        cell.syncEditable = true;\n        return cell;\n    }\n    /**\n     * Remove a cell widget.\n     */\n    _removeCell(index) {\n        const widget = this.cellsArray[index];\n        widget.parent = null;\n        ArrayExt.removeAt(this.cellsArray, index);\n        this.onCellRemoved(index, widget);\n        widget.dispose();\n    }\n    /**\n     * Update the mimetype of the notebook.\n     */\n    _updateMimetype() {\n        var _a;\n        const info = (_a = this._notebookModel) === null || _a === void 0 ? void 0 : _a.getMetadata('language_info');\n        if (!info) {\n            return;\n        }\n        this._mimetype = this._mimetypeService.getMimeTypeByLanguage(info);\n        for (const widget of this.widgets) {\n            if (widget.model.type === 'code') {\n                widget.model.mimeType = this._mimetype;\n            }\n        }\n    }\n    /**\n     * Callback when a cell collapsed status changes.\n     *\n     * @param cell Cell changed\n     * @param collapsed New collapsed status\n     */\n    _onCellCollapsed(cell, collapsed) {\n        NotebookActions.setHeadingCollapse(cell, collapsed, this);\n        this._cellCollapsed.emit(cell);\n    }\n    /**\n     * Callback when a cell viewport status changes.\n     *\n     * @param cell Cell changed\n     */\n    _onCellInViewportChanged(cell) {\n        this._cellInViewportChanged.emit(cell);\n    }\n    /**\n     * Ensure to load in the DOM a cell requesting an user input\n     *\n     * @param cell Cell requesting an input\n     */\n    async _onInputRequested(cell) {\n        if (!cell.inViewport) {\n            const cellIndex = this.widgets.findIndex(c => c === cell);\n            if (cellIndex >= 0) {\n                await this.scrollToItem(cellIndex);\n                const inputEl = cell.node.querySelector('.jp-Stdin');\n                if (inputEl) {\n                    ElementExt.scrollIntoViewIfNeeded(this.node, inputEl);\n                    inputEl.focus();\n                }\n            }\n        }\n    }\n    _scheduleCellRenderOnIdle() {\n        if (this.notebookConfig.windowingMode !== 'none' && !this.isDisposed) {\n            if (!this._idleCallBack) {\n                this._idleCallBack = requestIdleCallback((deadline) => {\n                    this._idleCallBack = null;\n                    // In case of timeout, render for some time even if it means freezing the UI\n                    // This avoids the cells to never be loaded.\n                    void this._runOnIdleTime(deadline.didTimeout\n                        ? MAXIMUM_TIME_REMAINING\n                        : deadline.timeRemaining());\n                }, {\n                    timeout: 3000\n                });\n            }\n        }\n    }\n    _updateDataWindowedListIndex(start, end, delta) {\n        for (let cellIdx = 0; cellIdx < this.viewportNode.childElementCount; cellIdx++) {\n            const cell = this.viewportNode.children[cellIdx];\n            const globalIndex = parseInt(cell.dataset.windowedListIndex, 10);\n            if (globalIndex >= start && globalIndex < end) {\n                cell.dataset.windowedListIndex = `${globalIndex + delta}`;\n            }\n        }\n    }\n    /**\n     * Update editor settings for notebook cells.\n     */\n    _updateEditorConfig() {\n        for (let i = 0; i < this.widgets.length; i++) {\n            const cell = this.widgets[i];\n            let config = {};\n            switch (cell.model.type) {\n                case 'code':\n                    config = this._editorConfig.code;\n                    break;\n                case 'markdown':\n                    config = this._editorConfig.markdown;\n                    break;\n                default:\n                    config = this._editorConfig.raw;\n                    break;\n            }\n            cell.updateEditorConfig({ ...config });\n        }\n    }\n    async _runOnIdleTime(remainingTime = MAXIMUM_TIME_REMAINING) {\n        const startTime = Date.now();\n        let cellIdx = 0;\n        while (Date.now() - startTime < remainingTime &&\n            cellIdx < this.cellsArray.length) {\n            const cell = this.cellsArray[cellIdx];\n            if (cell.isPlaceholder()) {\n                switch (this.notebookConfig.windowingMode) {\n                    case 'defer':\n                        await this._updateForDeferMode(cell, cellIdx);\n                        break;\n                    case 'full':\n                        this._renderCSSAndJSOutputs(cell, cellIdx);\n                        break;\n                }\n            }\n            cellIdx++;\n        }\n        if (cellIdx < this.cellsArray.length) {\n            this._scheduleCellRenderOnIdle();\n        }\n        else {\n            if (this._idleCallBack) {\n                window.cancelIdleCallback(this._idleCallBack);\n                this._idleCallBack = null;\n            }\n        }\n    }\n    async _updateForDeferMode(cell, cellIdx) {\n        cell.dataset.windowedListIndex = `${cellIdx}`;\n        this.layout.insertWidget(cellIdx, cell);\n        await cell.ready;\n    }\n    _renderCSSAndJSOutputs(cell, cellIdx) {\n        var _a, _b, _c;\n        // Only render cell with text/html outputs containing scripts or/and styles\n        // Note:\n        //   We don't need to render JavaScript mimetype outputs because they get\n        //   directly evaluate without adding DOM elements (see @jupyterlab/javascript-extension)\n        if (cell instanceof CodeCell) {\n            for (let outputIdx = 0; outputIdx < ((_b = (_a = cell.model.outputs) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0); outputIdx++) {\n                const output = cell.model.outputs.get(outputIdx);\n                const html = (_c = output.data['text/html']) !== null && _c !== void 0 ? _c : '';\n                if (html.match(/(<style[^>]*>[^<]*<\\/style[^>]*>|<script[^>]*>.*?<\\/script[^>]*>)/gims)) {\n                    this.renderCellOutputs(cellIdx);\n                    break;\n                }\n            }\n        }\n    }\n    /**\n     * Apply updated notebook settings.\n     */\n    _updateNotebookConfig() {\n        // Apply scrollPastEnd setting.\n        this.toggleClass('jp-mod-scrollPastEnd', this._notebookConfig.scrollPastEnd);\n        // Control visibility of heading collapser UI\n        this.toggleClass(HEADING_COLLAPSER_VISBILITY_CONTROL_CLASS, this._notebookConfig.showHiddenCellsButton);\n        // Control editor visibility for read-only Markdown cells\n        const showEditorForReadOnlyMarkdown = this._notebookConfig.showEditorForReadOnlyMarkdown;\n        if (showEditorForReadOnlyMarkdown !== undefined) {\n            for (const cell of this.cellsArray) {\n                if (cell.model.type === 'markdown') {\n                    cell.showEditorForReadOnly =\n                        showEditorForReadOnlyMarkdown;\n                }\n            }\n        }\n        this.viewModel.windowingActive =\n            this._notebookConfig.windowingMode === 'full';\n    }\n}\n/**\n * The namespace for the `StaticNotebook` class statics.\n */\n(function (StaticNotebook) {\n    /**\n     * Default configuration options for cell editors.\n     */\n    StaticNotebook.defaultEditorConfig = {\n        code: {\n            lineNumbers: false,\n            lineWrap: false,\n            matchBrackets: true\n        },\n        markdown: {\n            lineNumbers: false,\n            lineWrap: true,\n            matchBrackets: false\n        },\n        raw: {\n            lineNumbers: false,\n            lineWrap: true,\n            matchBrackets: false\n        }\n    };\n    /**\n     * Default configuration options for notebooks.\n     */\n    StaticNotebook.defaultNotebookConfig = {\n        showHiddenCellsButton: true,\n        scrollPastEnd: true,\n        defaultCell: 'code',\n        recordTiming: false,\n        inputHistoryScope: 'global',\n        maxNumberOutputs: 50,\n        showEditorForReadOnlyMarkdown: true,\n        disableDocumentWideUndoRedo: true,\n        renderingLayout: 'default',\n        sideBySideLeftMarginOverride: '10px',\n        sideBySideRightMarginOverride: '10px',\n        sideBySideOutputRatio: 1,\n        overscanCount: 1,\n        windowingMode: 'full'\n    };\n    /**\n     * The default implementation of an `IContentFactory`.\n     */\n    class ContentFactory extends Cell.ContentFactory {\n        /**\n         * Create a new code cell widget.\n         *\n         * #### Notes\n         * If no cell content factory is passed in with the options, the one on the\n         * notebook content factory is used.\n         */\n        createCodeCell(options) {\n            return new CodeCell(options).initializeState();\n        }\n        /**\n         * Create a new markdown cell widget.\n         *\n         * #### Notes\n         * If no cell content factory is passed in with the options, the one on the\n         * notebook content factory is used.\n         */\n        createMarkdownCell(options) {\n            return new MarkdownCell(options).initializeState();\n        }\n        /**\n         * Create a new raw cell widget.\n         *\n         * #### Notes\n         * If no cell content factory is passed in with the options, the one on the\n         * notebook content factory is used.\n         */\n        createRawCell(options) {\n            return new RawCell(options).initializeState();\n        }\n    }\n    StaticNotebook.ContentFactory = ContentFactory;\n})(StaticNotebook || (StaticNotebook = {}));\n/**\n * A notebook widget that supports interactivity.\n */\nexport class Notebook extends StaticNotebook {\n    /**\n     * Construct a notebook widget.\n     */\n    constructor(options) {\n        super(options);\n        this._activeCellIndex = -1;\n        this._activeCell = null;\n        this._mode = 'command';\n        this._drag = null;\n        this._dragData = null;\n        this._mouseMode = null;\n        this._activeCellChanged = new Signal(this);\n        this._stateChanged = new Signal(this);\n        this._selectionChanged = new Signal(this);\n        this._checkCacheOnNextResize = false;\n        this._lastClipboardInteraction = null;\n        this._selectedCells = [];\n        this.node.tabIndex = 0; // Allow the widget to take focus.\n        // Allow the node to scroll while dragging items.\n        this.node.setAttribute('data-lm-dragscroll', 'true');\n        this.activeCellChanged.connect(this._updateSelectedCells, this);\n        this.selectionChanged.connect(this._updateSelectedCells, this);\n        this.addFooter();\n    }\n    /**\n     * List of selected and active cells\n     */\n    get selectedCells() {\n        return this._selectedCells;\n    }\n    /**\n     * Adds a footer to the notebook.\n     */\n    addFooter() {\n        const info = new NotebookFooter(this);\n        this.layout.footer = info;\n    }\n    /**\n     * Handle a change cells event.\n     */\n    _onCellsChanged(sender, args) {\n        var _a, _b;\n        const activeCellId = (_a = this.activeCell) === null || _a === void 0 ? void 0 : _a.model.id;\n        super._onCellsChanged(sender, args);\n        if (activeCellId) {\n            const newActiveCellIndex = (_b = this.model) === null || _b === void 0 ? void 0 : _b.sharedModel.cells.findIndex(cell => cell.getId() === activeCellId);\n            if (newActiveCellIndex != null) {\n                this.activeCellIndex = newActiveCellIndex;\n            }\n        }\n    }\n    /**\n     * A signal emitted when the active cell changes.\n     *\n     * #### Notes\n     * This can be due to the active index changing or the\n     * cell at the active index changing.\n     */\n    get activeCellChanged() {\n        return this._activeCellChanged;\n    }\n    /**\n     * A signal emitted when the state of the notebook changes.\n     */\n    get stateChanged() {\n        return this._stateChanged;\n    }\n    /**\n     * A signal emitted when the selection state of the notebook changes.\n     */\n    get selectionChanged() {\n        return this._selectionChanged;\n    }\n    /**\n     * The interactivity mode of the notebook.\n     */\n    get mode() {\n        return this._mode;\n    }\n    set mode(newValue) {\n        const activeCell = this.activeCell;\n        if (!activeCell) {\n            newValue = 'command';\n        }\n        if (newValue === this._mode) {\n            this._ensureFocus();\n            return;\n        }\n        // Post an update request.\n        this.update();\n        const oldValue = this._mode;\n        this._mode = newValue;\n        if (newValue === 'edit') {\n            // Edit mode deselects all cells.\n            for (const widget of this.widgets) {\n                this.deselect(widget);\n            }\n            //  Edit mode unrenders an active markdown widget.\n            if (activeCell instanceof MarkdownCell) {\n                activeCell.rendered = false;\n            }\n            activeCell.inputHidden = false;\n        }\n        else {\n            // Focus on the notebook document, which blurs the active cell.\n            this.node.focus();\n        }\n        this._stateChanged.emit({ name: 'mode', oldValue, newValue });\n        this._ensureFocus();\n    }\n    /**\n     * The active cell index of the notebook.\n     *\n     * #### Notes\n     * The index will be clamped to the bounds of the notebook cells.\n     */\n    get activeCellIndex() {\n        if (!this.model) {\n            return -1;\n        }\n        return this.widgets.length ? this._activeCellIndex : -1;\n    }\n    set activeCellIndex(newValue) {\n        var _a;\n        const oldValue = this._activeCellIndex;\n        if (!this.model || !this.widgets.length) {\n            newValue = -1;\n        }\n        else {\n            newValue = Math.max(newValue, 0);\n            newValue = Math.min(newValue, this.widgets.length - 1);\n        }\n        this._activeCellIndex = newValue;\n        const cell = (_a = this.widgets[newValue]) !== null && _a !== void 0 ? _a : null;\n        const cellChanged = cell !== this._activeCell;\n        if (cellChanged) {\n            // Post an update request.\n            this.update();\n            this._activeCell = cell;\n        }\n        if (cellChanged || newValue != oldValue) {\n            this._activeCellChanged.emit(cell);\n        }\n        if (this.mode === 'edit' && cell instanceof MarkdownCell) {\n            cell.rendered = false;\n        }\n        this._ensureFocus();\n        if (newValue === oldValue) {\n            return;\n        }\n        this._trimSelections();\n        this._stateChanged.emit({ name: 'activeCellIndex', oldValue, newValue });\n    }\n    /**\n     * Get the active cell widget.\n     *\n     * #### Notes\n     * This is a cell or `null` if there is no active cell.\n     */\n    get activeCell() {\n        return this._activeCell;\n    }\n    get lastClipboardInteraction() {\n        return this._lastClipboardInteraction;\n    }\n    set lastClipboardInteraction(newValue) {\n        this._lastClipboardInteraction = newValue;\n    }\n    /**\n     * Dispose of the resources held by the widget.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._activeCell = null;\n        super.dispose();\n    }\n    /**\n     * Move cells preserving widget view state.\n     *\n     * #### Notes\n     * This is required because at the model level a move is a deletion\n     * followed by an insertion. Hence the view state is not preserved.\n     *\n     * @param from The index of the cell to move\n     * @param to The new index of the cell\n     * @param n Number of cells to move\n     */\n    moveCell(from, to, n = 1) {\n        // Save active cell id to be restored\n        const newActiveCellIndex = from <= this.activeCellIndex && this.activeCellIndex < from + n\n            ? this.activeCellIndex + to - from - (from > to ? 0 : n - 1)\n            : -1;\n        const isSelected = this.widgets\n            .slice(from, from + n)\n            .map(w => this.isSelected(w));\n        super.moveCell(from, to, n);\n        if (newActiveCellIndex >= 0) {\n            this.activeCellIndex = newActiveCellIndex;\n        }\n        if (from > to) {\n            isSelected.forEach((selected, idx) => {\n                if (selected) {\n                    this.select(this.widgets[to + idx]);\n                }\n            });\n        }\n        else {\n            isSelected.forEach((selected, idx) => {\n                if (selected) {\n                    this.select(this.widgets[to - n + 1 + idx]);\n                }\n            });\n        }\n    }\n    /**\n     * Select a cell widget.\n     *\n     * #### Notes\n     * It is a no-op if the value does not change.\n     * It will emit the `selectionChanged` signal.\n     */\n    select(widget) {\n        if (Private.selectedProperty.get(widget)) {\n            return;\n        }\n        Private.selectedProperty.set(widget, true);\n        this._selectionChanged.emit(void 0);\n        this.update();\n    }\n    /**\n     * Deselect a cell widget.\n     *\n     * #### Notes\n     * It is a no-op if the value does not change.\n     * It will emit the `selectionChanged` signal.\n     */\n    deselect(widget) {\n        if (!Private.selectedProperty.get(widget)) {\n            return;\n        }\n        Private.selectedProperty.set(widget, false);\n        this._selectionChanged.emit(void 0);\n        this.update();\n    }\n    /**\n     * Whether a cell is selected.\n     */\n    isSelected(widget) {\n        return Private.selectedProperty.get(widget);\n    }\n    /**\n     * Whether a cell is selected or is the active cell.\n     */\n    isSelectedOrActive(widget) {\n        if (widget === this._activeCell) {\n            return true;\n        }\n        return Private.selectedProperty.get(widget);\n    }\n    /**\n     * Deselect all of the cells.\n     */\n    deselectAll() {\n        let changed = false;\n        for (const widget of this.widgets) {\n            if (Private.selectedProperty.get(widget)) {\n                changed = true;\n            }\n            Private.selectedProperty.set(widget, false);\n        }\n        if (changed) {\n            this._selectionChanged.emit(void 0);\n        }\n        // Make sure we have a valid active cell.\n        this.activeCellIndex = this.activeCellIndex; // eslint-disable-line\n        this.update();\n    }\n    /**\n     * Move the head of an existing contiguous selection to extend the selection.\n     *\n     * @param index - The new head of the existing selection.\n     *\n     * #### Notes\n     * If there is no existing selection, the active cell is considered an\n     * existing one-cell selection.\n     *\n     * If the new selection is a single cell, that cell becomes the active cell\n     * and all cells are deselected.\n     *\n     * There is no change if there are no cells (i.e., activeCellIndex is -1).\n     */\n    extendContiguousSelectionTo(index) {\n        let { head, anchor } = this.getContiguousSelection();\n        let i;\n        // Handle the case of no current selection.\n        if (anchor === null || head === null) {\n            if (index === this.activeCellIndex) {\n                // Already collapsed selection, nothing more to do.\n                return;\n            }\n            // We will start a new selection below.\n            head = this.activeCellIndex;\n            anchor = this.activeCellIndex;\n        }\n        // Move the active cell. We do this before the collapsing shortcut below.\n        this.activeCellIndex = index;\n        // Make sure the index is valid, according to the rules for setting and clipping the\n        // active cell index. This may change the index.\n        index = this.activeCellIndex;\n        // Collapse the selection if it is only the active cell.\n        if (index === anchor) {\n            this.deselectAll();\n            return;\n        }\n        let selectionChanged = false;\n        if (head < index) {\n            if (head < anchor) {\n                Private.selectedProperty.set(this.widgets[head], false);\n                selectionChanged = true;\n            }\n            // Toggle everything strictly between head and index except anchor.\n            for (i = head + 1; i < index; i++) {\n                if (i !== anchor) {\n                    Private.selectedProperty.set(this.widgets[i], !Private.selectedProperty.get(this.widgets[i]));\n                    selectionChanged = true;\n                }\n            }\n        }\n        else if (index < head) {\n            if (anchor < head) {\n                Private.selectedProperty.set(this.widgets[head], false);\n                selectionChanged = true;\n            }\n            // Toggle everything strictly between index and head except anchor.\n            for (i = index + 1; i < head; i++) {\n                if (i !== anchor) {\n                    Private.selectedProperty.set(this.widgets[i], !Private.selectedProperty.get(this.widgets[i]));\n                    selectionChanged = true;\n                }\n            }\n        }\n        // Anchor and index should *always* be selected.\n        if (!Private.selectedProperty.get(this.widgets[anchor])) {\n            selectionChanged = true;\n        }\n        Private.selectedProperty.set(this.widgets[anchor], true);\n        if (!Private.selectedProperty.get(this.widgets[index])) {\n            selectionChanged = true;\n        }\n        Private.selectedProperty.set(this.widgets[index], true);\n        if (selectionChanged) {\n            this._selectionChanged.emit(void 0);\n        }\n    }\n    /**\n     * Get the head and anchor of a contiguous cell selection.\n     *\n     * The head of a contiguous selection is always the active cell.\n     *\n     * If there are no cells selected, `{head: null, anchor: null}` is returned.\n     *\n     * Throws an error if the currently selected cells do not form a contiguous\n     * selection.\n     */\n    getContiguousSelection() {\n        const cells = this.widgets;\n        const first = ArrayExt.findFirstIndex(cells, c => this.isSelected(c));\n        // Return early if no cells are selected.\n        if (first === -1) {\n            return { head: null, anchor: null };\n        }\n        const last = ArrayExt.findLastIndex(cells, c => this.isSelected(c), -1, first);\n        // Check that the selection is contiguous.\n        for (let i = first; i <= last; i++) {\n            if (!this.isSelected(cells[i])) {\n                throw new Error('Selection not contiguous');\n            }\n        }\n        // Check that the active cell is one of the endpoints of the selection.\n        const activeIndex = this.activeCellIndex;\n        if (first !== activeIndex && last !== activeIndex) {\n            throw new Error('Active cell not at endpoint of selection');\n        }\n        // Determine the head and anchor of the selection.\n        if (first === activeIndex) {\n            return { head: first, anchor: last };\n        }\n        else {\n            return { head: last, anchor: first };\n        }\n    }\n    /**\n     * Scroll so that the given cell is in view. Selects and activates cell.\n     *\n     * @param cell - A cell in the notebook widget.\n     * @param align - Type of alignment.\n     *\n     */\n    async scrollToCell(cell, align = 'auto') {\n        try {\n            await this.scrollToItem(this.widgets.findIndex(c => c === cell), align);\n        }\n        catch (r) {\n            //no-op\n        }\n        // change selection and active cell:\n        this.deselectAll();\n        this.select(cell);\n        cell.activate();\n    }\n    _parseFragment(fragment) {\n        const cleanedFragment = fragment.slice(1);\n        if (!cleanedFragment) {\n            // Bail early\n            return;\n        }\n        const parts = cleanedFragment.split('=');\n        if (parts.length === 1) {\n            // Default to heading if no prefix is given.\n            return {\n                kind: 'heading',\n                value: cleanedFragment\n            };\n        }\n        return {\n            kind: parts[0],\n            value: parts.slice(1).join('=')\n        };\n    }\n    /**\n     * Set URI fragment identifier.\n     */\n    async setFragment(fragment) {\n        const parsedFragment = this._parseFragment(fragment);\n        if (!parsedFragment) {\n            // Bail early\n            return;\n        }\n        let result;\n        switch (parsedFragment.kind) {\n            case 'heading':\n                result = await this._findHeading(parsedFragment.value);\n                break;\n            case 'cell-id':\n                result = this._findCellById(parsedFragment.value);\n                break;\n            default:\n                console.warn(`Unknown target type for URI fragment ${fragment}, interpreting as a heading`);\n                result = await this._findHeading(parsedFragment.kind + '=' + parsedFragment.value);\n                break;\n        }\n        if (result == null) {\n            return;\n        }\n        let { cell, element } = result;\n        if (!cell.inViewport) {\n            await this.scrollToCell(cell, 'center');\n        }\n        if (element == null) {\n            element = cell.node;\n        }\n        const widgetBox = this.node.getBoundingClientRect();\n        const elementBox = element.getBoundingClientRect();\n        if (elementBox.top > widgetBox.bottom ||\n            elementBox.bottom < widgetBox.top) {\n            element.scrollIntoView({ block: 'center' });\n        }\n    }\n    /**\n     * Handle the DOM events for the widget.\n     *\n     * @param event - The DOM event sent to the widget.\n     *\n     * #### Notes\n     * This method implements the DOM `EventListener` interface and is\n     * called in response to events on the notebook panel's node. It should\n     * not be called directly by user code.\n     */\n    handleEvent(event) {\n        if (!this.model) {\n            return;\n        }\n        switch (event.type) {\n            case 'contextmenu':\n                if (event.eventPhase === Event.CAPTURING_PHASE) {\n                    this._evtContextMenuCapture(event);\n                }\n                break;\n            case 'mousedown':\n                if (event.eventPhase === Event.CAPTURING_PHASE) {\n                    this._evtMouseDownCapture(event);\n                }\n                else {\n                    // Skip processing the event when it resulted from a toolbar button click\n                    if (!event.defaultPrevented) {\n                        this._evtMouseDown(event);\n                    }\n                }\n                break;\n            case 'mouseup':\n                if (event.currentTarget === document) {\n                    this._evtDocumentMouseup(event);\n                }\n                break;\n            case 'mousemove':\n                if (event.currentTarget === document) {\n                    this._evtDocumentMousemove(event);\n                }\n                break;\n            case 'keydown':\n                this._ensureFocus(true);\n                break;\n            case 'dblclick':\n                this._evtDblClick(event);\n                break;\n            case 'focusin':\n                this._evtFocusIn(event);\n                break;\n            case 'focusout':\n                this._evtFocusOut(event);\n                break;\n            case 'lm-dragenter':\n                this._evtDragEnter(event);\n                break;\n            case 'lm-dragleave':\n                this._evtDragLeave(event);\n                break;\n            case 'lm-dragover':\n                this._evtDragOver(event);\n                break;\n            case 'lm-drop':\n                this._evtDrop(event);\n                break;\n            default:\n                super.handleEvent(event);\n                break;\n        }\n    }\n    /**\n     * Handle `after-attach` messages for the widget.\n     */\n    onAfterAttach(msg) {\n        super.onAfterAttach(msg);\n        const node = this.node;\n        node.addEventListener('contextmenu', this, true);\n        node.addEventListener('mousedown', this, true);\n        node.addEventListener('mousedown', this);\n        node.addEventListener('keydown', this);\n        node.addEventListener('dblclick', this);\n        node.addEventListener('focusin', this);\n        node.addEventListener('focusout', this);\n        // Capture drag events for the notebook widget\n        // in order to preempt the drag/drop handlers in the\n        // code editor widgets, which can take text data.\n        node.addEventListener('lm-dragenter', this, true);\n        node.addEventListener('lm-dragleave', this, true);\n        node.addEventListener('lm-dragover', this, true);\n        node.addEventListener('lm-drop', this, true);\n    }\n    /**\n     * Handle `before-detach` messages for the widget.\n     */\n    onBeforeDetach(msg) {\n        const node = this.node;\n        node.removeEventListener('contextmenu', this, true);\n        node.removeEventListener('mousedown', this, true);\n        node.removeEventListener('mousedown', this);\n        node.removeEventListener('keydown', this);\n        node.removeEventListener('dblclick', this);\n        node.removeEventListener('focusin', this);\n        node.removeEventListener('focusout', this);\n        node.removeEventListener('lm-dragenter', this, true);\n        node.removeEventListener('lm-dragleave', this, true);\n        node.removeEventListener('lm-dragover', this, true);\n        node.removeEventListener('lm-drop', this, true);\n        document.removeEventListener('mousemove', this, true);\n        document.removeEventListener('mouseup', this, true);\n        super.onBeforeAttach(msg);\n    }\n    /**\n     * A message handler invoked on an `'after-show'` message.\n     */\n    onAfterShow(msg) {\n        super.onAfterShow(msg);\n        this._checkCacheOnNextResize = true;\n    }\n    /**\n     * A message handler invoked on a `'resize'` message.\n     */\n    onResize(msg) {\n        var _a;\n        // TODO\n        if (!this._checkCacheOnNextResize) {\n            return super.onResize(msg);\n        }\n        super.onResize(msg);\n        this._checkCacheOnNextResize = false;\n        const cache = this._cellLayoutStateCache;\n        const width = parseInt(this.node.style.width, 10);\n        if (cache) {\n            if (width === cache.width) {\n                // Cache identical, do nothing\n                return;\n            }\n        }\n        // Update cache\n        this._cellLayoutStateCache = { width };\n        // Fallback:\n        for (const w of this.widgets) {\n            if (w instanceof Cell && w.inViewport) {\n                (_a = w.editorWidget) === null || _a === void 0 ? void 0 : _a.update();\n            }\n        }\n    }\n    /**\n     * A message handler invoked on an `'before-hide'` message.\n     */\n    onBeforeHide(msg) {\n        super.onBeforeHide(msg);\n        // Update cache\n        const width = parseInt(this.node.style.width, 10);\n        this._cellLayoutStateCache = { width };\n    }\n    /**\n     * Handle `'activate-request'` messages.\n     */\n    onActivateRequest(msg) {\n        super.onActivateRequest(msg);\n        this._ensureFocus(true);\n    }\n    /**\n     * Handle `update-request` messages sent to the widget.\n     */\n    onUpdateRequest(msg) {\n        super.onUpdateRequest(msg);\n        const activeCell = this.activeCell;\n        // Set the appropriate classes on the cells.\n        if (this.mode === 'edit') {\n            this.addClass(EDIT_CLASS);\n            this.removeClass(COMMAND_CLASS);\n        }\n        else {\n            this.addClass(COMMAND_CLASS);\n            this.removeClass(EDIT_CLASS);\n        }\n        if (activeCell) {\n            activeCell.addClass(ACTIVE_CLASS);\n        }\n        let count = 0;\n        for (const widget of this.widgets) {\n            if (widget !== activeCell) {\n                widget.removeClass(ACTIVE_CLASS);\n            }\n            widget.removeClass(OTHER_SELECTED_CLASS);\n            if (this.isSelectedOrActive(widget)) {\n                widget.addClass(SELECTED_CLASS);\n                count++;\n            }\n            else {\n                widget.removeClass(SELECTED_CLASS);\n            }\n        }\n        if (count > 1) {\n            activeCell === null || activeCell === void 0 ? void 0 : activeCell.addClass(OTHER_SELECTED_CLASS);\n        }\n    }\n    /**\n     * Handle a cell being inserted.\n     */\n    onCellInserted(index, cell) {\n        void cell.ready.then(() => {\n            if (!cell.isDisposed) {\n                cell.editor.edgeRequested.connect(this._onEdgeRequest, this);\n            }\n        });\n        // If the insertion happened above, increment the active cell\n        // index, otherwise it stays the same.\n        this.activeCellIndex =\n            index <= this.activeCellIndex\n                ? this.activeCellIndex + 1\n                : this.activeCellIndex;\n    }\n    /**\n     * Handle a cell being removed.\n     */\n    onCellRemoved(index, cell) {\n        // If the removal happened above, decrement the active\n        // cell index, otherwise it stays the same.\n        this.activeCellIndex =\n            index <= this.activeCellIndex\n                ? this.activeCellIndex - 1\n                : this.activeCellIndex;\n        if (this.isSelected(cell)) {\n            this._selectionChanged.emit(void 0);\n        }\n    }\n    /**\n     * Handle a new model.\n     */\n    onModelChanged(oldValue, newValue) {\n        super.onModelChanged(oldValue, newValue);\n        // Try to set the active cell index to 0.\n        // It will be set to `-1` if there is no new model or the model is empty.\n        this.activeCellIndex = 0;\n    }\n    /**\n     * Handle edge request signals from cells.\n     */\n    _onEdgeRequest(editor, location) {\n        const prev = this.activeCellIndex;\n        if (location === 'top') {\n            this.activeCellIndex--;\n            // Move the cursor to the first position on the last line.\n            if (this.activeCellIndex < prev) {\n                const editor = this.activeCell.editor;\n                if (editor) {\n                    const lastLine = editor.lineCount - 1;\n                    editor.setCursorPosition({ line: lastLine, column: 0 });\n                }\n            }\n        }\n        else if (location === 'bottom') {\n            this.activeCellIndex++;\n            // Move the cursor to the first character.\n            if (this.activeCellIndex > prev) {\n                const editor = this.activeCell.editor;\n                if (editor) {\n                    editor.setCursorPosition({ line: 0, column: 0 });\n                }\n            }\n        }\n        this.mode = 'edit';\n    }\n    /**\n     * Ensure that the notebook has proper focus.\n     */\n    _ensureFocus(force = false) {\n        var _a, _b;\n        const activeCell = this.activeCell;\n        if (this.mode === 'edit' && activeCell) {\n            // Test for !== true to cover hasFocus is false and editor is not yet rendered.\n            if (((_a = activeCell.editor) === null || _a === void 0 ? void 0 : _a.hasFocus()) !== true) {\n                if (activeCell.inViewport) {\n                    (_b = activeCell.editor) === null || _b === void 0 ? void 0 : _b.focus();\n                }\n                else {\n                    this.scrollToItem(this.activeCellIndex)\n                        .then(() => {\n                        void activeCell.ready.then(() => {\n                            var _a;\n                            (_a = activeCell.editor) === null || _a === void 0 ? void 0 : _a.focus();\n                        });\n                    })\n                        .catch(reason => {\n                        // no-op\n                    });\n                }\n            }\n        }\n        if (force && !this.node.contains(document.activeElement)) {\n            this.node.focus();\n        }\n    }\n    /**\n     * Find the cell index containing the target html element.\n     *\n     * #### Notes\n     * Returns -1 if the cell is not found.\n     */\n    _findCell(node) {\n        // Trace up the DOM hierarchy to find the root cell node.\n        // Then find the corresponding child and select it.\n        let n = node;\n        while (n && n !== this.node) {\n            if (n.classList.contains(NB_CELL_CLASS)) {\n                const i = ArrayExt.findFirstIndex(this.widgets, widget => widget.node === n);\n                if (i !== -1) {\n                    return i;\n                }\n                break;\n            }\n            n = n.parentElement;\n        }\n        return -1;\n    }\n    /**\n     * Find the target of html mouse event and cell index containing this target.\n     *\n     * #### Notes\n     * Returned index is -1 if the cell is not found.\n     */\n    _findEventTargetAndCell(event) {\n        let target = event.target;\n        let index = this._findCell(target);\n        if (index === -1) {\n            // `event.target` sometimes gives an orphaned node in Firefox 57, which\n            // can have `null` anywhere in its parent line. If we fail to find a cell\n            // using `event.target`, try again using a target reconstructed from the\n            // position of the click event.\n            target = document.elementFromPoint(event.clientX, event.clientY);\n            index = this._findCell(target);\n        }\n        return [target, index];\n    }\n    /**\n     * Find heading with given ID in any of the cells.\n     */\n    async _findHeading(queryId) {\n        // Loop on cells, get headings and search for first matching id.\n        for (let cellIdx = 0; cellIdx < this.widgets.length; cellIdx++) {\n            const cell = this.widgets[cellIdx];\n            if (cell.model.type === 'raw' ||\n                (cell.model.type === 'markdown' && !cell.rendered)) {\n                // Bail early\n                continue;\n            }\n            for (const heading of cell.headings) {\n                let id = '';\n                switch (heading.type) {\n                    case Cell.HeadingType.HTML:\n                        id = heading.id;\n                        break;\n                    case Cell.HeadingType.Markdown:\n                        {\n                            const mdHeading = heading;\n                            id = await TableOfContentsUtils.Markdown.getHeadingId(this.rendermime.markdownParser, mdHeading.raw, mdHeading.level);\n                        }\n                        break;\n                }\n                if (id === queryId) {\n                    const element = this.node.querySelector(`h${heading.level}[id=\"${id}\"]`);\n                    return {\n                        cell,\n                        element\n                    };\n                }\n            }\n        }\n        return null;\n    }\n    /**\n     * Find cell by its unique ID.\n     */\n    _findCellById(queryId) {\n        for (let cellIdx = 0; cellIdx < this.widgets.length; cellIdx++) {\n            const cell = this.widgets[cellIdx];\n            if (cell.model.id === queryId) {\n                return {\n                    cell\n                };\n            }\n        }\n        return null;\n    }\n    /**\n     * Handle `contextmenu` event.\n     */\n    _evtContextMenuCapture(event) {\n        var _a;\n        // Allow the event to propagate un-modified if the user\n        // is holding the shift-key (and probably requesting\n        // the native context menu).\n        if (event.shiftKey) {\n            return;\n        }\n        const [target, index] = this._findEventTargetAndCell(event);\n        const widget = this.widgets[index];\n        if (widget && ((_a = widget.editorWidget) === null || _a === void 0 ? void 0 : _a.node.contains(target))) {\n            // Prevent CodeMirror from focusing the editor.\n            // TODO: find an editor-agnostic solution.\n            event.preventDefault();\n        }\n    }\n    /**\n     * Handle `mousedown` event in the capture phase for the widget.\n     */\n    _evtMouseDownCapture(event) {\n        var _a;\n        const { button, shiftKey } = event;\n        const [target, index] = this._findEventTargetAndCell(event);\n        const widget = this.widgets[index];\n        // On OS X, the context menu may be triggered with ctrl-left-click. In\n        // Firefox, ctrl-left-click gives an event with button 2, but in Chrome,\n        // ctrl-left-click gives an event with button 0 with the ctrl modifier.\n        if (button === 2 &&\n            !shiftKey &&\n            widget &&\n            ((_a = widget.editorWidget) === null || _a === void 0 ? void 0 : _a.node.contains(target))) {\n            this.mode = 'command';\n            // Prevent CodeMirror from focusing the editor.\n            // TODO: find an editor-agnostic solution.\n            event.preventDefault();\n        }\n    }\n    /**\n     * Handle `mousedown` events for the widget.\n     */\n    _evtMouseDown(event) {\n        var _a, _b, _c;\n        const { button, shiftKey } = event;\n        // We only handle main or secondary button actions.\n        if (!(button === 0 || button === 2)) {\n            return;\n        }\n        // Shift right-click gives the browser default behavior.\n        if (shiftKey && button === 2) {\n            return;\n        }\n        const [target, index] = this._findEventTargetAndCell(event);\n        const widget = this.widgets[index];\n        let targetArea;\n        if (widget) {\n            if ((_a = widget.editorWidget) === null || _a === void 0 ? void 0 : _a.node.contains(target)) {\n                targetArea = 'input';\n            }\n            else if ((_b = widget.promptNode) === null || _b === void 0 ? void 0 : _b.contains(target)) {\n                targetArea = 'prompt';\n            }\n            else {\n                targetArea = 'cell';\n            }\n        }\n        else {\n            targetArea = 'notebook';\n        }\n        // Make sure we go to command mode if the click isn't in the cell editor If\n        // we do click in the cell editor, the editor handles the focus event to\n        // switch to edit mode.\n        if (targetArea !== 'input') {\n            this.mode = 'command';\n        }\n        if (targetArea === 'notebook') {\n            this.deselectAll();\n        }\n        else if (targetArea === 'prompt' || targetArea === 'cell') {\n            // We don't want to prevent the default selection behavior\n            // if there is currently text selected in an output.\n            const hasSelection = ((_c = window.getSelection()) !== null && _c !== void 0 ? _c : '').toString() !== '';\n            if (button === 0 &&\n                shiftKey &&\n                !hasSelection &&\n                !['INPUT', 'OPTION'].includes(target.tagName)) {\n                // Prevent browser selecting text in prompt or output\n                event.preventDefault();\n                // Shift-click - extend selection\n                try {\n                    this.extendContiguousSelectionTo(index);\n                }\n                catch (e) {\n                    console.error(e);\n                    this.deselectAll();\n                    return;\n                }\n                // Enter selecting mode\n                this._mouseMode = 'select';\n                document.addEventListener('mouseup', this, true);\n                document.addEventListener('mousemove', this, true);\n            }\n            else if (button === 0 && !shiftKey) {\n                // Prepare to start a drag if we are on the drag region.\n                if (targetArea === 'prompt') {\n                    // Prepare for a drag start\n                    this._dragData = {\n                        pressX: event.clientX,\n                        pressY: event.clientY,\n                        index: index\n                    };\n                    // Enter possible drag mode\n                    this._mouseMode = 'couldDrag';\n                    document.addEventListener('mouseup', this, true);\n                    document.addEventListener('mousemove', this, true);\n                    event.preventDefault();\n                }\n                if (!this.isSelectedOrActive(widget)) {\n                    this.deselectAll();\n                    this.activeCellIndex = index;\n                }\n            }\n            else if (button === 2) {\n                if (!this.isSelectedOrActive(widget)) {\n                    this.deselectAll();\n                    this.activeCellIndex = index;\n                }\n                event.preventDefault();\n            }\n        }\n        else if (targetArea === 'input') {\n            if (button === 2 && !this.isSelectedOrActive(widget)) {\n                this.deselectAll();\n                this.activeCellIndex = index;\n            }\n        }\n        // If we didn't set focus above, make sure we get focus now.\n        this._ensureFocus(true);\n    }\n    /**\n     * Handle the `'mouseup'` event on the document.\n     */\n    _evtDocumentMouseup(event) {\n        event.preventDefault();\n        event.stopPropagation();\n        // Remove the event listeners we put on the document\n        document.removeEventListener('mousemove', this, true);\n        document.removeEventListener('mouseup', this, true);\n        if (this._mouseMode === 'couldDrag') {\n            // We didn't end up dragging if we are here, so treat it as a click event.\n            const [, index] = this._findEventTargetAndCell(event);\n            this.deselectAll();\n            this.activeCellIndex = index;\n            // Focus notebook if active cell changes but does not have focus.\n            if (!this.activeCell.node.contains(document.activeElement)) {\n                this.node.focus();\n            }\n        }\n        this._mouseMode = null;\n    }\n    /**\n     * Handle the `'mousemove'` event for the widget.\n     */\n    _evtDocumentMousemove(event) {\n        event.preventDefault();\n        event.stopPropagation();\n        // If in select mode, update the selection\n        switch (this._mouseMode) {\n            case 'select': {\n                const target = event.target;\n                const index = this._findCell(target);\n                if (index !== -1) {\n                    this.extendContiguousSelectionTo(index);\n                }\n                break;\n            }\n            case 'couldDrag': {\n                // Check for a drag initialization.\n                const data = this._dragData;\n                const dx = Math.abs(event.clientX - data.pressX);\n                const dy = Math.abs(event.clientY - data.pressY);\n                if (dx >= DRAG_THRESHOLD || dy >= DRAG_THRESHOLD) {\n                    this._mouseMode = null;\n                    this._startDrag(data.index, event.clientX, event.clientY);\n                }\n                break;\n            }\n            default:\n                break;\n        }\n    }\n    /**\n     * Handle the `'lm-dragenter'` event for the widget.\n     */\n    _evtDragEnter(event) {\n        if (!event.mimeData.hasData(JUPYTER_CELL_MIME)) {\n            return;\n        }\n        event.preventDefault();\n        event.stopPropagation();\n        const target = event.target;\n        const index = this._findCell(target);\n        if (index === -1) {\n            return;\n        }\n        const widget = this.cellsArray[index];\n        widget.node.classList.add(DROP_TARGET_CLASS);\n    }\n    /**\n     * Handle the `'lm-dragleave'` event for the widget.\n     */\n    _evtDragLeave(event) {\n        if (!event.mimeData.hasData(JUPYTER_CELL_MIME)) {\n            return;\n        }\n        event.preventDefault();\n        event.stopPropagation();\n        const elements = this.node.getElementsByClassName(DROP_TARGET_CLASS);\n        if (elements.length) {\n            elements[0].classList.remove(DROP_TARGET_CLASS);\n        }\n    }\n    /**\n     * Handle the `'lm-dragover'` event for the widget.\n     */\n    _evtDragOver(event) {\n        if (!event.mimeData.hasData(JUPYTER_CELL_MIME)) {\n            return;\n        }\n        event.preventDefault();\n        event.stopPropagation();\n        event.dropAction = event.proposedAction;\n        const elements = this.node.getElementsByClassName(DROP_TARGET_CLASS);\n        if (elements.length) {\n            elements[0].classList.remove(DROP_TARGET_CLASS);\n        }\n        const target = event.target;\n        const index = this._findCell(target);\n        if (index === -1) {\n            return;\n        }\n        const widget = this.cellsArray[index];\n        widget.node.classList.add(DROP_TARGET_CLASS);\n    }\n    /**\n     * Handle the `'lm-drop'` event for the widget.\n     */\n    _evtDrop(event) {\n        if (!event.mimeData.hasData(JUPYTER_CELL_MIME)) {\n            return;\n        }\n        event.preventDefault();\n        event.stopPropagation();\n        if (event.proposedAction === 'none') {\n            event.dropAction = 'none';\n            return;\n        }\n        let target = event.target;\n        while (target && target.parentElement) {\n            if (target.classList.contains(DROP_TARGET_CLASS)) {\n                target.classList.remove(DROP_TARGET_CLASS);\n                break;\n            }\n            target = target.parentElement;\n        }\n        // Model presence should be checked before calling event handlers\n        const model = this.model;\n        const source = event.source;\n        if (source === this) {\n            // Handle the case where we are moving cells within\n            // the same notebook.\n            event.dropAction = 'move';\n            const toMove = event.mimeData.getData('internal:cells');\n            // For collapsed markdown headings with hidden \"child\" cells, move all\n            // child cells as well as the markdown heading.\n            const cell = toMove[toMove.length - 1];\n            if (cell instanceof MarkdownCell && cell.headingCollapsed) {\n                const nextParent = NotebookActions.findNextParentHeading(cell, source);\n                if (nextParent > 0) {\n                    const index = findIndex(source.widgets, (possibleCell) => {\n                        return cell.model.id === possibleCell.model.id;\n                    });\n                    toMove.push(...source.widgets.slice(index + 1, nextParent));\n                }\n            }\n            // Compute the to/from indices for the move.\n            let fromIndex = ArrayExt.firstIndexOf(this.widgets, toMove[0]);\n            let toIndex = this._findCell(target);\n            // This check is needed for consistency with the view.\n            if (toIndex !== -1 && toIndex > fromIndex) {\n                toIndex -= 1;\n            }\n            else if (toIndex === -1) {\n                // If the drop is within the notebook but not on any cell,\n                // most often this means it is past the cell areas, so\n                // set it to move the cells to the end of the notebook.\n                toIndex = this.widgets.length - 1;\n            }\n            // Don't move if we are within the block of selected cells.\n            if (toIndex >= fromIndex && toIndex < fromIndex + toMove.length) {\n                return;\n            }\n            // Move the cells one by one\n            this.moveCell(fromIndex, toIndex, toMove.length);\n        }\n        else {\n            // Handle the case where we are copying cells between\n            // notebooks.\n            event.dropAction = 'copy';\n            // Find the target cell and insert the copied cells.\n            let index = this._findCell(target);\n            if (index === -1) {\n                index = this.widgets.length;\n            }\n            const start = index;\n            const values = event.mimeData.getData(JUPYTER_CELL_MIME);\n            // Insert the copies of the original cells.\n            // We preserve trust status of pasted cells by not modifying metadata.\n            model.sharedModel.insertCells(index, values);\n            // Select the inserted cells.\n            this.deselectAll();\n            this.activeCellIndex = start;\n            this.extendContiguousSelectionTo(index - 1);\n        }\n    }\n    /**\n     * Start a drag event.\n     */\n    _startDrag(index, clientX, clientY) {\n        var _a;\n        const cells = this.model.cells;\n        const selected = [];\n        const toMove = [];\n        let i = -1;\n        for (const widget of this.widgets) {\n            const cell = cells.get(++i);\n            if (this.isSelectedOrActive(widget)) {\n                widget.addClass(DROP_SOURCE_CLASS);\n                selected.push(cell.toJSON());\n                toMove.push(widget);\n            }\n        }\n        const activeCell = this.activeCell;\n        let dragImage = null;\n        let countString;\n        if ((activeCell === null || activeCell === void 0 ? void 0 : activeCell.model.type) === 'code') {\n            const executionCount = activeCell.model\n                .executionCount;\n            countString = ' ';\n            if (executionCount) {\n                countString = executionCount.toString();\n            }\n        }\n        else {\n            countString = '';\n        }\n        // Create the drag image.\n        dragImage = Private.createDragImage(selected.length, countString, (_a = activeCell === null || activeCell === void 0 ? void 0 : activeCell.model.sharedModel.getSource().split('\\n')[0].slice(0, 26)) !== null && _a !== void 0 ? _a : '');\n        // Set up the drag event.\n        this._drag = new Drag({\n            mimeData: new MimeData(),\n            dragImage,\n            supportedActions: 'copy-move',\n            proposedAction: 'copy',\n            source: this\n        });\n        this._drag.mimeData.setData(JUPYTER_CELL_MIME, selected);\n        // Add mimeData for the fully reified cell widgets, for the\n        // case where the target is in the same notebook and we\n        // can just move the cells.\n        this._drag.mimeData.setData('internal:cells', toMove);\n        // Add mimeData for the text content of the selected cells,\n        // allowing for drag/drop into plain text fields.\n        const textContent = toMove\n            .map(cell => cell.model.sharedModel.getSource())\n            .join('\\n');\n        this._drag.mimeData.setData('text/plain', textContent);\n        // Remove mousemove and mouseup listeners and start the drag.\n        document.removeEventListener('mousemove', this, true);\n        document.removeEventListener('mouseup', this, true);\n        this._mouseMode = null;\n        void this._drag.start(clientX, clientY).then(action => {\n            if (this.isDisposed) {\n                return;\n            }\n            this._drag = null;\n            for (const widget of toMove) {\n                widget.removeClass(DROP_SOURCE_CLASS);\n            }\n        });\n    }\n    /**\n     * Handle `focus` events for the widget.\n     */\n    _evtFocusIn(event) {\n        var _a;\n        const target = event.target;\n        const index = this._findCell(target);\n        if (index !== -1) {\n            const widget = this.widgets[index];\n            // If the editor itself does not have focus, ensure command mode.\n            if (widget.editorWidget && !widget.editorWidget.node.contains(target)) {\n                this.mode = 'command';\n            }\n            this.activeCellIndex = index;\n            // If the editor has focus, ensure edit mode.\n            const node = (_a = widget.editorWidget) === null || _a === void 0 ? void 0 : _a.node;\n            if (node === null || node === void 0 ? void 0 : node.contains(target)) {\n                this.mode = 'edit';\n            }\n            this.activeCellIndex = index;\n        }\n        else {\n            // No cell has focus, ensure command mode.\n            this.mode = 'command';\n        }\n    }\n    /**\n     * Handle `focusout` events for the notebook.\n     */\n    _evtFocusOut(event) {\n        var _a;\n        const relatedTarget = event.relatedTarget;\n        // Bail if the window is losing focus, to preserve edit mode. This test\n        // assumes that we explicitly focus things rather than calling blur()\n        if (!relatedTarget) {\n            return;\n        }\n        // Bail if the item gaining focus is another cell,\n        // and we should not be entering command mode.\n        const index = this._findCell(relatedTarget);\n        if (index !== -1) {\n            const widget = this.widgets[index];\n            if ((_a = widget.editorWidget) === null || _a === void 0 ? void 0 : _a.node.contains(relatedTarget)) {\n                return;\n            }\n        }\n        // Otherwise enter command mode if not already.\n        if (this.mode !== 'command') {\n            this.mode = 'command';\n            // Switching to command mode currently focuses the notebook element, so\n            // refocus the relatedTarget so the focus actually switches as intended.\n            if (relatedTarget) {\n                relatedTarget.focus();\n            }\n        }\n    }\n    /**\n     * Handle `dblclick` events for the widget.\n     */\n    _evtDblClick(event) {\n        const model = this.model;\n        if (!model) {\n            return;\n        }\n        this.deselectAll();\n        const [target, index] = this._findEventTargetAndCell(event);\n        if (event.target.classList.contains(HEADING_COLLAPSER_CLASS)) {\n            return;\n        }\n        if (index === -1) {\n            return;\n        }\n        this.activeCellIndex = index;\n        if (model.cells.get(index).type === 'markdown') {\n            const widget = this.widgets[index];\n            widget.rendered = false;\n        }\n        else if (target.localName === 'img') {\n            target.classList.toggle(UNCONFINED_CLASS);\n        }\n    }\n    /**\n     * Remove selections from inactive cells to avoid\n     * spurious cursors.\n     */\n    _trimSelections() {\n        for (let i = 0; i < this.widgets.length; i++) {\n            if (i !== this._activeCellIndex) {\n                const cell = this.widgets[i];\n                if (!cell.model.isDisposed && cell.editor) {\n                    cell.model.selections.delete(cell.editor.uuid);\n                }\n            }\n        }\n    }\n    _updateSelectedCells() {\n        this._selectedCells = this.widgets.filter(cell => this.isSelectedOrActive(cell));\n    }\n}\n/**\n * The namespace for the `Notebook` class statics.\n */\n(function (Notebook) {\n    /**\n     * The default implementation of a notebook content factory..\n     *\n     * #### Notes\n     * Override methods on this class to customize the default notebook factory\n     * methods that create notebook content.\n     */\n    class ContentFactory extends StaticNotebook.ContentFactory {\n    }\n    Notebook.ContentFactory = ContentFactory;\n})(Notebook || (Notebook = {}));\n/**\n * A namespace for private data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * An attached property for the selected state of a cell.\n     */\n    Private.selectedProperty = new AttachedProperty({\n        name: 'selected',\n        create: () => false\n    });\n    /**\n     * A custom panel layout for the notebook.\n     */\n    class NotebookPanelLayout extends PanelLayout {\n        /**\n         * A message handler invoked on an `'update-request'` message.\n         *\n         * #### Notes\n         * This is a reimplementation of the base class method,\n         * and is a no-op.\n         */\n        onUpdateRequest(msg) {\n            // This is a no-op.\n        }\n    }\n    Private.NotebookPanelLayout = NotebookPanelLayout;\n    /**\n     * Create a cell drag image.\n     */\n    function createDragImage(count, promptNumber, cellContent) {\n        if (count > 1) {\n            if (promptNumber !== '') {\n                return VirtualDOM.realize(h.div(h.div({ className: DRAG_IMAGE_CLASS }, h.span({ className: CELL_DRAG_PROMPT_CLASS }, '[' + promptNumber + ']:'), h.span({ className: CELL_DRAG_CONTENT_CLASS }, cellContent)), h.div({ className: CELL_DRAG_MULTIPLE_BACK }, '')));\n            }\n            else {\n                return VirtualDOM.realize(h.div(h.div({ className: DRAG_IMAGE_CLASS }, h.span({ className: CELL_DRAG_PROMPT_CLASS }), h.span({ className: CELL_DRAG_CONTENT_CLASS }, cellContent)), h.div({ className: CELL_DRAG_MULTIPLE_BACK }, '')));\n            }\n        }\n        else {\n            if (promptNumber !== '') {\n                return VirtualDOM.realize(h.div(h.div({ className: `${DRAG_IMAGE_CLASS} ${SINGLE_DRAG_IMAGE_CLASS}` }, h.span({ className: CELL_DRAG_PROMPT_CLASS }, '[' + promptNumber + ']:'), h.span({ className: CELL_DRAG_CONTENT_CLASS }, cellContent))));\n            }\n            else {\n                return VirtualDOM.realize(h.div(h.div({ className: `${DRAG_IMAGE_CLASS} ${SINGLE_DRAG_IMAGE_CLASS}` }, h.span({ className: CELL_DRAG_PROMPT_CLASS }), h.span({ className: CELL_DRAG_CONTENT_CLASS }, cellContent))));\n            }\n        }\n    }\n    Private.createDragImage = createDragImage;\n})(Private || (Private = {}));\n//# sourceMappingURL=widget.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Dialog, Printing, showDialog } from '@jupyterlab/apputils';\nimport { isMarkdownCellModel } from '@jupyterlab/cells';\nimport { PageConfig } from '@jupyterlab/coreutils';\nimport { DocumentWidget } from '@jupyterlab/docregistry';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { Token } from '@lumino/coreutils';\nimport { Notebook } from './widget';\n/**\n * The class name added to notebook panels.\n */\nconst NOTEBOOK_PANEL_CLASS = 'jp-NotebookPanel';\nconst NOTEBOOK_PANEL_TOOLBAR_CLASS = 'jp-NotebookPanel-toolbar';\nconst NOTEBOOK_PANEL_NOTEBOOK_CLASS = 'jp-NotebookPanel-notebook';\n/**\n * A widget that hosts a notebook toolbar and content area.\n *\n * #### Notes\n * The widget keeps the document metadata in sync with the current\n * kernel on the context.\n */\nexport class NotebookPanel extends DocumentWidget {\n    /**\n     * Construct a new notebook panel.\n     */\n    constructor(options) {\n        super(options);\n        /**\n         * Whether we are currently in a series of autorestarts we have already\n         * notified the user about.\n         */\n        this._autorestarting = false;\n        this.translator = options.translator || nullTranslator;\n        this._trans = this.translator.load('jupyterlab');\n        // Set up CSS classes\n        this.addClass(NOTEBOOK_PANEL_CLASS);\n        this.toolbar.addClass(NOTEBOOK_PANEL_TOOLBAR_CLASS);\n        this.content.addClass(NOTEBOOK_PANEL_NOTEBOOK_CLASS);\n        // Set up things related to the context\n        this.content.model = this.context.model;\n        this.context.sessionContext.kernelChanged.connect(this._onKernelChanged, this);\n        this.context.sessionContext.statusChanged.connect(this._onSessionStatusChanged, this);\n        // this.content.fullyRendered.connect(this._onFullyRendered, this);\n        this.context.saveState.connect(this._onSave, this);\n        void this.revealed.then(() => {\n            if (this.isDisposed) {\n                // this widget has already been disposed, bail\n                return;\n            }\n            // Set the document edit mode on initial open if it looks like a new document.\n            if (this.content.widgets.length === 1) {\n                const cellModel = this.content.widgets[0].model;\n                if (cellModel.type === 'code' &&\n                    cellModel.sharedModel.getSource() === '') {\n                    this.content.mode = 'edit';\n                }\n            }\n        });\n    }\n    /**\n     * Handle a change to the document registry save state.\n     *\n     * @param sender The document registry context\n     * @param state The document registry save state\n     */\n    _onSave(sender, state) {\n        if (state === 'started' && this.model) {\n            // Find markdown cells\n            for (const cell of this.model.cells) {\n                if (isMarkdownCellModel(cell)) {\n                    for (const key of cell.attachments.keys) {\n                        if (!cell.sharedModel.getSource().includes(key)) {\n                            cell.attachments.remove(key);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * The session context used by the panel.\n     */\n    get sessionContext() {\n        return this.context.sessionContext;\n    }\n    /**\n     * The model for the widget.\n     */\n    get model() {\n        return this.content.model;\n    }\n    /**\n     * Update the options for the current notebook panel.\n     *\n     * @param config new options to set\n     */\n    setConfig(config) {\n        this.content.editorConfig = config.editorConfig;\n        this.content.notebookConfig = config.notebookConfig;\n        // Update kernel shutdown behavior\n        const kernelPreference = this.context.sessionContext.kernelPreference;\n        this.context.sessionContext.kernelPreference = {\n            ...kernelPreference,\n            shutdownOnDispose: config.kernelShutdown,\n            autoStartDefault: config.autoStartDefault\n        };\n    }\n    /**\n     * Set URI fragment identifier.\n     */\n    setFragment(fragment) {\n        void this.context.ready.then(() => {\n            void this.content.setFragment(fragment);\n        });\n    }\n    /**\n     * Dispose of the resources used by the widget.\n     */\n    dispose() {\n        this.content.dispose();\n        super.dispose();\n    }\n    /**\n     * Prints the notebook by converting to HTML with nbconvert.\n     */\n    [Printing.symbol]() {\n        return async () => {\n            // Save before generating HTML\n            if (this.context.model.dirty && !this.context.model.readOnly) {\n                await this.context.save();\n            }\n            await Printing.printURL(PageConfig.getNBConvertURL({\n                format: 'html',\n                download: false,\n                path: this.context.path\n            }));\n        };\n    }\n    /**\n     * A message handler invoked on a 'before-hide' message.\n     */\n    onBeforeHide(msg) {\n        super.onBeforeHide(msg);\n        // Inform the windowed list that the notebook is gonna be hidden\n        this.content.isParentHidden = true;\n    }\n    /**\n     * A message handler invoked on a 'before-show' message.\n     */\n    onBeforeShow(msg) {\n        // Inform the windowed list that the notebook is gonna be shown\n        // Use onBeforeShow instead of onAfterShow to take into account\n        // resizing (like sidebars got expanded before switching to the notebook tab)\n        this.content.isParentHidden = false;\n        super.onBeforeShow(msg);\n    }\n    /**\n     * Handle a change in the kernel by updating the document metadata.\n     */\n    _onKernelChanged(sender, args) {\n        if (!this.model || !args.newValue) {\n            return;\n        }\n        const { newValue } = args;\n        void newValue.info.then(info => {\n            var _a;\n            if (this.model &&\n                ((_a = this.context.sessionContext.session) === null || _a === void 0 ? void 0 : _a.kernel) === newValue) {\n                this._updateLanguage(info.language_info);\n            }\n        });\n        void this._updateSpec(newValue);\n    }\n    _onSessionStatusChanged(sender, status) {\n        var _a;\n        // If the status is autorestarting, and we aren't already in a series of\n        // autorestarts, show the dialog.\n        if (status === 'autorestarting' && !this._autorestarting) {\n            // The kernel died and the server is restarting it. We notify the user so\n            // they know why their kernel state is gone.\n            void showDialog({\n                title: this._trans.__('Kernel Restarting'),\n                body: this._trans.__('The kernel for %1 appears to have died. It will restart automatically.', (_a = this.sessionContext.session) === null || _a === void 0 ? void 0 : _a.path),\n                buttons: [Dialog.okButton({ label: this._trans.__('Ok') })]\n            });\n            this._autorestarting = true;\n        }\n        else if (status === 'restarting') {\n            // Another autorestart attempt will first change the status to\n            // restarting, then to autorestarting again, so we don't reset the\n            // autorestarting status if the status is 'restarting'.\n            /* no-op */\n        }\n        else {\n            this._autorestarting = false;\n        }\n    }\n    /**\n     * Update the kernel language.\n     */\n    _updateLanguage(language) {\n        this.model.setMetadata('language_info', language);\n    }\n    /**\n     * Update the kernel spec.\n     */\n    async _updateSpec(kernel) {\n        const spec = await kernel.spec;\n        if (this.isDisposed) {\n            return;\n        }\n        this.model.setMetadata('kernelspec', {\n            name: kernel.name,\n            display_name: spec === null || spec === void 0 ? void 0 : spec.display_name,\n            language: spec === null || spec === void 0 ? void 0 : spec.language\n        });\n    }\n}\n/**\n * A namespace for `NotebookPanel` statics.\n */\n(function (NotebookPanel) {\n    /**\n     * The default implementation of an `IContentFactory`.\n     */\n    class ContentFactory extends Notebook.ContentFactory {\n        /**\n         * Create a new content area for the panel.\n         */\n        createNotebook(options) {\n            return new Notebook(options);\n        }\n    }\n    NotebookPanel.ContentFactory = ContentFactory;\n    /**\n     * The notebook renderer token.\n     */\n    NotebookPanel.IContentFactory = new Token('@jupyterlab/notebook:IContentFactory', `A factory object that creates new notebooks.\n    Use this if you want to create and host notebooks in your own UI elements.`);\n})(NotebookPanel || (NotebookPanel = {}));\n//# sourceMappingURL=panel.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Cell, MarkdownCell } from '@jupyterlab/cells';\nimport { TableOfContentsFactory, TableOfContentsModel, TableOfContentsUtils } from '@jupyterlab/toc';\nimport { NotebookActions } from './actions';\n/**\n * Cell running status\n */\nexport var RunningStatus;\n(function (RunningStatus) {\n    /**\n     * Cell is idle\n     */\n    RunningStatus[RunningStatus[\"Idle\"] = -1] = \"Idle\";\n    /**\n     * Cell execution is scheduled\n     */\n    RunningStatus[RunningStatus[\"Scheduled\"] = 0] = \"Scheduled\";\n    /**\n     * Cell is running\n     */\n    RunningStatus[RunningStatus[\"Running\"] = 1] = \"Running\";\n})(RunningStatus || (RunningStatus = {}));\n/**\n * Table of content model for Notebook files.\n */\nexport class NotebookToCModel extends TableOfContentsModel {\n    /**\n     * Constructor\n     *\n     * @param widget The widget to search in\n     * @param parser Markdown parser\n     * @param sanitizer Sanitizer\n     * @param configuration Default model configuration\n     */\n    constructor(widget, parser, sanitizer, configuration) {\n        super(widget, configuration);\n        this.parser = parser;\n        this.sanitizer = sanitizer;\n        /**\n         * Mapping between configuration options and notebook metadata.\n         *\n         * If it starts with `!`, the boolean value of the configuration option is\n         * opposite to the one stored in metadata.\n         * If it contains `/`, the metadata data is nested.\n         */\n        this.configMetadataMap = {\n            numberHeaders: ['toc-autonumbering', 'toc/number_sections'],\n            numberingH1: ['!toc/skip_h1_title'],\n            baseNumbering: ['toc/base_numbering']\n        };\n        this._runningCells = new Array();\n        this._cellToHeadingIndex = new WeakMap();\n        void widget.context.ready.then(() => {\n            // Load configuration from metadata\n            this.setConfiguration({});\n        });\n        this.widget.context.model.metadataChanged.connect(this.onMetadataChanged, this);\n        this.widget.content.activeCellChanged.connect(this.onActiveCellChanged, this);\n        NotebookActions.executionScheduled.connect(this.onExecutionScheduled, this);\n        NotebookActions.executed.connect(this.onExecuted, this);\n        this.headingsChanged.connect(this.onHeadingsChanged, this);\n    }\n    /**\n     * Type of document supported by the model.\n     *\n     * #### Notes\n     * A `data-document-type` attribute with this value will be set\n     * on the tree view `.jp-TableOfContents-content[data-document-type=\"...\"]`\n     */\n    get documentType() {\n        return 'notebook';\n    }\n    /**\n     * Whether the model gets updated even if the table of contents panel\n     * is hidden or not.\n     */\n    get isAlwaysActive() {\n        return true;\n    }\n    /**\n     * List of configuration options supported by the model.\n     */\n    get supportedOptions() {\n        return [\n            'baseNumbering',\n            'maximalDepth',\n            'numberingH1',\n            'numberHeaders',\n            'includeOutput',\n            'syncCollapseState'\n        ];\n    }\n    /**\n     * Get the headings of a given cell.\n     *\n     * @param cell Cell\n     * @returns The associated headings\n     */\n    getCellHeadings(cell) {\n        const headings = new Array();\n        let headingIndex = this._cellToHeadingIndex.get(cell);\n        if (headingIndex !== undefined) {\n            const candidate = this.headings[headingIndex];\n            headings.push(candidate);\n            while (this.headings[headingIndex - 1] &&\n                this.headings[headingIndex - 1].cellRef === candidate.cellRef) {\n                headingIndex--;\n                headings.unshift(this.headings[headingIndex]);\n            }\n        }\n        return headings;\n    }\n    /**\n     * Dispose the object\n     */\n    dispose() {\n        var _a, _b, _c;\n        if (this.isDisposed) {\n            return;\n        }\n        this.headingsChanged.disconnect(this.onHeadingsChanged, this);\n        (_b = (_a = this.widget.context) === null || _a === void 0 ? void 0 : _a.model) === null || _b === void 0 ? void 0 : _b.metadataChanged.disconnect(this.onMetadataChanged, this);\n        (_c = this.widget.content) === null || _c === void 0 ? void 0 : _c.activeCellChanged.disconnect(this.onActiveCellChanged, this);\n        NotebookActions.executionScheduled.disconnect(this.onExecutionScheduled, this);\n        NotebookActions.executed.disconnect(this.onExecuted, this);\n        this._runningCells.length = 0;\n        super.dispose();\n    }\n    /**\n     * Model configuration setter.\n     *\n     * @param c New configuration\n     */\n    setConfiguration(c) {\n        // Ensure configuration update\n        const metadataConfig = this.loadConfigurationFromMetadata();\n        super.setConfiguration({ ...this.configuration, ...metadataConfig, ...c });\n    }\n    /**\n     * Callback on heading collapse.\n     *\n     * @param options.heading The heading to change state (all headings if not provided)\n     * @param options.collapsed The new collapsed status (toggle existing status if not provided)\n     */\n    toggleCollapse(options) {\n        super.toggleCollapse(options);\n        this.updateRunningStatus(this.headings);\n    }\n    /**\n     * Produce the headings for a document.\n     *\n     * @returns The list of new headings or `null` if nothing needs to be updated.\n     */\n    getHeadings() {\n        const cells = this.widget.content.widgets;\n        const headings = [];\n        const documentLevels = new Array();\n        // Generate headings by iterating through all notebook cells...\n        for (let i = 0; i < cells.length; i++) {\n            const cell = cells[i];\n            const model = cell.model;\n            switch (model.type) {\n                case 'code': {\n                    // Collapsing cells is incompatible with output headings\n                    if (!this.configuration.syncCollapseState &&\n                        this.configuration.includeOutput) {\n                        headings.push(...TableOfContentsUtils.filterHeadings(cell.headings, this.configuration, documentLevels).map(heading => {\n                            return {\n                                ...heading,\n                                cellRef: cell,\n                                collapsed: false,\n                                isRunning: RunningStatus.Idle\n                            };\n                        }));\n                    }\n                    break;\n                }\n                case 'markdown': {\n                    const cellHeadings = TableOfContentsUtils.filterHeadings(cell.headings, this.configuration, documentLevels).map((heading, index) => {\n                        return {\n                            ...heading,\n                            cellRef: cell,\n                            collapsed: false,\n                            isRunning: RunningStatus.Idle\n                        };\n                    });\n                    // If there are multiple headings, only collapse the highest heading (i.e. minimal level)\n                    // consistent with the cell.headingInfo\n                    if (this.configuration.syncCollapseState &&\n                        cell.headingCollapsed) {\n                        const minLevel = Math.min(...cellHeadings.map(h => h.level));\n                        const minHeading = cellHeadings.find(h => h.level === minLevel);\n                        minHeading.collapsed = cell.headingCollapsed;\n                    }\n                    headings.push(...cellHeadings);\n                    break;\n                }\n            }\n            if (headings.length > 0) {\n                this._cellToHeadingIndex.set(cell, headings.length - 1);\n            }\n        }\n        this.updateRunningStatus(headings);\n        return Promise.resolve(headings);\n    }\n    /**\n     * Read table of content configuration from notebook metadata.\n     *\n     * @returns ToC configuration from metadata\n     */\n    loadConfigurationFromMetadata() {\n        const nbModel = this.widget.content.model;\n        const newConfig = {};\n        if (nbModel) {\n            for (const option in this.configMetadataMap) {\n                const keys = this.configMetadataMap[option];\n                for (const k of keys) {\n                    let key = k;\n                    const negate = key[0] === '!';\n                    if (negate) {\n                        key = key.slice(1);\n                    }\n                    const keyPath = key.split('/');\n                    let value = nbModel.getMetadata(keyPath[0]);\n                    for (let p = 1; p < keyPath.length; p++) {\n                        value = (value !== null && value !== void 0 ? value : {})[keyPath[p]];\n                    }\n                    if (value !== undefined) {\n                        if (typeof value === 'boolean' && negate) {\n                            value = !value;\n                        }\n                        newConfig[option] = value;\n                    }\n                }\n            }\n        }\n        return newConfig;\n    }\n    onActiveCellChanged(notebook, cell) {\n        // Highlight the first title as active (if multiple titles are in the same cell)\n        const activeHeading = this.getCellHeadings(cell)[0];\n        this.setActiveHeading(activeHeading !== null && activeHeading !== void 0 ? activeHeading : null, false);\n    }\n    onHeadingsChanged() {\n        if (this.widget.content.activeCell) {\n            this.onActiveCellChanged(this.widget.content, this.widget.content.activeCell);\n        }\n    }\n    onExecuted(_, args) {\n        this._runningCells.forEach((cell, index) => {\n            if (cell === args.cell) {\n                this._runningCells.splice(index, 1);\n                const headingIndex = this._cellToHeadingIndex.get(cell);\n                if (headingIndex !== undefined) {\n                    const heading = this.headings[headingIndex];\n                    heading.isRunning = RunningStatus.Idle;\n                }\n            }\n        });\n        this.updateRunningStatus(this.headings);\n        this.stateChanged.emit();\n    }\n    onExecutionScheduled(_, args) {\n        if (!this._runningCells.includes(args.cell)) {\n            this._runningCells.push(args.cell);\n        }\n        this.updateRunningStatus(this.headings);\n        this.stateChanged.emit();\n    }\n    onMetadataChanged() {\n        this.setConfiguration({});\n    }\n    updateRunningStatus(headings) {\n        // Update isRunning\n        this._runningCells.forEach((cell, index) => {\n            const headingIndex = this._cellToHeadingIndex.get(cell);\n            if (headingIndex !== undefined) {\n                const heading = this.headings[headingIndex];\n                heading.isRunning = Math.max(index > 0 ? RunningStatus.Scheduled : RunningStatus.Running, heading.isRunning);\n            }\n        });\n        let globalIndex = 0;\n        while (globalIndex < headings.length) {\n            const heading = headings[globalIndex];\n            globalIndex++;\n            if (heading.collapsed) {\n                const maxIsRunning = Math.max(heading.isRunning, getMaxIsRunning(headings, heading.level));\n                heading.dataset = {\n                    ...heading.dataset,\n                    'data-running': maxIsRunning.toString()\n                };\n            }\n            else {\n                heading.dataset = {\n                    ...heading.dataset,\n                    'data-running': heading.isRunning.toString()\n                };\n            }\n        }\n        function getMaxIsRunning(headings, collapsedLevel) {\n            let maxIsRunning = RunningStatus.Idle;\n            while (globalIndex < headings.length) {\n                const heading = headings[globalIndex];\n                heading.dataset = {\n                    ...heading.dataset,\n                    'data-running': heading.isRunning.toString()\n                };\n                if (heading.level > collapsedLevel) {\n                    globalIndex++;\n                    maxIsRunning = Math.max(heading.isRunning, maxIsRunning);\n                    if (heading.collapsed) {\n                        maxIsRunning = Math.max(maxIsRunning, getMaxIsRunning(headings, heading.level));\n                        heading.dataset = {\n                            ...heading.dataset,\n                            'data-running': maxIsRunning.toString()\n                        };\n                    }\n                }\n                else {\n                    break;\n                }\n            }\n            return maxIsRunning;\n        }\n    }\n}\n/**\n * Table of content model factory for Notebook files.\n */\nexport class NotebookToCFactory extends TableOfContentsFactory {\n    /**\n     * Constructor\n     *\n     * @param tracker Widget tracker\n     * @param parser Markdown parser\n     * @param sanitizer Sanitizer\n     */\n    constructor(tracker, parser, sanitizer) {\n        super(tracker);\n        this.parser = parser;\n        this.sanitizer = sanitizer;\n    }\n    /**\n     * Create a new table of contents model for the widget\n     *\n     * @param widget - widget\n     * @param configuration - Table of contents configuration\n     * @returns The table of contents model\n     */\n    _createNew(widget, configuration) {\n        const model = new NotebookToCModel(widget, this.parser, this.sanitizer, configuration);\n        // Connect model signals to notebook panel\n        let headingToElement = new WeakMap();\n        const onActiveHeadingChanged = (model, heading) => {\n            if (heading) {\n                const onCellInViewport = (cell) => {\n                    if (!cell.inViewport) {\n                        // Bail early\n                        return;\n                    }\n                    const el = headingToElement.get(heading);\n                    if (el) {\n                        const widgetBox = widget.content.node.getBoundingClientRect();\n                        const elementBox = el.getBoundingClientRect();\n                        if (elementBox.top > widgetBox.bottom ||\n                            elementBox.bottom < widgetBox.top) {\n                            el.scrollIntoView({ block: 'center' });\n                        }\n                    }\n                };\n                const cell = heading.cellRef;\n                const cells = widget.content.widgets;\n                const idx = cells.indexOf(cell);\n                widget.content.activeCellIndex = idx;\n                if (cell.inViewport) {\n                    onCellInViewport(cell);\n                }\n                else {\n                    widget.content\n                        .scrollToItem(idx)\n                        .then(() => {\n                        onCellInViewport(cell);\n                    })\n                        .catch(reason => {\n                        console.error('Fail to scroll to cell to display the required heading.');\n                    });\n                }\n            }\n        };\n        const findHeadingElement = (cell) => {\n            model.getCellHeadings(cell).forEach(async (heading) => {\n                var _a, _b;\n                const elementId = await getIdForHeading(heading, this.parser);\n                const selector = elementId\n                    ? `h${heading.level}[id=\"${elementId}\"]`\n                    : `h${heading.level}`;\n                if (heading.outputIndex !== undefined) {\n                    // Code cell\n                    headingToElement.set(heading, TableOfContentsUtils.addPrefix(heading.cellRef.outputArea.widgets[heading.outputIndex].node, selector, (_a = heading.prefix) !== null && _a !== void 0 ? _a : ''));\n                }\n                else {\n                    headingToElement.set(heading, TableOfContentsUtils.addPrefix(heading.cellRef.node, selector, (_b = heading.prefix) !== null && _b !== void 0 ? _b : ''));\n                }\n            });\n        };\n        const onHeadingsChanged = (model) => {\n            if (!this.parser) {\n                return;\n            }\n            // Clear all numbering items\n            TableOfContentsUtils.clearNumbering(widget.content.node);\n            // Create a new mapping\n            headingToElement = new WeakMap();\n            widget.content.widgets.forEach(cell => {\n                findHeadingElement(cell);\n            });\n        };\n        const onHeadingCollapsed = (_, heading) => {\n            var _a, _b, _c, _d;\n            if (model.configuration.syncCollapseState) {\n                if (heading !== null) {\n                    const cell = heading.cellRef;\n                    if (cell.headingCollapsed !== ((_a = heading.collapsed) !== null && _a !== void 0 ? _a : false)) {\n                        cell.headingCollapsed = (_b = heading.collapsed) !== null && _b !== void 0 ? _b : false;\n                    }\n                }\n                else {\n                    const collapseState = (_d = (_c = model.headings[0]) === null || _c === void 0 ? void 0 : _c.collapsed) !== null && _d !== void 0 ? _d : false;\n                    widget.content.widgets.forEach(cell => {\n                        if (cell instanceof MarkdownCell) {\n                            if (cell.headingInfo.level >= 0) {\n                                cell.headingCollapsed = collapseState;\n                            }\n                        }\n                    });\n                }\n            }\n        };\n        const onCellCollapsed = (_, cell) => {\n            if (model.configuration.syncCollapseState) {\n                const h = model.getCellHeadings(cell)[0];\n                if (h) {\n                    model.toggleCollapse({\n                        heading: h,\n                        collapsed: cell.headingCollapsed\n                    });\n                }\n            }\n        };\n        const onCellInViewportChanged = (_, cell) => {\n            if (cell.inViewport) {\n                findHeadingElement(cell);\n            }\n            else {\n                // Needed to remove prefix in cell outputs\n                TableOfContentsUtils.clearNumbering(cell.node);\n            }\n        };\n        void widget.context.ready.then(() => {\n            onHeadingsChanged(model);\n            model.activeHeadingChanged.connect(onActiveHeadingChanged);\n            model.headingsChanged.connect(onHeadingsChanged);\n            model.collapseChanged.connect(onHeadingCollapsed);\n            widget.content.cellCollapsed.connect(onCellCollapsed);\n            widget.content.cellInViewportChanged.connect(onCellInViewportChanged);\n            widget.disposed.connect(() => {\n                model.activeHeadingChanged.disconnect(onActiveHeadingChanged);\n                model.headingsChanged.disconnect(onHeadingsChanged);\n                model.collapseChanged.disconnect(onHeadingCollapsed);\n                widget.content.cellCollapsed.disconnect(onCellCollapsed);\n                widget.content.cellInViewportChanged.disconnect(onCellInViewportChanged);\n            });\n        });\n        return model;\n    }\n}\n/**\n * Get the element id for an heading\n * @param heading Heading\n * @param parser The markdownparser\n * @returns The element id\n */\nexport async function getIdForHeading(heading, parser) {\n    let elementId = null;\n    if (heading.type === Cell.HeadingType.Markdown) {\n        elementId = await TableOfContentsUtils.Markdown.getHeadingId(parser, \n        // Type from TableOfContentsUtils.Markdown.IMarkdownHeading\n        heading.raw, heading.level);\n    }\n    else if (heading.type === Cell.HeadingType.HTML) {\n        // Type from TableOfContentsUtils.IHTMLHeading\n        elementId = heading.id;\n    }\n    return elementId;\n}\n//# sourceMappingURL=toc.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Dialog, showDialog } from '@jupyterlab/apputils';\nimport { CodeCell, createCellSearchProvider } from '@jupyterlab/cells';\nimport { SearchProvider } from '@jupyterlab/documentsearch';\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { ArrayExt } from '@lumino/algorithm';\nimport { NotebookPanel } from './panel';\n/**\n * Notebook document search provider\n */\nexport class NotebookSearchProvider extends SearchProvider {\n    /**\n     * Constructor\n     *\n     * @param widget The widget to search in\n     * @param translator Application translator\n     */\n    constructor(widget, translator = nullTranslator) {\n        super(widget);\n        this.translator = translator;\n        this._textSelection = null;\n        this._currentProviderIndex = null;\n        this._delayedActiveCellChangeHandler = null;\n        this._onSelection = false;\n        this._selectedCells = 1;\n        this._selectedLines = 0;\n        this._query = null;\n        this._searchProviders = [];\n        this._editorSelectionsObservable = null;\n        this._selectionSearchMode = 'cells';\n        this._selectionLock = false;\n        this._handleHighlightsAfterActiveCellChange =\n            this._handleHighlightsAfterActiveCellChange.bind(this);\n        this.widget.model.cells.changed.connect(this._onCellsChanged, this);\n        this.widget.content.activeCellChanged.connect(this._onActiveCellChanged, this);\n        this.widget.content.selectionChanged.connect(this._onCellSelectionChanged, this);\n        this.widget.content.stateChanged.connect(this._onNotebookStateChanged, this);\n        this._observeActiveCell();\n        this._filtersChanged.connect(this._setEnginesSelectionSearchMode, this);\n    }\n    _onNotebookStateChanged(_, args) {\n        if (args.name === 'mode') {\n            // Delay the update to ensure that `document.activeElement` settled.\n            window.setTimeout(() => {\n                var _a;\n                if (args.newValue === 'command' &&\n                    ((_a = document.activeElement) === null || _a === void 0 ? void 0 : _a.closest('.jp-DocumentSearch-overlay'))) {\n                    // Do not request updating mode when user switched focus to search overlay.\n                    return;\n                }\n                this._updateSelectionMode();\n                this._filtersChanged.emit();\n            }, 0);\n        }\n    }\n    /**\n     * Report whether or not this provider has the ability to search on the given object\n     *\n     * @param domain Widget to test\n     * @returns Search ability\n     */\n    static isApplicable(domain) {\n        // check to see if the CMSearchProvider can search on the\n        // first cell, false indicates another editor is present\n        return domain instanceof NotebookPanel;\n    }\n    /**\n     * Instantiate a search provider for the notebook panel.\n     *\n     * #### Notes\n     * The widget provided is always checked using `isApplicable` before calling\n     * this factory.\n     *\n     * @param widget The widget to search on\n     * @param translator [optional] The translator object\n     *\n     * @returns The search provider on the notebook panel\n     */\n    static createNew(widget, translator) {\n        return new NotebookSearchProvider(widget, translator);\n    }\n    /**\n     * The current index of the selected match.\n     */\n    get currentMatchIndex() {\n        let agg = 0;\n        let found = false;\n        for (let idx = 0; idx < this._searchProviders.length; idx++) {\n            const provider = this._searchProviders[idx];\n            if (this._currentProviderIndex == idx) {\n                const localMatch = provider.currentMatchIndex;\n                if (localMatch === null) {\n                    return null;\n                }\n                agg += localMatch;\n                found = true;\n                break;\n            }\n            else {\n                agg += provider.matchesCount;\n            }\n        }\n        return found ? agg : null;\n    }\n    /**\n     * The number of matches.\n     */\n    get matchesCount() {\n        return this._searchProviders.reduce((sum, provider) => (sum += provider.matchesCount), 0);\n    }\n    /**\n     * Set to true if the widget under search is read-only, false\n     * if it is editable. Will be used to determine whether to show\n     * the replace option.\n     */\n    get isReadOnly() {\n        var _a, _b, _c;\n        return (_c = (_b = (_a = this.widget) === null || _a === void 0 ? void 0 : _a.content.model) === null || _b === void 0 ? void 0 : _b.readOnly) !== null && _c !== void 0 ? _c : false;\n    }\n    /**\n     * Support for options adjusting replacement behavior.\n     */\n    get replaceOptionsSupport() {\n        return {\n            preserveCase: true\n        };\n    }\n    /**\n     * Dispose of the resources held by the search provider.\n     *\n     * #### Notes\n     * If the object's `dispose` method is called more than once, all\n     * calls made after the first will be a no-op.\n     *\n     * #### Undefined Behavior\n     * It is undefined behavior to use any functionality of the object\n     * after it has been disposed unless otherwise explicitly noted.\n     */\n    dispose() {\n        var _a;\n        if (this.isDisposed) {\n            return;\n        }\n        this.widget.content.activeCellChanged.disconnect(this._onActiveCellChanged, this);\n        (_a = this.widget.model) === null || _a === void 0 ? void 0 : _a.cells.changed.disconnect(this._onCellsChanged, this);\n        this.widget.content.stateChanged.disconnect(this._onNotebookStateChanged, this);\n        this.widget.content.selectionChanged.disconnect(this._onCellSelectionChanged, this);\n        this._stopObservingLastCell();\n        super.dispose();\n        const index = this.widget.content.activeCellIndex;\n        this.endQuery()\n            .then(() => {\n            if (!this.widget.isDisposed) {\n                this.widget.content.activeCellIndex = index;\n            }\n        })\n            .catch(reason => {\n            console.error(`Fail to end search query in notebook:\\n${reason}`);\n        });\n    }\n    /**\n     * Get the filters for the given provider.\n     *\n     * @returns The filters.\n     */\n    getFilters() {\n        const trans = this.translator.load('jupyterlab');\n        return {\n            output: {\n                title: trans.__('Search Cell Outputs'),\n                description: trans.__('Search in the cell outputs.'),\n                default: false,\n                supportReplace: false\n            },\n            selection: {\n                title: this._selectionSearchMode === 'cells'\n                    ? trans._n('Search in %1 Selected Cell', 'Search in %1 Selected Cells', this._selectedCells)\n                    : trans._n('Search in %1 Selected Line', 'Search in %1 Selected Lines', this._selectedLines),\n                description: trans.__('Search only in the selected cells or text (depending on edit/command mode).'),\n                default: false,\n                supportReplace: true\n            }\n        };\n    }\n    /**\n     * Update the search in selection mode; it should only be called when user\n     * navigates the notebook (enters editing/command mode, changes selection)\n     * but not when the searchbox gets focused (switching the notebook to command\n     * mode) nor when search highlights a match (switching notebook to edit mode).\n     */\n    _updateSelectionMode() {\n        if (this._selectionLock) {\n            return;\n        }\n        this._selectionSearchMode =\n            this._selectedCells === 1 &&\n                this.widget.content.mode === 'edit' &&\n                this._selectedLines !== 0\n                ? 'text'\n                : 'cells';\n    }\n    /**\n     * Get an initial query value if applicable so that it can be entered\n     * into the search box as an initial query\n     *\n     * @returns Initial value used to populate the search box.\n     */\n    getInitialQuery() {\n        const activeCell = this.widget.content.activeCell;\n        const editor = activeCell === null || activeCell === void 0 ? void 0 : activeCell.editor;\n        if (!editor) {\n            return '';\n        }\n        const selection = editor.state.sliceDoc(editor.state.selection.main.from, editor.state.selection.main.to);\n        return selection;\n    }\n    /**\n     * Clear currently highlighted match.\n     */\n    async clearHighlight() {\n        this._selectionLock = true;\n        if (this._currentProviderIndex !== null &&\n            this._currentProviderIndex < this._searchProviders.length) {\n            await this._searchProviders[this._currentProviderIndex].clearHighlight();\n            this._currentProviderIndex = null;\n        }\n        this._selectionLock = false;\n    }\n    /**\n     * Highlight the next match.\n     *\n     * @param loop Whether to loop within the matches list.\n     *\n     * @returns The next match if available.\n     */\n    async highlightNext(loop = true, options) {\n        const match = await this._stepNext(false, loop, options);\n        return match !== null && match !== void 0 ? match : undefined;\n    }\n    /**\n     * Highlight the previous match.\n     *\n     * @param loop Whether to loop within the matches list.\n     *\n     * @returns The previous match if available.\n     */\n    async highlightPrevious(loop = true, options) {\n        const match = await this._stepNext(true, loop, options);\n        return match !== null && match !== void 0 ? match : undefined;\n    }\n    /**\n     * Search for a regular expression with optional filters.\n     *\n     * @param query A regular expression to test for\n     * @param filters Filter parameters to pass to provider\n     *\n     */\n    async startQuery(query, filters) {\n        if (!this.widget) {\n            return;\n        }\n        await this.endQuery();\n        let cells = this.widget.content.widgets;\n        this._query = query;\n        this._filters = {\n            output: false,\n            selection: false,\n            ...(filters !== null && filters !== void 0 ? filters : {})\n        };\n        this._onSelection = this._filters.selection;\n        const currentProviderIndex = this.widget.content.activeCellIndex;\n        // For each cell, create a search provider\n        this._searchProviders = await Promise.all(cells.map(async (cell, index) => {\n            const cellSearchProvider = createCellSearchProvider(cell);\n            await cellSearchProvider.setIsActive(!this._filters.selection ||\n                this.widget.content.isSelectedOrActive(cell));\n            if (this._onSelection &&\n                this._selectionSearchMode === 'text' &&\n                index === currentProviderIndex) {\n                if (this._textSelection) {\n                    await cellSearchProvider.setSearchSelection(this._textSelection);\n                }\n            }\n            await cellSearchProvider.startQuery(query, this._filters);\n            return cellSearchProvider;\n        }));\n        this._currentProviderIndex = currentProviderIndex;\n        // We do not want to show the first \"current\" closest to cursor as depending\n        // on which way the user dragged the selection it would be:\n        // - the first or last match when searching in selection\n        // - the next match when starting search using ctrl + f\n        // `scroll` and `select` are disabled because `startQuery` is also used as\n        // \"restartQuery\" after each text change and if those were enabled, we would\n        // steal the cursor.\n        await this.highlightNext(true, {\n            from: 'selection-start',\n            scroll: false,\n            select: false\n        });\n        return Promise.resolve();\n    }\n    /**\n     * Stop the search and clear all internal state.\n     */\n    async endQuery() {\n        await Promise.all(this._searchProviders.map(provider => {\n            return provider.endQuery().then(() => {\n                provider.dispose();\n            });\n        }));\n        this._searchProviders.length = 0;\n        this._currentProviderIndex = null;\n    }\n    /**\n     * Replace the currently selected match with the provided text\n     *\n     * @param newText The replacement text.\n     * @param loop Whether to loop within the matches list.\n     *\n     * @returns A promise that resolves with a boolean indicating whether a replace occurred.\n     */\n    async replaceCurrentMatch(newText, loop = true, options) {\n        let replaceOccurred = false;\n        const unrenderMarkdownCell = async (highlightNext = false) => {\n            var _a;\n            // Unrendered markdown cell\n            const activeCell = (_a = this.widget) === null || _a === void 0 ? void 0 : _a.content.activeCell;\n            if ((activeCell === null || activeCell === void 0 ? void 0 : activeCell.model.type) === 'markdown' &&\n                activeCell.rendered) {\n                activeCell.rendered = false;\n                if (highlightNext) {\n                    await this.highlightNext(loop);\n                }\n            }\n        };\n        if (this._currentProviderIndex !== null) {\n            await unrenderMarkdownCell();\n            const searchEngine = this._searchProviders[this._currentProviderIndex];\n            replaceOccurred = await searchEngine.replaceCurrentMatch(newText, false, options);\n            if (searchEngine.currentMatchIndex === null) {\n                // switch to next cell\n                await this.highlightNext(loop);\n            }\n        }\n        // TODO: markdown undrendering/highlighting sequence is likely incorrect\n        // Force highlighting the first hit in the unrendered cell\n        await unrenderMarkdownCell(true);\n        return replaceOccurred;\n    }\n    /**\n     * Replace all matches in the notebook with the provided text\n     *\n     * @param newText The replacement text.\n     *\n     * @returns A promise that resolves with a boolean indicating whether a replace occurred.\n     */\n    async replaceAllMatches(newText, options) {\n        const replacementOccurred = await Promise.all(this._searchProviders.map(provider => {\n            return provider.replaceAllMatches(newText, options);\n        }));\n        return replacementOccurred.includes(true);\n    }\n    async validateFilter(name, value) {\n        if (name !== 'output') {\n            // Bail early\n            return value;\n        }\n        // If value is true and some cells have never been rendered, ask confirmation.\n        if (value &&\n            this.widget.content.widgets.some(w => w instanceof CodeCell && w.isPlaceholder())) {\n            const trans = this.translator.load('jupyterlab');\n            const reply = await showDialog({\n                title: trans.__('Confirmation'),\n                body: trans.__('Searching outputs is expensive and requires to first rendered all outputs. Are you sure you want to search in the cell outputs?'),\n                buttons: [\n                    Dialog.cancelButton({ label: trans.__('Cancel') }),\n                    Dialog.okButton({ label: trans.__('Ok') })\n                ]\n            });\n            if (reply.button.accept) {\n                this.widget.content.widgets.forEach((w, i) => {\n                    if (w instanceof CodeCell && w.isPlaceholder()) {\n                        this.widget.content.renderCellOutputs(i);\n                    }\n                });\n            }\n            else {\n                return false;\n            }\n        }\n        return value;\n    }\n    _addCellProvider(index) {\n        var _a, _b;\n        const cell = this.widget.content.widgets[index];\n        const cellSearchProvider = createCellSearchProvider(cell);\n        ArrayExt.insert(this._searchProviders, index, cellSearchProvider);\n        void cellSearchProvider\n            .setIsActive(!((_b = (_a = this._filters) === null || _a === void 0 ? void 0 : _a.selection) !== null && _b !== void 0 ? _b : false) ||\n            this.widget.content.isSelectedOrActive(cell))\n            .then(() => {\n            void cellSearchProvider.startQuery(this._query, this._filters);\n        });\n    }\n    _removeCellProvider(index) {\n        const provider = ArrayExt.removeAt(this._searchProviders, index);\n        provider === null || provider === void 0 ? void 0 : provider.dispose();\n    }\n    async _onCellsChanged(cells, changes) {\n        switch (changes.type) {\n            case 'add':\n                changes.newValues.forEach((model, index) => {\n                    this._addCellProvider(changes.newIndex + index);\n                });\n                break;\n            case 'move':\n                ArrayExt.move(this._searchProviders, changes.oldIndex, changes.newIndex);\n                break;\n            case 'remove':\n                for (let index = 0; index < changes.oldValues.length; index++) {\n                    this._removeCellProvider(changes.oldIndex);\n                }\n                break;\n            case 'set':\n                changes.newValues.forEach((model, index) => {\n                    this._addCellProvider(changes.newIndex + index);\n                    this._removeCellProvider(changes.newIndex + index + 1);\n                });\n                break;\n        }\n        this._stateChanged.emit();\n    }\n    async _stepNext(reverse = false, loop = false, options) {\n        const activateNewMatch = async (match) => {\n            var _a;\n            const shouldScroll = (_a = options === null || options === void 0 ? void 0 : options.scroll) !== null && _a !== void 0 ? _a : true;\n            if (!shouldScroll) {\n                // do not activate the match if scrolling was disabled\n                return;\n            }\n            this._selectionLock = true;\n            if (this.widget.content.activeCellIndex !== this._currentProviderIndex) {\n                this.widget.content.activeCellIndex = this._currentProviderIndex;\n            }\n            if (this.widget.content.activeCellIndex === -1) {\n                console.warn('No active cell (no cells or no model), aborting search');\n                this._selectionLock = false;\n                return;\n            }\n            const activeCell = this.widget.content.activeCell;\n            if (!activeCell.inViewport) {\n                try {\n                    await this.widget.content.scrollToItem(this._currentProviderIndex);\n                }\n                catch (error) {\n                    // no-op\n                }\n            }\n            // Unhide cell\n            if (activeCell.inputHidden) {\n                activeCell.inputHidden = false;\n            }\n            if (!activeCell.inViewport) {\n                this._selectionLock = false;\n                // It will not be possible the cell is not in the view\n                return;\n            }\n            await activeCell.ready;\n            const editor = activeCell.editor;\n            editor.revealPosition(editor.getPositionAt(match.position));\n            this._selectionLock = false;\n        };\n        if (this._currentProviderIndex === null) {\n            this._currentProviderIndex = this.widget.content.activeCellIndex;\n        }\n        // When going to previous match in cell mode and there is no current we\n        // want to skip the active cell and go to the previous cell; in edit mode\n        // the appropriate behaviour is induced by searching from nearest cursor.\n        if (reverse && this.widget.content.mode === 'command') {\n            const searchEngine = this._searchProviders[this._currentProviderIndex];\n            const currentMatch = searchEngine.getCurrentMatch();\n            if (!currentMatch) {\n                this._currentProviderIndex -= 1;\n            }\n            if (loop) {\n                this._currentProviderIndex =\n                    (this._currentProviderIndex + this._searchProviders.length) %\n                        this._searchProviders.length;\n            }\n        }\n        const startIndex = this._currentProviderIndex;\n        do {\n            const searchEngine = this._searchProviders[this._currentProviderIndex];\n            const match = reverse\n                ? await searchEngine.highlightPrevious(false, options)\n                : await searchEngine.highlightNext(false, options);\n            if (match) {\n                await activateNewMatch(match);\n                return match;\n            }\n            else {\n                this._currentProviderIndex =\n                    this._currentProviderIndex + (reverse ? -1 : 1);\n                if (loop) {\n                    this._currentProviderIndex =\n                        (this._currentProviderIndex + this._searchProviders.length) %\n                            this._searchProviders.length;\n                }\n            }\n        } while (loop\n            ? // We looped on all cells, no hit found\n                this._currentProviderIndex !== startIndex\n            : 0 <= this._currentProviderIndex &&\n                this._currentProviderIndex < this._searchProviders.length);\n        if (loop) {\n            // try the first provider again\n            const searchEngine = this._searchProviders[startIndex];\n            const match = reverse\n                ? await searchEngine.highlightPrevious(false, options)\n                : await searchEngine.highlightNext(false, options);\n            if (match) {\n                await activateNewMatch(match);\n                return match;\n            }\n        }\n        this._currentProviderIndex = null;\n        return null;\n    }\n    async _onActiveCellChanged() {\n        if (this._delayedActiveCellChangeHandler !== null) {\n            // Prevent handler from running twice if active cell is changed twice\n            // within the same task of the event loop.\n            clearTimeout(this._delayedActiveCellChangeHandler);\n            this._delayedActiveCellChangeHandler = null;\n        }\n        if (this.widget.content.activeCellIndex !== this._currentProviderIndex) {\n            // At this time we cannot handle the change of active cell, because\n            // `activeCellChanged` is also emitted in the middle of cell selection\n            // change, and if selection is getting extended, we do not want to clear\n            // highlights just to re-apply them shortly after, which has side effects\n            // impacting the functionality and performance.\n            this._delayedActiveCellChangeHandler = setTimeout(() => {\n                this.delayedActiveCellChangeHandlerReady =\n                    this._handleHighlightsAfterActiveCellChange();\n            }, 0);\n        }\n        this._observeActiveCell();\n    }\n    async _handleHighlightsAfterActiveCellChange() {\n        if (this._onSelection) {\n            const previousProviderCell = this._currentProviderIndex !== null &&\n                this._currentProviderIndex < this.widget.content.widgets.length\n                ? this.widget.content.widgets[this._currentProviderIndex]\n                : null;\n            const previousProviderInCurrentSelection = previousProviderCell &&\n                this.widget.content.isSelectedOrActive(previousProviderCell);\n            if (!previousProviderInCurrentSelection) {\n                await this._updateCellSelection();\n                // Clear highlight from previous provider\n                await this.clearHighlight();\n                // If we are searching in all cells, we should not change the active\n                // provider when switching active cell to preserve current match;\n                // if we are searching within selected cells we should update\n                this._currentProviderIndex = this.widget.content.activeCellIndex;\n            }\n        }\n        await this._ensureCurrentMatch();\n    }\n    /**\n     * If there are results but no match is designated as current,\n     * mark a result as current and highlight it.\n     */\n    async _ensureCurrentMatch() {\n        if (this._currentProviderIndex !== null) {\n            const searchEngine = this._searchProviders[this._currentProviderIndex];\n            if (!searchEngine) {\n                // This can happen when `startQuery()` has not finished yet.\n                return;\n            }\n            const currentMatch = searchEngine.getCurrentMatch();\n            if (!currentMatch && this.matchesCount) {\n                // Select a match as current by highlighting next (with looping) from\n                // the selection start, to prevent \"current\" match from jumping around.\n                await this.highlightNext(true, {\n                    from: 'start',\n                    scroll: false,\n                    select: false\n                });\n            }\n        }\n    }\n    _observeActiveCell() {\n        var _a;\n        const editor = (_a = this.widget.content.activeCell) === null || _a === void 0 ? void 0 : _a.editor;\n        if (!editor) {\n            return;\n        }\n        this._stopObservingLastCell();\n        editor.model.selections.changed.connect(this._setSelectedLines, this);\n        this._editorSelectionsObservable = editor.model.selections;\n    }\n    _stopObservingLastCell() {\n        if (this._editorSelectionsObservable) {\n            this._editorSelectionsObservable.changed.disconnect(this._setSelectedLines, this);\n        }\n    }\n    _setSelectedLines() {\n        var _a;\n        const editor = (_a = this.widget.content.activeCell) === null || _a === void 0 ? void 0 : _a.editor;\n        if (!editor) {\n            return;\n        }\n        const selection = editor.getSelection();\n        const { start, end } = selection;\n        const newLines = end.line === start.line && end.column === start.column\n            ? 0\n            : end.line - start.line + 1;\n        this._textSelection = selection;\n        if (newLines !== this._selectedLines) {\n            this._selectedLines = newLines;\n            this._updateSelectionMode();\n        }\n        this._filtersChanged.emit();\n    }\n    /**\n     * Set whether the engines should search within selection only or full text.\n     */\n    async _setEnginesSelectionSearchMode() {\n        let textMode;\n        if (!this._onSelection) {\n            // When search in selection is off we always search full text\n            textMode = false;\n        }\n        else {\n            // When search in selection is off we either search in full cells\n            // (toggling off isActive flag on search enginges of non-selected cells)\n            // or in selected text of the active cell.\n            textMode = this._selectionSearchMode === 'text';\n        }\n        if (this._selectionLock) {\n            return;\n        }\n        // Clear old selection restrictions or if relevant, set current restrictions for active provider.\n        await Promise.all(this._searchProviders.map((provider, index) => {\n            const isCurrent = this.widget.content.activeCellIndex === index;\n            provider.setProtectSelection(isCurrent && this._onSelection);\n            return provider.setSearchSelection(isCurrent && textMode ? this._textSelection : null);\n        }));\n    }\n    async _onCellSelectionChanged() {\n        if (this._delayedActiveCellChangeHandler !== null) {\n            // Avoid race condition due to `activeCellChanged` and `selectionChanged`\n            // signals firing in short sequence when selection gets extended, with\n            // handling of the former having potential to undo selection set by the latter.\n            clearTimeout(this._delayedActiveCellChangeHandler);\n            this._delayedActiveCellChangeHandler = null;\n        }\n        await this._updateCellSelection();\n        if (this._currentProviderIndex === null) {\n            // For consistency we set the first cell in selection as current provider.\n            const firstSelectedCellIndex = this.widget.content.widgets.findIndex(cell => this.widget.content.isSelectedOrActive(cell));\n            this._currentProviderIndex = firstSelectedCellIndex;\n        }\n        await this._ensureCurrentMatch();\n    }\n    async _updateCellSelection() {\n        const cells = this.widget.content.widgets;\n        let selectedCells = 0;\n        await Promise.all(cells.map(async (cell, index) => {\n            const provider = this._searchProviders[index];\n            const isSelected = this.widget.content.isSelectedOrActive(cell);\n            if (isSelected) {\n                selectedCells += 1;\n            }\n            if (provider && this._onSelection) {\n                await provider.setIsActive(isSelected);\n            }\n        }));\n        if (selectedCells !== this._selectedCells) {\n            this._selectedCells = selectedCells;\n            this._updateSelectionMode();\n        }\n        this._filtersChanged.emit();\n    }\n}\n//# sourceMappingURL=searchprovider.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { Token } from '@lumino/coreutils';\n/**\n * The notebook widget factory token.\n */\nexport const INotebookWidgetFactory = new Token('@jupyterlab/notebook:INotebookWidgetFactory', 'A service to create the notebook viewer.');\n/**\n * The notebook tools token.\n */\nexport const INotebookTools = new Token('@jupyterlab/notebook:INotebookTools', `A service for the \"Notebook Tools\" panel in the\n  right sidebar. Use this to add your own functionality to the panel.`);\n/**\n * The notebook tracker token.\n */\nexport const INotebookTracker = new Token('@jupyterlab/notebook:INotebookTracker', `A widget tracker for notebooks.\n  Use this if you want to be able to iterate over and interact with notebooks\n  created by the application.`);\n//# sourceMappingURL=tokens.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { WidgetTracker } from '@jupyterlab/apputils';\nimport { Signal } from '@lumino/signaling';\nexport class NotebookTracker extends WidgetTracker {\n    constructor() {\n        super(...arguments);\n        this._activeCell = null;\n        this._activeCellChanged = new Signal(this);\n        this._selectionChanged = new Signal(this);\n    }\n    /**\n     * The currently focused cell.\n     *\n     * #### Notes\n     * This is a read-only property. If there is no cell with the focus, then this\n     * value is `null`.\n     */\n    get activeCell() {\n        const widget = this.currentWidget;\n        if (!widget) {\n            return null;\n        }\n        return widget.content.activeCell || null;\n    }\n    /**\n     * A signal emitted when the current active cell changes.\n     *\n     * #### Notes\n     * If there is no cell with the focus, then `null` will be emitted.\n     */\n    get activeCellChanged() {\n        return this._activeCellChanged;\n    }\n    /**\n     * A signal emitted when the selection state changes.\n     */\n    get selectionChanged() {\n        return this._selectionChanged;\n    }\n    /**\n     * Add a new notebook panel to the tracker.\n     *\n     * @param panel - The notebook panel being added.\n     */\n    add(panel) {\n        const promise = super.add(panel);\n        panel.content.activeCellChanged.connect(this._onActiveCellChanged, this);\n        panel.content.selectionChanged.connect(this._onSelectionChanged, this);\n        return promise;\n    }\n    /**\n     * Dispose of the resources held by the tracker.\n     */\n    dispose() {\n        this._activeCell = null;\n        super.dispose();\n    }\n    /**\n     * Handle the current change event.\n     */\n    onCurrentChanged(widget) {\n        // Store an internal reference to active cell to prevent false positives.\n        const activeCell = this.activeCell;\n        if (activeCell && activeCell === this._activeCell) {\n            return;\n        }\n        this._activeCell = activeCell;\n        if (!widget) {\n            return;\n        }\n        // Since the notebook has changed, immediately signal an active cell change\n        this._activeCellChanged.emit(widget.content.activeCell || null);\n    }\n    _onActiveCellChanged(sender, cell) {\n        // Check if the active cell change happened for the current notebook.\n        if (this.currentWidget && this.currentWidget.content === sender) {\n            this._activeCell = cell || null;\n            this._activeCellChanged.emit(this._activeCell);\n        }\n    }\n    _onSelectionChanged(sender) {\n        // Check if the selection change happened for the current notebook.\n        if (this.currentWidget && this.currentWidget.content === sender) {\n            this._selectionChanged.emit(void 0);\n        }\n    }\n}\n//# sourceMappingURL=tracker.js.map","/*\n * Copyright (c) Jupyter Development Team.\n * Distributed under the terms of the Modified BSD License.\n */\nimport { nullTranslator } from '@jupyterlab/translation';\nimport { notTrustedIcon, trustedIcon, VDomModel, VDomRenderer } from '@jupyterlab/ui-components';\nimport React from 'react';\nconst TRUST_CLASS = 'jp-StatusItem-trust';\n/**\n * Determine the notebook trust status message.\n */\nfunction cellTrust(props, translator) {\n    translator = translator || nullTranslator;\n    const trans = translator.load('jupyterlab');\n    if (props.trustedCells === props.totalCells) {\n        return trans.__('Notebook trusted: %1 of %2 code cells trusted.', props.trustedCells, props.totalCells);\n    }\n    else if (props.activeCellTrusted) {\n        return trans.__('Active cell trusted: %1 of %2 code cells trusted.', props.trustedCells, props.totalCells);\n    }\n    else {\n        return trans.__('Notebook not trusted: %1 of %2 code cells trusted.', props.trustedCells, props.totalCells);\n    }\n}\n/**\n * A pure function for a notebook trust status component.\n *\n * @param props: the props for the component.\n *\n * @returns a tsx component for notebook trust.\n */\nfunction NotebookTrustComponent(props) {\n    if (props.allCellsTrusted) {\n        return React.createElement(trustedIcon.react, { top: '2px', stylesheet: 'statusBar' });\n    }\n    else {\n        return React.createElement(notTrustedIcon.react, { top: '2px', stylesheet: 'statusBar' });\n    }\n}\n/**\n * The NotebookTrust status item.\n */\nexport class NotebookTrustStatus extends VDomRenderer {\n    /**\n     * Construct a new status item.\n     */\n    constructor(translator) {\n        super(new NotebookTrustStatus.Model());\n        this.translator = translator || nullTranslator;\n        this.node.classList.add(TRUST_CLASS);\n    }\n    /**\n     * Render the NotebookTrust status item.\n     */\n    render() {\n        if (!this.model) {\n            return null;\n        }\n        const newTitle = cellTrust(this.model, this.translator);\n        if (newTitle !== this.node.title) {\n            this.node.title = newTitle;\n        }\n        return (React.createElement(NotebookTrustComponent, { allCellsTrusted: this.model.trustedCells === this.model.totalCells, activeCellTrusted: this.model.activeCellTrusted, totalCells: this.model.totalCells, trustedCells: this.model.trustedCells }));\n    }\n}\n/**\n * A namespace for NotebookTrust statics.\n */\n(function (NotebookTrustStatus) {\n    /**\n     * A VDomModel for the NotebookTrust status item.\n     */\n    class Model extends VDomModel {\n        constructor() {\n            super(...arguments);\n            this._trustedCells = 0;\n            this._totalCells = 0;\n            this._activeCellTrusted = false;\n            this._notebook = null;\n        }\n        /**\n         * The number of trusted code cells in the current notebook.\n         */\n        get trustedCells() {\n            return this._trustedCells;\n        }\n        /**\n         * The total number of code cells in the current notebook.\n         */\n        get totalCells() {\n            return this._totalCells;\n        }\n        /**\n         * Whether the active cell is trusted.\n         */\n        get activeCellTrusted() {\n            return this._activeCellTrusted;\n        }\n        /**\n         * The current notebook for the model.\n         */\n        get notebook() {\n            return this._notebook;\n        }\n        set notebook(model) {\n            const oldNotebook = this._notebook;\n            if (oldNotebook !== null) {\n                oldNotebook.activeCellChanged.disconnect(this._onActiveCellChanged, this);\n                oldNotebook.modelContentChanged.disconnect(this._onModelChanged, this);\n            }\n            const oldState = this._getAllState();\n            this._notebook = model;\n            if (this._notebook === null) {\n                this._trustedCells = 0;\n                this._totalCells = 0;\n                this._activeCellTrusted = false;\n            }\n            else {\n                // Add listeners\n                this._notebook.activeCellChanged.connect(this._onActiveCellChanged, this);\n                this._notebook.modelContentChanged.connect(this._onModelChanged, this);\n                // Derive values\n                if (this._notebook.activeCell) {\n                    this._activeCellTrusted = this._notebook.activeCell.model.trusted;\n                }\n                else {\n                    this._activeCellTrusted = false;\n                }\n                const { total, trusted } = this._deriveCellTrustState(this._notebook.model);\n                this._totalCells = total;\n                this._trustedCells = trusted;\n            }\n            this._triggerChange(oldState, this._getAllState());\n        }\n        /**\n         * When the notebook model changes, update the trust state.\n         */\n        _onModelChanged(notebook) {\n            const oldState = this._getAllState();\n            const { total, trusted } = this._deriveCellTrustState(notebook.model);\n            this._totalCells = total;\n            this._trustedCells = trusted;\n            this._triggerChange(oldState, this._getAllState());\n        }\n        /**\n         * When the active cell changes, update the trust state.\n         */\n        _onActiveCellChanged(model, cell) {\n            const oldState = this._getAllState();\n            if (cell) {\n                this._activeCellTrusted = cell.model.trusted;\n            }\n            else {\n                this._activeCellTrusted = false;\n            }\n            this._triggerChange(oldState, this._getAllState());\n        }\n        /**\n         * Given a notebook model, figure out how many of the code cells are trusted.\n         */\n        _deriveCellTrustState(model) {\n            if (model === null) {\n                return { total: 0, trusted: 0 };\n            }\n            let total = 0;\n            let trusted = 0;\n            for (const cell of model.cells) {\n                if (cell.type !== 'code') {\n                    continue;\n                }\n                total++;\n                if (cell.trusted) {\n                    trusted++;\n                }\n            }\n            return { total, trusted };\n        }\n        /**\n         * Get the current state of the model.\n         */\n        _getAllState() {\n            return [this._trustedCells, this._totalCells, this.activeCellTrusted];\n        }\n        /**\n         * Trigger a change in the renderer.\n         */\n        _triggerChange(oldState, newState) {\n            if (oldState[0] !== newState[0] ||\n                oldState[1] !== newState[1] ||\n                oldState[2] !== newState[2]) {\n                this.stateChanged.emit(void 0);\n            }\n        }\n    }\n    NotebookTrustStatus.Model = Model;\n})(NotebookTrustStatus || (NotebookTrustStatus = {}));\n//# sourceMappingURL=truststatus.js.map","// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nimport { ABCWidgetFactory } from '@jupyterlab/docregistry';\nimport { NotebookPanel } from './panel';\nimport { StaticNotebook } from './widget';\n/**\n * A widget factory for notebook panels.\n */\nexport class NotebookWidgetFactory extends ABCWidgetFactory {\n    /**\n     * Construct a new notebook widget factory.\n     *\n     * @param options - The options used to construct the factory.\n     */\n    constructor(options) {\n        super(options);\n        this.rendermime = options.rendermime;\n        this.contentFactory = options.contentFactory;\n        this.mimeTypeService = options.mimeTypeService;\n        this._editorConfig =\n            options.editorConfig || StaticNotebook.defaultEditorConfig;\n        this._notebookConfig =\n            options.notebookConfig || StaticNotebook.defaultNotebookConfig;\n    }\n    /**\n     * A configuration object for cell editor settings.\n     */\n    get editorConfig() {\n        return this._editorConfig;\n    }\n    set editorConfig(value) {\n        this._editorConfig = value;\n    }\n    /**\n     * A configuration object for notebook settings.\n     */\n    get notebookConfig() {\n        return this._notebookConfig;\n    }\n    set notebookConfig(value) {\n        this._notebookConfig = value;\n    }\n    /**\n     * Create a new widget.\n     *\n     * #### Notes\n     * The factory will start the appropriate kernel.\n     */\n    createNewWidget(context, source) {\n        const translator = context.translator;\n        const nbOptions = {\n            rendermime: source\n                ? source.content.rendermime\n                : this.rendermime.clone({ resolver: context.urlResolver }),\n            contentFactory: this.contentFactory,\n            mimeTypeService: this.mimeTypeService,\n            editorConfig: source ? source.content.editorConfig : this._editorConfig,\n            notebookConfig: source\n                ? source.content.notebookConfig\n                : this._notebookConfig,\n            translator\n        };\n        const content = this.contentFactory.createNotebook(nbOptions);\n        return new NotebookPanel({ context, content });\n    }\n}\n//# sourceMappingURL=widgetfactory.js.map"],"names":["JUPYTER_CELL_MIME","KernelError","Error","constructor","content","errorContent","errorName","ename","errorValue","evalue","super","this","traceback","Object","setPrototypeOf","prototype","NotebookActions","executed","Private","executionScheduled","selectionExecuted","move","notebook","shift","model","activeCell","state","getState","firstIndex","widgets","findIndex","w","isSelectedOrActive","lastIndex","slice","cells","length","moveCell","handleState","addCells","mode","values","cellsFromClipboard","index","prevActiveCellIndex","activeCellIndex","sharedModel","transact","forEach","child","childIndex","toDelete","deletable","getMetadata","push","reverse","i","deleteCell","insertCells","map","cell","id","cell_type","lastClipboardInteraction","undefined","deselectAll","setHeadingCollapse","collapsing","which","possibleCell","selectedHeadingInfo","getHeadingInfo","isHidden","MarkdownCell","isHeading","cellNum","localCollapsed","localCollapsedLevel","subCell","subCellHeadingInfo","headingLevel","setHidden","collapsed","numberChildNodes","setCellCollapse","level","headingInfo","headingCollapsed","splitCell","nbModel","editor","selections","getSelections","orig","getSource","offsets","start","end","getOffsetAt","clones","offset","offsetIdx","metadata","toJSON","source","replace","activeCellDelta","scrollToItem","then","_a","focus","catch","reason","mergeCells","mergeAbove","toMerge","primary","active","attachments","isRawCellModel","isMarkdownCellModel","key","keys","get","cellModel","unshift","primaryModel","trusted","newModel","join","insertCell","sort","a","b","rendered","deleteCells","insertAbove","newIndex","notebookConfig","defaultCell","insertBelow","moveDown","moveUp","changeCellType","value","run","sessionContext","sessionDialogs","translator","Promise","resolve","promise","runSelected","handleRunState","runAndAdvance","async","inViewport","signalToPromise","inViewportChanged","runAndInsert","runAll","select","renderAllMarkdown","previousIndex","type","runAllAbove","runAllBelow","replaceSelection","text","_b","_c","call","selectAbove","possibleNextCellIndex","possibleNextCell","inputHidden","selectBelow","maxCellIndex","footer","layout","node","insertSameLevelHeadingAbove","Headings","determineHeadingLevel","insertHeadingAboveCellIndex","insertSameLevelHeadingBelow","cellIdxOfHeadingBelow","findLowerEqualLevelHeadingBelow","selectHeadingAboveOrCollapseHeading","hInfoActiveCell","targetHeadingCellIdx","findLowerEqualLevelParentHeadingAbove","selectHeadingBelowOrExpandHeading","hInfo","findHeadingBelow","extendSelectionAbove","toTop","extendContiguousSelectionTo","extendSelectionBelow","toBottom","selectAll","copy","copyOrCut","cut","paste","clipboard","Clipboard","getInstance","hasData","getData","duplicate","selectedCells","undo","redo","toggleAllLineNumbers","config","editorConfig","lineNumbers","code","markdown","raw","newConfig","clearOutputs","clearExecution","outputHidden","clearAllOutputs","hideCode","showCode","hideAllCode","showAllCode","hideOutput","showOutput","hideAllOutputs","renderSideBySide","renderingLayout","renderDefault","showAllOutputs","enableOutputScrolling","outputsScrolled","disableOutputScrolling","selectLastRunCell","latestTime","latestCellIdx","cellIndx","execution","JSONExt","isObject","timestamp","toString","startTime","Date","setMarkdownHeader","Math","min","max","collapseAllHeadings","expandAllHeadings","expandParent","nearestParentCell","childHeaderInfo","cellN","findNearestParentHeader","findNextParentHeading","toggleCurrentHeadingCollapse","trust","trans","nullTranslator","load","every","trustMessage","__","href","target","rel","showDialog","body","buttons","Dialog","okButton","title","cancelButton","warnButton","label","ariaLabel","result","button","accept","wasFocused","contains","document","activeElement","activeCellId","scrollIfNeeded","activate","deletedCells","Signal","scroll","inputArea","selected","filter","all","emit","success","isTerminating","session","path","pendingInput","hasNoKernel","startKernel","selectKernel","ran","reply","CodeCell","execute","recordTiming","splice","isDisposed","status","payload","setNextInput","setSource","notebookModel","handlePayload","message","startsWith","error","runCell","results","lastCell","update","executionCount","setPrompt","cellJSON","clear","data","setData","notebookSharedModel","newCell","includes","newHeader","Array","matches","exec","findParentHeading","childCell","includeChildCell","returnIndex","cellIdx","indexOf","baseCell","baseHeadingLevel","headingInfoBaseCell","parentHeading","cellIndex","repeat","CellList","_cellMap","WeakMap","_changed","_isDisposed","_insertCells","changed","connect","_onSharedModelChanged","Symbol","iterator","dispose","clearData","CodeCellModel","MarkdownCellModel","RawCellModel","set","disposed","delete","self","change","currpos","events","cellsChange","delta","insert","newValues","c","oldIndex","oldValues","fill","retain","msg","ToolbarItems","createSaveButton","panel","onClick","context","readOnly","save","createCheckpoint","addToolbarButtonClass","ReactWidget","create","UseSignal","signal","fileChanged","ToolbarButtonComponent","icon","saveIcon","tooltip","enabled","contentsModel","writable","createInsertButton","ToolbarButton","addIcon","createCutButton","cutIcon","createCopyButton","copyIcon","createPasteButton","pasteIcon","createRunButton","runIcon","createRestartRunAllButton","dialogs","fastForwardIcon","dialogs_","SessionContextDialogs","restart","restarted","createCellTypeItem","CellTypeSwitcher","getDefaultItems","name","widget","createInterruptButton","createRestartButton","Toolbar","createSpacerItem","createKernelNameItem","handleChange","event","_notebook","handleKeyDown","keyCode","_trans","addClass","activeCellChanged","selectionChanged","render","HTMLSelect","className","onChange","onKeyDown","ExecutionIndicatorComponent","props","kernelStatuses","translateKernelStatuses","showOnToolBar","displayOption","showProgress","tooltipClass","emptyDiv","kernelStatus","circleIconProps","alignSelf","height","time","totalTime","scheduledCellNumber","executedCellNumber","scheduledCell","size","percentage","displayClass","progressBar","ProgressCircle","progress","width","titleFactory","translatedStatus","reactElement","circle","popup","offlineBoltIcon","react","circleIcon","executionStatus","_n","ExecutionIndicator","VDomRenderer","Model","renderFlag","nb","currentNotebook","executionState","VDomModel","_notebookExecutionProgress","_displayOption","_renderFlag","attachNotebook","_d","_currentNotebook","has","interval","timeout","Set","needReset","contextStatusChanged","ctx","kernelDisplayStatus","stateChanged","statusChanged","contextConnectionStatusChanged","connectionStatusChanged","disconnect","handleKernelMsg","sender","msgId","header","msg_id","msg_type","_cellScheduledCallback","KernelMessage","isStatusMsg","execution_state","parentId","parent_header","_cellExecutedCallback","_restartHandler","_startTimer","kernel","anyMessage","kernelChangedSlot","_","kernelData","_resetTime","newValue","kernelChanged","options","_scheduleSwitchToIdle","window","setTimeout","clearInterval","clearTimeout","setInterval","_tick","add","updateRenderOption","getSettingValue","settings","configValues","composite","showOnStatusBar","createExecutionIndicatorItem","loadSettings","toolbarItem","updateSettings","newSettings","console","NotebookModel","standaloneModel","_dirty","_readOnly","_contentChanged","_stateChanged","_metadataChanged","YNotebook","disableDocumentWideUndoRedo","nbformat","nbformat_minor","kernelspec","display_name","language_info","languagePreference","_cells","_deletedCells","_collaborationEnabled","collaborationEnabled","_onCellsChanged","_onStateChanged","metadataChanged","_onMetadataChanged","contentChanged","dirty","oldValue","triggerStateChange","nbformatMinor","defaultKernelName","spec","defaultKernelLanguage","info","collaborative","deleteMetadata","setMetadata","JSON","stringify","fromString","fromJSON","parse","_ensureMetadata","deepCopy","origNbformat","orig_nbformat","list","triggerContentChange","changes","stateChange","languageName","args","NotebookModelFactory","_disposed","_disableDocumentWideUndoRedo","_collaborative","contentType","fileFormat","createNew","preferredLanguage","CommandEditComponent","TextItem","modeNames","notebookMode","CommandEditStatus","_modeNames","command","edit","arguments","_onChanged","oldMode","_notebookMode","_triggerChange","oldNotebook","modelContentChanged","oldState","newState","NotebookAdapter","WidgetLSPAdapter","editorWidget","_type","_readyDelegate","PromiseDelegate","_editorToCell","Map","_cellToEditor","ready","connectionManager","initOnceReady","documentPath","mimeType","languageMetadata","mimetype","codeMimetype","isArray","languageFileExtension","file_extension","wrapperElement","editors","ceEditor","_getCellEditor","activeEditor","getEditorIndexAt","position","_getCellAt","otherCell","getEditorIndex","getEditorWrapper","onKernelChanged","_session","oldLanguageInfo","_languageInfo","untilReady","isReady","_updateLanguageInfo","newLanguageInfo","log","reloadConnection","err","warn","_activeCellChanged","isVisible","handleCellChange","cellsAdded","cellsRemoved","convertedToMarkdownOrRaw","convertedToCode","updateDocuments","cellWidget","find","createVirtualDocument","VirtualDocument","language","foreignCodeExtractors","foreignCodeExtractorsManager","fileExtension","standalone","hasLspSupportedFile","bind","initVirtual","connectDocument","virtualDocument","_connectModelSignals","modelChanged","_activeEditorChanged","pos","getEditorAtVirtualLine","freeze","getEditor","reveal","scrollToCell","_editorRemoved","_editorAdded","RankedPanel","Widget","_items","PanelLayout","addWidget","rank","rankItem","ArrayExt","upperBound","itemCmp","insertWidget","onChildRemoved","findFirstIndex","item","removeAt","NotebookTools","_tools","_tracker","tracker","currentChanged","_onActiveNotebookPanelChanged","_onActiveCellChanged","_onSelectionChanged","currentWidget","activeNotebookPanel","addItem","tool","section","extendedTool","notebookTools","MessageLoop","sendMessage","ActiveNotebookPanelMessage","ActiveCellMessage","addSection","sectionName","newSection","Collapser","advancedToolsRank","_prevActiveNotebookModel","_onActiveNotebookPanelMetadataChanged","activeNBModel","_toolChildren","_prevActiveCell","_onActiveCellMetadataChanged","SelectionMessage","ObservableJSON","ChangeMessage","children","ConflatableMessage","Tool","processMessage","onActiveNotebookPanelChanged","onActiveCellChanged","onSelectionChanged","onActiveCellMetadataChanged","onActiveNotebookPanelMetadataChanged","MetadataEditorTool","editorFactory","_editorFactory","_editorLabel","createEditor","titleNode","createElement","textContent","_editor","JSONEditor","first","second","DROP_TARGET_CLASS","DROP_SOURCE_CLASS","NotebookViewModel","WindowedListModel","estimateWidgetSize","nLines","split","DEFAULT_EDITOR_LINE_HEIGHT","DEFAULT_CELL_MARGIN","widgetRenderer","_estimatedWidgetSize","DEFAULT_CELL_SIZE","NotebookWindowedLayout","WindowedLayout","_header","_footer","_willBeRemoved","_topHiddenCodeCells","isAttached","detach","parent","attach","removeWidget","removeWidgetAt","detachWidget","attachWidget","wasPlaceholder","isPlaceholder","Msg","BeforeAttach","parentElement","style","display","siblingIndex","_findNearestChildBinarySearch","viewportNode","childElementCount","parseInt","dataset","windowedListIndex","ref","insertBefore","AfterAttach","classList","BeforeDetach","removeChild","remove","AfterDetach","moveWidget","fromIndex","toIndex","idx","insertAdjacentElement","onAfterAttach","firstElementChild","onBeforeDetach","high","low","middle","floor","currentIndex","NotebookFooter","innerText","handleEvent","onArrowUp","blur","addEventListener","removeEventListener","NB_CELL_CLASS","EDIT_CLASS","COMMAND_CLASS","ACTIVE_CLASS","SELECTED_CLASS","OTHER_SELECTED_CLASS","DRAG_IMAGE_CLASS","SINGLE_DRAG_IMAGE_CLASS","CELL_DRAG_CONTENT_CLASS","CELL_DRAG_PROMPT_CLASS","CELL_DRAG_MULTIPLE_BACK","SIDE_BY_SIDE_CLASS","requestIdleCallback","handler","now","didTimeout","timeRemaining","cancelIdleCallback","StaticNotebook","WindowedList","_e","overscanCount","defaultNotebookConfig","windowingActive","windowingMode","_cellCollapsed","_cellInViewportChanged","_renderingLayoutChanged","cellsArray","_idleCallBack","_editorConfig","defaultEditorConfig","_notebookConfig","_mimetype","_notebookModel","_modelChanged","_modelContentChanged","rendermime","contentFactory","_updateNotebookConfig","_mimetypeService","mimeTypeService","cellCollapsed","cellInViewportChanged","renderingLayoutChanged","_onModelChanged","onModelChanged","viewModel","itemsList","_updateEditorConfig","_renderingLayout","from","to","n","boundedTo","oldCell","k","moveCells","view","renderCellOutputs","requestAnimationFrame","addHeader","removeHeader","onModelContentChanged","onMetadataChanged","_updateMimetype","onCellInserted","onCellRemoved","onUpdateRequest","_runOnIdleTime","_removeCell","_insertCell","_updateDataWindowedListIndex","_createCodeCell","_createMarkdownCell","_createRawCell","_onCellInViewportChanged","_scheduleCellRenderOnIdle","inputHistoryScope","maxNumberOutputs","placeholder","createCodeCell","syncCollapse","syncEditable","syncScrolled","outputArea","inputRequested","_onInputRequested","showEditorForReadOnlyMarkdown","createMarkdownCell","headingCollapsedChanged","_onCellCollapsed","createRawCell","getMimeTypeByLanguage","inputEl","querySelector","ElementExt","scrollIntoViewIfNeeded","deadline","globalIndex","updateEditorConfig","remainingTime","_updateForDeferMode","_renderCSSAndJSOutputs","outputIdx","outputs","match","toggleClass","scrollPastEnd","showHiddenCellsButton","showEditorForReadOnly","lineWrap","matchBrackets","sideBySideLeftMarginOverride","sideBySideRightMarginOverride","sideBySideOutputRatio","ContentFactory","Cell","initializeState","RawCell","Notebook","_activeCellIndex","_activeCell","_mode","_drag","_dragData","_mouseMode","_selectionChanged","_checkCacheOnNextResize","_lastClipboardInteraction","_selectedCells","tabIndex","setAttribute","_updateSelectedCells","addFooter","newActiveCellIndex","getId","_ensureFocus","deselect","cellChanged","_trimSelections","isSelected","selectedProperty","head","anchor","getContiguousSelection","last","findLastIndex","activeIndex","align","r","_parseFragment","fragment","cleanedFragment","parts","kind","setFragment","parsedFragment","_findHeading","_findCellById","element","widgetBox","getBoundingClientRect","elementBox","top","bottom","scrollIntoView","block","eventPhase","Event","CAPTURING_PHASE","_evtContextMenuCapture","_evtMouseDownCapture","defaultPrevented","_evtMouseDown","currentTarget","_evtDocumentMouseup","_evtDocumentMousemove","_evtDblClick","_evtFocusIn","_evtFocusOut","_evtDragEnter","_evtDragLeave","_evtDragOver","_evtDrop","onBeforeAttach","onAfterShow","onResize","cache","_cellLayoutStateCache","onBeforeHide","onActivateRequest","removeClass","count","edgeRequested","_onEdgeRequest","location","prev","lastLine","lineCount","setCursorPosition","line","column","force","hasFocus","_findCell","_findEventTargetAndCell","elementFromPoint","clientX","clientY","queryId","heading","headings","HeadingType","HTML","Markdown","mdHeading","TableOfContentsUtils","getHeadingId","markdownParser","shiftKey","preventDefault","targetArea","promptNode","hasSelection","getSelection","tagName","pressX","pressY","e","stopPropagation","dx","abs","dy","_startDrag","mimeData","elements","getElementsByClassName","dropAction","proposedAction","toMove","nextParent","firstIndexOf","countString","dragImage","createDragImage","Drag","MimeData","supportedActions","action","relatedTarget","localName","toggle","uuid","AttachedProperty","NotebookPanelLayout","promptNumber","cellContent","VirtualDOM","realize","h","div","span","NotebookPanel","DocumentWidget","_autorestarting","toolbar","_onKernelChanged","_onSessionStatusChanged","saveState","_onSave","revealed","setConfig","kernelPreference","shutdownOnDispose","kernelShutdown","autoStartDefault","Printing","symbol","printURL","PageConfig","getNBConvertURL","format","download","isParentHidden","onBeforeShow","_updateLanguage","_updateSpec","createNotebook","IContentFactory","Token","RunningStatus","NotebookSearchProvider","SearchProvider","_textSelection","_currentProviderIndex","_delayedActiveCellChangeHandler","_onSelection","_selectedLines","_query","_searchProviders","_editorSelectionsObservable","_selectionSearchMode","_selectionLock","_handleHighlightsAfterActiveCellChange","_onCellSelectionChanged","_onNotebookStateChanged","_observeActiveCell","_filtersChanged","_setEnginesSelectionSearchMode","closest","_updateSelectionMode","isApplicable","domain","currentMatchIndex","agg","found","provider","localMatch","matchesCount","reduce","sum","isReadOnly","replaceOptionsSupport","preserveCase","_stopObservingLastCell","endQuery","getFilters","output","description","default","supportReplace","selection","getInitialQuery","sliceDoc","main","clearHighlight","highlightNext","loop","_stepNext","highlightPrevious","startQuery","query","filters","_filters","currentProviderIndex","cellSearchProvider","createCellSearchProvider","setIsActive","setSearchSelection","replaceCurrentMatch","newText","replaceOccurred","unrenderMarkdownCell","searchEngine","replaceAllMatches","validateFilter","some","_addCellProvider","_removeCellProvider","activateNewMatch","revealPosition","getPositionAt","getCurrentMatch","startIndex","delayedActiveCellChangeHandlerReady","previousProviderCell","_updateCellSelection","_ensureCurrentMatch","_setSelectedLines","newLines","textMode","isCurrent","setProtectSelection","firstSelectedCellIndex","NotebookToCModel","TableOfContentsModel","parser","sanitizer","configuration","configMetadataMap","numberHeaders","numberingH1","baseNumbering","_runningCells","_cellToHeadingIndex","setConfiguration","onExecutionScheduled","onExecuted","headingsChanged","onHeadingsChanged","documentType","isAlwaysActive","supportedOptions","getCellHeadings","headingIndex","candidate","cellRef","metadataConfig","loadConfigurationFromMetadata","toggleCollapse","updateRunningStatus","getHeadings","documentLevels","syncCollapseState","includeOutput","filterHeadings","isRunning","Idle","cellHeadings","minLevel","option","negate","keyPath","p","activeHeading","setActiveHeading","Scheduled","Running","maxIsRunning","getMaxIsRunning","collapsedLevel","NotebookToCFactory","TableOfContentsFactory","_createNew","headingToElement","onActiveHeadingChanged","onCellInViewport","el","findHeadingElement","elementId","getIdForHeading","selector","outputIndex","addPrefix","prefix","clearNumbering","onHeadingCollapsed","collapseState","onCellCollapsed","onCellInViewportChanged","activeHeadingChanged","collapseChanged","INotebookWidgetFactory","INotebookTools","INotebookTracker","NotebookTracker","WidgetTracker","onCurrentChanged","NotebookTrustComponent","allCellsTrusted","trustedIcon","stylesheet","notTrustedIcon","NotebookTrustStatus","newTitle","trustedCells","totalCells","activeCellTrusted","cellTrust","_trustedCells","_totalCells","_activeCellTrusted","_getAllState","total","_deriveCellTrustState","NotebookWidgetFactory","ABCWidgetFactory","createNewWidget","nbOptions","clone","resolver","urlResolver"],"sourceRoot":""}