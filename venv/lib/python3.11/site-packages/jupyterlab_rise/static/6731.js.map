{"version":3,"file":"6731.bundle.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@lumino/application/dist/index.es6.js"],"sourcesContent":["import { CommandRegistry } from '@lumino/commands';\nimport { PromiseDelegate } from '@lumino/coreutils';\nimport { ContextMenu, Widget } from '@lumino/widgets';\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * The namespace for array-specific algorithms.\n */\nvar ArrayExt;\n(function (ArrayExt) {\n    /**\n     * Find the index of the first occurrence of a value in an array.\n     *\n     * @param array - The array-like object to search.\n     *\n     * @param value - The value to locate in the array. Values are\n     *   compared using strict `===` equality.\n     *\n     * @param start - The index of the first element in the range to be\n     *   searched, inclusive. The default value is `0`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @param stop - The index of the last element in the range to be\n     *   searched, inclusive. The default value is `-1`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @returns The index of the first occurrence of the value, or `-1`\n     *   if the value is not found.\n     *\n     * #### Notes\n     * If `stop < start` the search will wrap at the end of the array.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Undefined Behavior\n     * A `start` or `stop` which is non-integral.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * let data = ['one', 'two', 'three', 'four', 'one'];\n     * ArrayExt.firstIndexOf(data, 'red');        // -1\n     * ArrayExt.firstIndexOf(data, 'one');        // 0\n     * ArrayExt.firstIndexOf(data, 'one', 1);     // 4\n     * ArrayExt.firstIndexOf(data, 'two', 2);     // -1\n     * ArrayExt.firstIndexOf(data, 'two', 2, 1);  // 1\n     * ```\n     */\n    function firstIndexOf(array, value, start = 0, stop = -1) {\n        let n = array.length;\n        if (n === 0) {\n            return -1;\n        }\n        if (start < 0) {\n            start = Math.max(0, start + n);\n        }\n        else {\n            start = Math.min(start, n - 1);\n        }\n        if (stop < 0) {\n            stop = Math.max(0, stop + n);\n        }\n        else {\n            stop = Math.min(stop, n - 1);\n        }\n        let span;\n        if (stop < start) {\n            span = stop + 1 + (n - start);\n        }\n        else {\n            span = stop - start + 1;\n        }\n        for (let i = 0; i < span; ++i) {\n            let j = (start + i) % n;\n            if (array[j] === value) {\n                return j;\n            }\n        }\n        return -1;\n    }\n    ArrayExt.firstIndexOf = firstIndexOf;\n    /**\n     * Find the index of the last occurrence of a value in an array.\n     *\n     * @param array - The array-like object to search.\n     *\n     * @param value - The value to locate in the array. Values are\n     *   compared using strict `===` equality.\n     *\n     * @param start - The index of the first element in the range to be\n     *   searched, inclusive. The default value is `-1`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @param stop - The index of the last element in the range to be\n     *   searched, inclusive. The default value is `0`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @returns The index of the last occurrence of the value, or `-1`\n     *   if the value is not found.\n     *\n     * #### Notes\n     * If `start < stop` the search will wrap at the front of the array.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Undefined Behavior\n     * A `start` or `stop` which is non-integral.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * let data = ['one', 'two', 'three', 'four', 'one'];\n     * ArrayExt.lastIndexOf(data, 'red');        // -1\n     * ArrayExt.lastIndexOf(data, 'one');        // 4\n     * ArrayExt.lastIndexOf(data, 'one', 1);     // 0\n     * ArrayExt.lastIndexOf(data, 'two', 0);     // -1\n     * ArrayExt.lastIndexOf(data, 'two', 0, 1);  // 1\n     * ```\n     */\n    function lastIndexOf(array, value, start = -1, stop = 0) {\n        let n = array.length;\n        if (n === 0) {\n            return -1;\n        }\n        if (start < 0) {\n            start = Math.max(0, start + n);\n        }\n        else {\n            start = Math.min(start, n - 1);\n        }\n        if (stop < 0) {\n            stop = Math.max(0, stop + n);\n        }\n        else {\n            stop = Math.min(stop, n - 1);\n        }\n        let span;\n        if (start < stop) {\n            span = start + 1 + (n - stop);\n        }\n        else {\n            span = start - stop + 1;\n        }\n        for (let i = 0; i < span; ++i) {\n            let j = (start - i + n) % n;\n            if (array[j] === value) {\n                return j;\n            }\n        }\n        return -1;\n    }\n    ArrayExt.lastIndexOf = lastIndexOf;\n    /**\n     * Find the index of the first value which matches a predicate.\n     *\n     * @param array - The array-like object to search.\n     *\n     * @param fn - The predicate function to apply to the values.\n     *\n     * @param start - The index of the first element in the range to be\n     *   searched, inclusive. The default value is `0`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @param stop - The index of the last element in the range to be\n     *   searched, inclusive. The default value is `-1`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @returns The index of the first matching value, or `-1` if no\n     *   matching value is found.\n     *\n     * #### Notes\n     * If `stop < start` the search will wrap at the end of the array.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Undefined Behavior\n     * A `start` or `stop` which is non-integral.\n     *\n     * Modifying the length of the array while searching.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * function isEven(value: number): boolean {\n     *   return value % 2 === 0;\n     * }\n     *\n     * let data = [1, 2, 3, 4, 3, 2, 1];\n     * ArrayExt.findFirstIndex(data, isEven);       // 1\n     * ArrayExt.findFirstIndex(data, isEven, 4);    // 5\n     * ArrayExt.findFirstIndex(data, isEven, 6);    // -1\n     * ArrayExt.findFirstIndex(data, isEven, 6, 5); // 1\n     * ```\n     */\n    function findFirstIndex(array, fn, start = 0, stop = -1) {\n        let n = array.length;\n        if (n === 0) {\n            return -1;\n        }\n        if (start < 0) {\n            start = Math.max(0, start + n);\n        }\n        else {\n            start = Math.min(start, n - 1);\n        }\n        if (stop < 0) {\n            stop = Math.max(0, stop + n);\n        }\n        else {\n            stop = Math.min(stop, n - 1);\n        }\n        let span;\n        if (stop < start) {\n            span = stop + 1 + (n - start);\n        }\n        else {\n            span = stop - start + 1;\n        }\n        for (let i = 0; i < span; ++i) {\n            let j = (start + i) % n;\n            if (fn(array[j], j)) {\n                return j;\n            }\n        }\n        return -1;\n    }\n    ArrayExt.findFirstIndex = findFirstIndex;\n    /**\n     * Find the index of the last value which matches a predicate.\n     *\n     * @param object - The array-like object to search.\n     *\n     * @param fn - The predicate function to apply to the values.\n     *\n     * @param start - The index of the first element in the range to be\n     *   searched, inclusive. The default value is `-1`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @param stop - The index of the last element in the range to be\n     *   searched, inclusive. The default value is `0`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @returns The index of the last matching value, or `-1` if no\n     *   matching value is found.\n     *\n     * #### Notes\n     * If `start < stop` the search will wrap at the front of the array.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Undefined Behavior\n     * A `start` or `stop` which is non-integral.\n     *\n     * Modifying the length of the array while searching.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * function isEven(value: number): boolean {\n     *   return value % 2 === 0;\n     * }\n     *\n     * let data = [1, 2, 3, 4, 3, 2, 1];\n     * ArrayExt.findLastIndex(data, isEven);        // 5\n     * ArrayExt.findLastIndex(data, isEven, 4);     // 3\n     * ArrayExt.findLastIndex(data, isEven, 0);     // -1\n     * ArrayExt.findLastIndex(data, isEven, 0, 1);  // 5\n     * ```\n     */\n    function findLastIndex(array, fn, start = -1, stop = 0) {\n        let n = array.length;\n        if (n === 0) {\n            return -1;\n        }\n        if (start < 0) {\n            start = Math.max(0, start + n);\n        }\n        else {\n            start = Math.min(start, n - 1);\n        }\n        if (stop < 0) {\n            stop = Math.max(0, stop + n);\n        }\n        else {\n            stop = Math.min(stop, n - 1);\n        }\n        let d;\n        if (start < stop) {\n            d = start + 1 + (n - stop);\n        }\n        else {\n            d = start - stop + 1;\n        }\n        for (let i = 0; i < d; ++i) {\n            let j = (start - i + n) % n;\n            if (fn(array[j], j)) {\n                return j;\n            }\n        }\n        return -1;\n    }\n    ArrayExt.findLastIndex = findLastIndex;\n    /**\n     * Find the first value which matches a predicate.\n     *\n     * @param array - The array-like object to search.\n     *\n     * @param fn - The predicate function to apply to the values.\n     *\n     * @param start - The index of the first element in the range to be\n     *   searched, inclusive. The default value is `0`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @param stop - The index of the last element in the range to be\n     *   searched, inclusive. The default value is `-1`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @returns The first matching value, or `undefined` if no matching\n     *   value is found.\n     *\n     * #### Notes\n     * If `stop < start` the search will wrap at the end of the array.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Undefined Behavior\n     * A `start` or `stop` which is non-integral.\n     *\n     * Modifying the length of the array while searching.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * function isEven(value: number): boolean {\n     *   return value % 2 === 0;\n     * }\n     *\n     * let data = [1, 2, 3, 4, 3, 2, 1];\n     * ArrayExt.findFirstValue(data, isEven);       // 2\n     * ArrayExt.findFirstValue(data, isEven, 2);    // 4\n     * ArrayExt.findFirstValue(data, isEven, 6);    // undefined\n     * ArrayExt.findFirstValue(data, isEven, 6, 5); // 2\n     * ```\n     */\n    function findFirstValue(array, fn, start = 0, stop = -1) {\n        let index = findFirstIndex(array, fn, start, stop);\n        return index !== -1 ? array[index] : undefined;\n    }\n    ArrayExt.findFirstValue = findFirstValue;\n    /**\n     * Find the last value which matches a predicate.\n     *\n     * @param object - The array-like object to search.\n     *\n     * @param fn - The predicate function to apply to the values.\n     *\n     * @param start - The index of the first element in the range to be\n     *   searched, inclusive. The default value is `-1`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @param stop - The index of the last element in the range to be\n     *   searched, inclusive. The default value is `0`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @returns The last matching value, or `undefined` if no matching\n     *   value is found.\n     *\n     * #### Notes\n     * If `start < stop` the search will wrap at the front of the array.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Undefined Behavior\n     * A `start` or `stop` which is non-integral.\n     *\n     * Modifying the length of the array while searching.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * function isEven(value: number): boolean {\n     *   return value % 2 === 0;\n     * }\n     *\n     * let data = [1, 2, 3, 4, 3, 2, 1];\n     * ArrayExt.findLastValue(data, isEven);        // 2\n     * ArrayExt.findLastValue(data, isEven, 4);     // 4\n     * ArrayExt.findLastValue(data, isEven, 0);     // undefined\n     * ArrayExt.findLastValue(data, isEven, 0, 1);  // 2\n     * ```\n     */\n    function findLastValue(array, fn, start = -1, stop = 0) {\n        let index = findLastIndex(array, fn, start, stop);\n        return index !== -1 ? array[index] : undefined;\n    }\n    ArrayExt.findLastValue = findLastValue;\n    /**\n     * Find the index of the first element which compares `>=` to a value.\n     *\n     * @param array - The sorted array-like object to search.\n     *\n     * @param value - The value to locate in the array.\n     *\n     * @param fn - The 3-way comparison function to apply to the values.\n     *   It should return `< 0` if an element is less than a value, `0` if\n     *   an element is equal to a value, or `> 0` if an element is greater\n     *   than a value.\n     *\n     * @param start - The index of the first element in the range to be\n     *   searched, inclusive. The default value is `0`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @param stop - The index of the last element in the range to be\n     *   searched, inclusive. The default value is `-1`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @returns The index of the first element which compares `>=` to the\n     *   value, or `length` if there is no such element. If the computed\n     *   index for `stop` is less than `start`, then the computed index\n     *   for `start` is returned.\n     *\n     * #### Notes\n     * The array must already be sorted in ascending order according to\n     * the comparison function.\n     *\n     * #### Complexity\n     * Logarithmic.\n     *\n     * #### Undefined Behavior\n     * Searching a range which is not sorted in ascending order.\n     *\n     * A `start` or `stop` which is non-integral.\n     *\n     * Modifying the length of the array while searching.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * function numberCmp(a: number, b: number): number {\n     *   return a - b;\n     * }\n     *\n     * let data = [0, 3, 4, 7, 7, 9];\n     * ArrayExt.lowerBound(data, 0, numberCmp);   // 0\n     * ArrayExt.lowerBound(data, 6, numberCmp);   // 3\n     * ArrayExt.lowerBound(data, 7, numberCmp);   // 3\n     * ArrayExt.lowerBound(data, -1, numberCmp);  // 0\n     * ArrayExt.lowerBound(data, 10, numberCmp);  // 6\n     * ```\n     */\n    function lowerBound(array, value, fn, start = 0, stop = -1) {\n        let n = array.length;\n        if (n === 0) {\n            return 0;\n        }\n        if (start < 0) {\n            start = Math.max(0, start + n);\n        }\n        else {\n            start = Math.min(start, n - 1);\n        }\n        if (stop < 0) {\n            stop = Math.max(0, stop + n);\n        }\n        else {\n            stop = Math.min(stop, n - 1);\n        }\n        let begin = start;\n        let span = stop - start + 1;\n        while (span > 0) {\n            let half = span >> 1;\n            let middle = begin + half;\n            if (fn(array[middle], value) < 0) {\n                begin = middle + 1;\n                span -= half + 1;\n            }\n            else {\n                span = half;\n            }\n        }\n        return begin;\n    }\n    ArrayExt.lowerBound = lowerBound;\n    /**\n     * Find the index of the first element which compares `>` than a value.\n     *\n     * @param array - The sorted array-like object to search.\n     *\n     * @param value - The value to locate in the array.\n     *\n     * @param fn - The 3-way comparison function to apply to the values.\n     *   It should return `< 0` if an element is less than a value, `0` if\n     *   an element is equal to a value, or `> 0` if an element is greater\n     *   than a value.\n     *\n     * @param start - The index of the first element in the range to be\n     *   searched, inclusive. The default value is `0`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @param stop - The index of the last element in the range to be\n     *   searched, inclusive. The default value is `-1`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @returns The index of the first element which compares `>` than the\n     *   value, or `length` if there is no such element. If the computed\n     *   index for `stop` is less than `start`, then the computed index\n     *   for `start` is returned.\n     *\n     * #### Notes\n     * The array must already be sorted in ascending order according to\n     * the comparison function.\n     *\n     * #### Complexity\n     * Logarithmic.\n     *\n     * #### Undefined Behavior\n     * Searching a range which is not sorted in ascending order.\n     *\n     * A `start` or `stop` which is non-integral.\n     *\n     * Modifying the length of the array while searching.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * function numberCmp(a: number, b: number): number {\n     *   return a - b;\n     * }\n     *\n     * let data = [0, 3, 4, 7, 7, 9];\n     * ArrayExt.upperBound(data, 0, numberCmp);   // 1\n     * ArrayExt.upperBound(data, 6, numberCmp);   // 3\n     * ArrayExt.upperBound(data, 7, numberCmp);   // 5\n     * ArrayExt.upperBound(data, -1, numberCmp);  // 0\n     * ArrayExt.upperBound(data, 10, numberCmp);  // 6\n     * ```\n     */\n    function upperBound(array, value, fn, start = 0, stop = -1) {\n        let n = array.length;\n        if (n === 0) {\n            return 0;\n        }\n        if (start < 0) {\n            start = Math.max(0, start + n);\n        }\n        else {\n            start = Math.min(start, n - 1);\n        }\n        if (stop < 0) {\n            stop = Math.max(0, stop + n);\n        }\n        else {\n            stop = Math.min(stop, n - 1);\n        }\n        let begin = start;\n        let span = stop - start + 1;\n        while (span > 0) {\n            let half = span >> 1;\n            let middle = begin + half;\n            if (fn(array[middle], value) > 0) {\n                span = half;\n            }\n            else {\n                begin = middle + 1;\n                span -= half + 1;\n            }\n        }\n        return begin;\n    }\n    ArrayExt.upperBound = upperBound;\n    /**\n     * Test whether two arrays are shallowly equal.\n     *\n     * @param a - The first array-like object to compare.\n     *\n     * @param b - The second array-like object to compare.\n     *\n     * @param fn - The comparison function to apply to the elements. It\n     *   should return `true` if the elements are \"equal\". The default\n     *   compares elements using strict `===` equality.\n     *\n     * @returns Whether the two arrays are shallowly equal.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Undefined Behavior\n     * Modifying the length of the arrays while comparing.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * let d1 = [0, 3, 4, 7, 7, 9];\n     * let d2 = [0, 3, 4, 7, 7, 9];\n     * let d3 = [42];\n     * ArrayExt.shallowEqual(d1, d2);  // true\n     * ArrayExt.shallowEqual(d2, d3);  // false\n     * ```\n     */\n    function shallowEqual(a, b, fn) {\n        // Check for object identity first.\n        if (a === b) {\n            return true;\n        }\n        // Bail early if the lengths are different.\n        if (a.length !== b.length) {\n            return false;\n        }\n        // Compare each element for equality.\n        for (let i = 0, n = a.length; i < n; ++i) {\n            if (fn ? !fn(a[i], b[i]) : a[i] !== b[i]) {\n                return false;\n            }\n        }\n        // The array are shallowly equal.\n        return true;\n    }\n    ArrayExt.shallowEqual = shallowEqual;\n    /**\n     * Create a slice of an array subject to an optional step.\n     *\n     * @param array - The array-like object of interest.\n     *\n     * @param options - The options for configuring the slice.\n     *\n     * @returns A new array with the specified values.\n     *\n     * @throws An exception if the slice `step` is `0`.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Undefined Behavior\n     * A `start`, `stop`, or `step` which is non-integral.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * let data = [0, 3, 4, 7, 7, 9];\n     * ArrayExt.slice(data);                         // [0, 3, 4, 7, 7, 9]\n     * ArrayExt.slice(data, { start: 2 });           // [4, 7, 7, 9]\n     * ArrayExt.slice(data, { start: 0, stop: 4 });  // [0, 3, 4, 7]\n     * ArrayExt.slice(data, { step: 2 });            // [0, 4, 7]\n     * ArrayExt.slice(data, { step: -1 });           // [9, 7, 7, 4, 3, 0]\n     * ```\n     */\n    function slice(array, options = {}) {\n        // Extract the options.\n        let { start, stop, step } = options;\n        // Set up the `step` value.\n        if (step === undefined) {\n            step = 1;\n        }\n        // Validate the step size.\n        if (step === 0) {\n            throw new Error('Slice `step` cannot be zero.');\n        }\n        // Look up the length of the array.\n        let n = array.length;\n        // Set up the `start` value.\n        if (start === undefined) {\n            start = step < 0 ? n - 1 : 0;\n        }\n        else if (start < 0) {\n            start = Math.max(start + n, step < 0 ? -1 : 0);\n        }\n        else if (start >= n) {\n            start = step < 0 ? n - 1 : n;\n        }\n        // Set up the `stop` value.\n        if (stop === undefined) {\n            stop = step < 0 ? -1 : n;\n        }\n        else if (stop < 0) {\n            stop = Math.max(stop + n, step < 0 ? -1 : 0);\n        }\n        else if (stop >= n) {\n            stop = step < 0 ? n - 1 : n;\n        }\n        // Compute the slice length.\n        let length;\n        if ((step < 0 && stop >= start) || (step > 0 && start >= stop)) {\n            length = 0;\n        }\n        else if (step < 0) {\n            length = Math.floor((stop - start + 1) / step + 1);\n        }\n        else {\n            length = Math.floor((stop - start - 1) / step + 1);\n        }\n        // Compute the sliced result.\n        let result = [];\n        for (let i = 0; i < length; ++i) {\n            result[i] = array[start + i * step];\n        }\n        // Return the result.\n        return result;\n    }\n    ArrayExt.slice = slice;\n    /**\n     * Move an element in an array from one index to another.\n     *\n     * @param array - The mutable array-like object of interest.\n     *\n     * @param fromIndex - The index of the element to move. Negative\n     *   values are taken as an offset from the end of the array.\n     *\n     * @param toIndex - The target index of the element. Negative\n     *   values are taken as an offset from the end of the array.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Undefined Behavior\n     * A `fromIndex` or `toIndex` which is non-integral.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from from '@lumino/algorithm';\n     *\n     * let data = [0, 1, 2, 3, 4];\n     * ArrayExt.move(data, 1, 2);  // [0, 2, 1, 3, 4]\n     * ArrayExt.move(data, 4, 2);  // [0, 2, 4, 1, 3]\n     * ```\n     */\n    function move(array, fromIndex, toIndex) {\n        let n = array.length;\n        if (n <= 1) {\n            return;\n        }\n        if (fromIndex < 0) {\n            fromIndex = Math.max(0, fromIndex + n);\n        }\n        else {\n            fromIndex = Math.min(fromIndex, n - 1);\n        }\n        if (toIndex < 0) {\n            toIndex = Math.max(0, toIndex + n);\n        }\n        else {\n            toIndex = Math.min(toIndex, n - 1);\n        }\n        if (fromIndex === toIndex) {\n            return;\n        }\n        let value = array[fromIndex];\n        let d = fromIndex < toIndex ? 1 : -1;\n        for (let i = fromIndex; i !== toIndex; i += d) {\n            array[i] = array[i + d];\n        }\n        array[toIndex] = value;\n    }\n    ArrayExt.move = move;\n    /**\n     * Reverse an array in-place.\n     *\n     * @param array - The mutable array-like object of interest.\n     *\n     * @param start - The index of the first element in the range to be\n     *   reversed, inclusive. The default value is `0`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @param stop - The index of the last element in the range to be\n     *   reversed, inclusive. The default value is `-1`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Undefined Behavior\n     * A `start` or  `stop` index which is non-integral.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * let data = [0, 1, 2, 3, 4];\n     * ArrayExt.reverse(data, 1, 3);  // [0, 3, 2, 1, 4]\n     * ArrayExt.reverse(data, 3);     // [0, 3, 2, 4, 1]\n     * ArrayExt.reverse(data);        // [1, 4, 2, 3, 0]\n     * ```\n     */\n    function reverse(array, start = 0, stop = -1) {\n        let n = array.length;\n        if (n <= 1) {\n            return;\n        }\n        if (start < 0) {\n            start = Math.max(0, start + n);\n        }\n        else {\n            start = Math.min(start, n - 1);\n        }\n        if (stop < 0) {\n            stop = Math.max(0, stop + n);\n        }\n        else {\n            stop = Math.min(stop, n - 1);\n        }\n        while (start < stop) {\n            let a = array[start];\n            let b = array[stop];\n            array[start++] = b;\n            array[stop--] = a;\n        }\n    }\n    ArrayExt.reverse = reverse;\n    /**\n     * Rotate the elements of an array in-place.\n     *\n     * @param array - The mutable array-like object of interest.\n     *\n     * @param delta - The amount of rotation to apply to the elements. A\n     *   positive value will rotate the elements to the left. A negative\n     *   value will rotate the elements to the right.\n     *\n     * @param start - The index of the first element in the range to be\n     *   rotated, inclusive. The default value is `0`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @param stop - The index of the last element in the range to be\n     *   rotated, inclusive. The default value is `-1`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Undefined Behavior\n     * A `delta`, `start`, or `stop` which is non-integral.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * let data = [0, 1, 2, 3, 4];\n     * ArrayExt.rotate(data, 2);        // [2, 3, 4, 0, 1]\n     * ArrayExt.rotate(data, -2);       // [0, 1, 2, 3, 4]\n     * ArrayExt.rotate(data, 10);       // [0, 1, 2, 3, 4]\n     * ArrayExt.rotate(data, 9);        // [4, 0, 1, 2, 3]\n     * ArrayExt.rotate(data, 2, 1, 3);  // [4, 2, 0, 1, 3]\n     * ```\n     */\n    function rotate(array, delta, start = 0, stop = -1) {\n        let n = array.length;\n        if (n <= 1) {\n            return;\n        }\n        if (start < 0) {\n            start = Math.max(0, start + n);\n        }\n        else {\n            start = Math.min(start, n - 1);\n        }\n        if (stop < 0) {\n            stop = Math.max(0, stop + n);\n        }\n        else {\n            stop = Math.min(stop, n - 1);\n        }\n        if (start >= stop) {\n            return;\n        }\n        let length = stop - start + 1;\n        if (delta > 0) {\n            delta = delta % length;\n        }\n        else if (delta < 0) {\n            delta = ((delta % length) + length) % length;\n        }\n        if (delta === 0) {\n            return;\n        }\n        let pivot = start + delta;\n        reverse(array, start, pivot - 1);\n        reverse(array, pivot, stop);\n        reverse(array, start, stop);\n    }\n    ArrayExt.rotate = rotate;\n    /**\n     * Fill an array with a static value.\n     *\n     * @param array - The mutable array-like object to fill.\n     *\n     * @param value - The static value to use to fill the array.\n     *\n     * @param start - The index of the first element in the range to be\n     *   filled, inclusive. The default value is `0`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @param stop - The index of the last element in the range to be\n     *   filled, inclusive. The default value is `-1`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * #### Notes\n     * If `stop < start` the fill will wrap at the end of the array.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Undefined Behavior\n     * A `start` or `stop` which is non-integral.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * let data = ['one', 'two', 'three', 'four'];\n     * ArrayExt.fill(data, 'r');        // ['r', 'r', 'r', 'r']\n     * ArrayExt.fill(data, 'g', 1);     // ['r', 'g', 'g', 'g']\n     * ArrayExt.fill(data, 'b', 2, 3);  // ['r', 'g', 'b', 'b']\n     * ArrayExt.fill(data, 'z', 3, 1);  // ['z', 'z', 'b', 'z']\n     * ```\n     */\n    function fill(array, value, start = 0, stop = -1) {\n        let n = array.length;\n        if (n === 0) {\n            return;\n        }\n        if (start < 0) {\n            start = Math.max(0, start + n);\n        }\n        else {\n            start = Math.min(start, n - 1);\n        }\n        if (stop < 0) {\n            stop = Math.max(0, stop + n);\n        }\n        else {\n            stop = Math.min(stop, n - 1);\n        }\n        let span;\n        if (stop < start) {\n            span = stop + 1 + (n - start);\n        }\n        else {\n            span = stop - start + 1;\n        }\n        for (let i = 0; i < span; ++i) {\n            array[(start + i) % n] = value;\n        }\n    }\n    ArrayExt.fill = fill;\n    /**\n     * Insert a value into an array at a specific index.\n     *\n     * @param array - The array of interest.\n     *\n     * @param index - The index at which to insert the value. Negative\n     *   values are taken as an offset from the end of the array.\n     *\n     * @param value - The value to set at the specified index.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Undefined Behavior\n     * An `index` which is non-integral.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * let data = [0, 1, 2];\n     * ArrayExt.insert(data, 0, -1);  // [-1, 0, 1, 2]\n     * ArrayExt.insert(data, 2, 12);  // [-1, 0, 12, 1, 2]\n     * ArrayExt.insert(data, -1, 7);  // [-1, 0, 12, 1, 7, 2]\n     * ArrayExt.insert(data, 6, 19);  // [-1, 0, 12, 1, 7, 2, 19]\n     * ```\n     */\n    function insert(array, index, value) {\n        let n = array.length;\n        if (index < 0) {\n            index = Math.max(0, index + n);\n        }\n        else {\n            index = Math.min(index, n);\n        }\n        for (let i = n; i > index; --i) {\n            array[i] = array[i - 1];\n        }\n        array[index] = value;\n    }\n    ArrayExt.insert = insert;\n    /**\n     * Remove and return a value at a specific index in an array.\n     *\n     * @param array - The array of interest.\n     *\n     * @param index - The index of the value to remove. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @returns The value at the specified index, or `undefined` if the\n     *   index is out of range.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Undefined Behavior\n     * An `index` which is non-integral.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * let data = [0, 12, 23, 39, 14, 12, 75];\n     * ArrayExt.removeAt(data, 2);   // 23\n     * ArrayExt.removeAt(data, -2);  // 12\n     * ArrayExt.removeAt(data, 10);  // undefined;\n     * ```\n     */\n    function removeAt(array, index) {\n        let n = array.length;\n        if (index < 0) {\n            index += n;\n        }\n        if (index < 0 || index >= n) {\n            return undefined;\n        }\n        let value = array[index];\n        for (let i = index + 1; i < n; ++i) {\n            array[i - 1] = array[i];\n        }\n        array.length = n - 1;\n        return value;\n    }\n    ArrayExt.removeAt = removeAt;\n    /**\n     * Remove the first occurrence of a value from an array.\n     *\n     * @param array - The array of interest.\n     *\n     * @param value - The value to remove from the array. Values are\n     *   compared using strict `===` equality.\n     *\n     * @param start - The index of the first element in the range to be\n     *   searched, inclusive. The default value is `0`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @param stop - The index of the last element in the range to be\n     *   searched, inclusive. The default value is `-1`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @returns The index of the removed value, or `-1` if the value\n     *   is not contained in the array.\n     *\n     * #### Notes\n     * If `stop < start` the search will wrap at the end of the array.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * let data = [0, 12, 23, 39, 14, 12, 75];\n     * ArrayExt.removeFirstOf(data, 12);        // 1\n     * ArrayExt.removeFirstOf(data, 17);        // -1\n     * ArrayExt.removeFirstOf(data, 39, 3);     // -1\n     * ArrayExt.removeFirstOf(data, 39, 3, 2);  // 2\n     * ```\n     */\n    function removeFirstOf(array, value, start = 0, stop = -1) {\n        let index = firstIndexOf(array, value, start, stop);\n        if (index !== -1) {\n            removeAt(array, index);\n        }\n        return index;\n    }\n    ArrayExt.removeFirstOf = removeFirstOf;\n    /**\n     * Remove the last occurrence of a value from an array.\n     *\n     * @param array - The array of interest.\n     *\n     * @param value - The value to remove from the array. Values are\n     *   compared using strict `===` equality.\n     *\n     * @param start - The index of the first element in the range to be\n     *   searched, inclusive. The default value is `-1`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @param stop - The index of the last element in the range to be\n     *   searched, inclusive. The default value is `0`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @returns The index of the removed value, or `-1` if the value\n     *   is not contained in the array.\n     *\n     * #### Notes\n     * If `start < stop` the search will wrap at the end of the array.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * let data = [0, 12, 23, 39, 14, 12, 75];\n     * ArrayExt.removeLastOf(data, 12);        // 5\n     * ArrayExt.removeLastOf(data, 17);        // -1\n     * ArrayExt.removeLastOf(data, 39, 2);     // -1\n     * ArrayExt.removeLastOf(data, 39, 2, 3);  // 3\n     * ```\n     */\n    function removeLastOf(array, value, start = -1, stop = 0) {\n        let index = lastIndexOf(array, value, start, stop);\n        if (index !== -1) {\n            removeAt(array, index);\n        }\n        return index;\n    }\n    ArrayExt.removeLastOf = removeLastOf;\n    /**\n     * Remove all occurrences of a value from an array.\n     *\n     * @param array - The array of interest.\n     *\n     * @param value - The value to remove from the array. Values are\n     *   compared using strict `===` equality.\n     *\n     * @param start - The index of the first element in the range to be\n     *   searched, inclusive. The default value is `0`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @param stop - The index of the last element in the range to be\n     *   searched, inclusive. The default value is `-1`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @returns The number of elements removed from the array.\n     *\n     * #### Notes\n     * If `stop < start` the search will conceptually wrap at the end of\n     * the array, however the array will be traversed front-to-back.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * let data = [14, 12, 23, 39, 14, 12, 19, 14];\n     * ArrayExt.removeAllOf(data, 12);        // 2\n     * ArrayExt.removeAllOf(data, 17);        // 0\n     * ArrayExt.removeAllOf(data, 14, 1, 4);  // 1\n     * ```\n     */\n    function removeAllOf(array, value, start = 0, stop = -1) {\n        let n = array.length;\n        if (n === 0) {\n            return 0;\n        }\n        if (start < 0) {\n            start = Math.max(0, start + n);\n        }\n        else {\n            start = Math.min(start, n - 1);\n        }\n        if (stop < 0) {\n            stop = Math.max(0, stop + n);\n        }\n        else {\n            stop = Math.min(stop, n - 1);\n        }\n        let count = 0;\n        for (let i = 0; i < n; ++i) {\n            if (start <= stop && i >= start && i <= stop && array[i] === value) {\n                count++;\n            }\n            else if (stop < start &&\n                (i <= stop || i >= start) &&\n                array[i] === value) {\n                count++;\n            }\n            else if (count > 0) {\n                array[i - count] = array[i];\n            }\n        }\n        if (count > 0) {\n            array.length = n - count;\n        }\n        return count;\n    }\n    ArrayExt.removeAllOf = removeAllOf;\n    /**\n     * Remove the first occurrence of a value which matches a predicate.\n     *\n     * @param array - The array of interest.\n     *\n     * @param fn - The predicate function to apply to the values.\n     *\n     * @param start - The index of the first element in the range to be\n     *   searched, inclusive. The default value is `0`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @param stop - The index of the last element in the range to be\n     *   searched, inclusive. The default value is `-1`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @returns The removed `{ index, value }`, which will be `-1` and\n     *   `undefined` if the value is not contained in the array.\n     *\n     * #### Notes\n     * If `stop < start` the search will wrap at the end of the array.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * function isEven(value: number): boolean {\n     *   return value % 2 === 0;\n     * }\n     *\n     * let data = [0, 12, 23, 39, 14, 12, 75];\n     * ArrayExt.removeFirstWhere(data, isEven);     // { index: 0, value: 0 }\n     * ArrayExt.removeFirstWhere(data, isEven, 2);  // { index: 3, value: 14 }\n     * ArrayExt.removeFirstWhere(data, isEven, 4);  // { index: -1, value: undefined }\n     * ```\n     */\n    function removeFirstWhere(array, fn, start = 0, stop = -1) {\n        let value;\n        let index = findFirstIndex(array, fn, start, stop);\n        if (index !== -1) {\n            value = removeAt(array, index);\n        }\n        return { index, value };\n    }\n    ArrayExt.removeFirstWhere = removeFirstWhere;\n    /**\n     * Remove the last occurrence of a value which matches a predicate.\n     *\n     * @param array - The array of interest.\n     *\n     * @param fn - The predicate function to apply to the values.\n     *\n     * @param start - The index of the first element in the range to be\n     *   searched, inclusive. The default value is `-1`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @param stop - The index of the last element in the range to be\n     *   searched, inclusive. The default value is `0`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @returns The removed `{ index, value }`, which will be `-1` and\n     *   `undefined` if the value is not contained in the array.\n     *\n     * #### Notes\n     * If `start < stop` the search will wrap at the end of the array.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * function isEven(value: number): boolean {\n     *   return value % 2 === 0;\n     * }\n     *\n     * let data = [0, 12, 23, 39, 14, 12, 75];\n     * ArrayExt.removeLastWhere(data, isEven);        // { index: 5, value: 12 }\n     * ArrayExt.removeLastWhere(data, isEven, 2);     // { index: 1, value: 12 }\n     * ArrayExt.removeLastWhere(data, isEven, 2, 1);  // { index: -1, value: undefined }\n     * ```\n     */\n    function removeLastWhere(array, fn, start = -1, stop = 0) {\n        let value;\n        let index = findLastIndex(array, fn, start, stop);\n        if (index !== -1) {\n            value = removeAt(array, index);\n        }\n        return { index, value };\n    }\n    ArrayExt.removeLastWhere = removeLastWhere;\n    /**\n     * Remove all occurrences of values which match a predicate.\n     *\n     * @param array - The array of interest.\n     *\n     * @param fn - The predicate function to apply to the values.\n     *\n     * @param start - The index of the first element in the range to be\n     *   searched, inclusive. The default value is `0`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @param stop - The index of the last element in the range to be\n     *   searched, inclusive. The default value is `-1`. Negative values\n     *   are taken as an offset from the end of the array.\n     *\n     * @returns The number of elements removed from the array.\n     *\n     * #### Notes\n     * If `stop < start` the search will conceptually wrap at the end of\n     * the array, however the array will be traversed front-to-back.\n     *\n     * #### Complexity\n     * Linear.\n     *\n     * #### Example\n     * ```typescript\n     * import { ArrayExt } from '@lumino/algorithm';\n     *\n     * function isEven(value: number): boolean {\n     *   return value % 2 === 0;\n     * }\n     *\n     * function isNegative(value: number): boolean {\n     *   return value < 0;\n     * }\n     *\n     * let data = [0, 12, -13, -9, 23, 39, 14, -15, 12, 75];\n     * ArrayExt.removeAllWhere(data, isEven);            // 4\n     * ArrayExt.removeAllWhere(data, isNegative, 0, 3);  // 2\n     * ```\n     */\n    function removeAllWhere(array, fn, start = 0, stop = -1) {\n        let n = array.length;\n        if (n === 0) {\n            return 0;\n        }\n        if (start < 0) {\n            start = Math.max(0, start + n);\n        }\n        else {\n            start = Math.min(start, n - 1);\n        }\n        if (stop < 0) {\n            stop = Math.max(0, stop + n);\n        }\n        else {\n            stop = Math.min(stop, n - 1);\n        }\n        let count = 0;\n        for (let i = 0; i < n; ++i) {\n            if (start <= stop && i >= start && i <= stop && fn(array[i], i)) {\n                count++;\n            }\n            else if (stop < start && (i <= stop || i >= start) && fn(array[i], i)) {\n                count++;\n            }\n            else if (count > 0) {\n                array[i - count] = array[i];\n            }\n        }\n        if (count > 0) {\n            array.length = n - count;\n        }\n        return count;\n    }\n    ArrayExt.removeAllWhere = removeAllWhere;\n})(ArrayExt || (ArrayExt = {}));\n/**\n * The namespace for the module implementation details.\n */\nvar Private$1;\n(function (Private) {\n    /**\n     * Compute the effective length of a range.\n     *\n     * @param start - The starting value for the range, inclusive.\n     *\n     * @param stop - The stopping value for the range, exclusive.\n     *\n     * @param step - The distance between each value.\n     *\n     * @returns The number of steps need to traverse the range.\n     */\n    function rangeLength(start, stop, step) {\n        if (step === 0) {\n            return Infinity;\n        }\n        if (start > stop && step > 0) {\n            return 0;\n        }\n        if (start < stop && step < 0) {\n            return 0;\n        }\n        return Math.ceil((stop - start) / step);\n    }\n    Private.rangeLength = rangeLength;\n})(Private$1 || (Private$1 = {}));\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * Topologically sort an iterable of edges.\n *\n * @param edges - The iterable object of edges to sort.\n *   An edge is represented as a 2-tuple of `[fromNode, toNode]`.\n *\n * @returns The topologically sorted array of nodes.\n *\n * #### Notes\n * If a cycle is present in the graph, the cycle will be ignored and\n * the return value will be only approximately sorted.\n *\n * #### Example\n * ```typescript\n * import { topologicSort } from '@lumino/algorithm';\n *\n * let data = [\n *   ['d', 'e'],\n *   ['c', 'd'],\n *   ['a', 'b'],\n *   ['b', 'c']\n * ];\n *\n * topologicSort(data);  // ['a', 'b', 'c', 'd', 'e']\n * ```\n */\nfunction topologicSort(edges) {\n    // Setup the shared sorting state.\n    let sorted = [];\n    let visited = new Set();\n    let graph = new Map();\n    // Add the edges to the graph.\n    for (const edge of edges) {\n        addEdge(edge);\n    }\n    // Visit each node in the graph.\n    for (const [k] of graph) {\n        visit(k);\n    }\n    // Return the sorted results.\n    return sorted;\n    // Add an edge to the graph.\n    function addEdge(edge) {\n        let [fromNode, toNode] = edge;\n        let children = graph.get(toNode);\n        if (children) {\n            children.push(fromNode);\n        }\n        else {\n            graph.set(toNode, [fromNode]);\n        }\n    }\n    // Recursively visit the node.\n    function visit(node) {\n        if (visited.has(node)) {\n            return;\n        }\n        visited.add(node);\n        let children = graph.get(node);\n        if (children) {\n            for (const child of children) {\n                visit(child);\n            }\n        }\n        sorted.push(node);\n    }\n}\n\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\n/*-----------------------------------------------------------------------------\n| Copyright (c) 2014-2017, PhosphorJS Contributors\n|\n| Distributed under the terms of the BSD 3-Clause License.\n|\n| The full license is in the file LICENSE, distributed with this software.\n|----------------------------------------------------------------------------*/\n/**\n * The namespace for string-specific algorithms.\n */\nvar StringExt;\n(function (StringExt) {\n    /**\n     * Find the indices of characters in a source text.\n     *\n     * @param source - The source text which should be searched.\n     *\n     * @param query - The characters to locate in the source text.\n     *\n     * @param start - The index to start the search.\n     *\n     * @returns The matched indices, or `null` if there is no match.\n     *\n     * #### Complexity\n     * Linear on `sourceText`.\n     *\n     * #### Notes\n     * In order for there to be a match, all of the characters in `query`\n     * **must** appear in `source` in the order given by `query`.\n     *\n     * Characters are matched using strict `===` equality.\n     */\n    function findIndices(source, query, start = 0) {\n        let indices = new Array(query.length);\n        for (let i = 0, j = start, n = query.length; i < n; ++i, ++j) {\n            j = source.indexOf(query[i], j);\n            if (j === -1) {\n                return null;\n            }\n            indices[i] = j;\n        }\n        return indices;\n    }\n    StringExt.findIndices = findIndices;\n    /**\n     * A string matcher which uses a sum-of-squares algorithm.\n     *\n     * @param source - The source text which should be searched.\n     *\n     * @param query - The characters to locate in the source text.\n     *\n     * @param start - The index to start the search.\n     *\n     * @returns The match result, or `null` if there is no match.\n     *   A lower `score` represents a stronger match.\n     *\n     * #### Complexity\n     * Linear on `sourceText`.\n     *\n     * #### Notes\n     * This scoring algorithm uses a sum-of-squares approach to determine\n     * the score. In order for there to be a match, all of the characters\n     * in `query` **must** appear in `source` in order. The index of each\n     * matching character is squared and added to the score. This means\n     * that early and consecutive character matches are preferred, while\n     * late matches are heavily penalized.\n     */\n    function matchSumOfSquares(source, query, start = 0) {\n        let indices = findIndices(source, query, start);\n        if (!indices) {\n            return null;\n        }\n        let score = 0;\n        for (let i = 0, n = indices.length; i < n; ++i) {\n            let j = indices[i] - start;\n            score += j * j;\n        }\n        return { score, indices };\n    }\n    StringExt.matchSumOfSquares = matchSumOfSquares;\n    /**\n     * A string matcher which uses a sum-of-deltas algorithm.\n     *\n     * @param source - The source text which should be searched.\n     *\n     * @param query - The characters to locate in the source text.\n     *\n     * @param start - The index to start the search.\n     *\n     * @returns The match result, or `null` if there is no match.\n     *   A lower `score` represents a stronger match.\n     *\n     * #### Complexity\n     * Linear on `sourceText`.\n     *\n     * #### Notes\n     * This scoring algorithm uses a sum-of-deltas approach to determine\n     * the score. In order for there to be a match, all of the characters\n     * in `query` **must** appear in `source` in order. The delta between\n     * the indices are summed to create the score. This means that groups\n     * of matched characters are preferred, while fragmented matches are\n     * penalized.\n     */\n    function matchSumOfDeltas(source, query, start = 0) {\n        let indices = findIndices(source, query, start);\n        if (!indices) {\n            return null;\n        }\n        let score = 0;\n        let last = start - 1;\n        for (let i = 0, n = indices.length; i < n; ++i) {\n            let j = indices[i];\n            score += j - last - 1;\n            last = j;\n        }\n        return { score, indices };\n    }\n    StringExt.matchSumOfDeltas = matchSumOfDeltas;\n    /**\n     * Highlight the matched characters of a source text.\n     *\n     * @param source - The text which should be highlighted.\n     *\n     * @param indices - The indices of the matched characters. They must\n     *   appear in increasing order and must be in bounds of the source.\n     *\n     * @param fn - The function to apply to the matched chunks.\n     *\n     * @returns An array of unmatched and highlighted chunks.\n     */\n    function highlight(source, indices, fn) {\n        // Set up the result array.\n        let result = [];\n        // Set up the counter variables.\n        let k = 0;\n        let last = 0;\n        let n = indices.length;\n        // Iterator over each index.\n        while (k < n) {\n            // Set up the chunk indices.\n            let i = indices[k];\n            let j = indices[k];\n            // Advance the right chunk index until it's non-contiguous.\n            while (++k < n && indices[k] === j + 1) {\n                j++;\n            }\n            // Extract the unmatched text.\n            if (last < i) {\n                result.push(source.slice(last, i));\n            }\n            // Extract and highlight the matched text.\n            if (i < j + 1) {\n                result.push(fn(source.slice(i, j + 1)));\n            }\n            // Update the last visited index.\n            last = j + 1;\n        }\n        // Extract any remaining unmatched text.\n        if (last < source.length) {\n            result.push(source.slice(last));\n        }\n        // Return the highlighted result.\n        return result;\n    }\n    StringExt.highlight = highlight;\n    /**\n     * A 3-way string comparison function.\n     *\n     * @param a - The first string of interest.\n     *\n     * @param b - The second string of interest.\n     *\n     * @returns `-1` if `a < b`, else `1` if `a > b`, else `0`.\n     */\n    function cmp(a, b) {\n        return a < b ? -1 : a > b ? 1 : 0;\n    }\n    StringExt.cmp = cmp;\n})(StringExt || (StringExt = {}));\n\n// Copyright (c) Jupyter Development Team.\n/**\n * A class for creating pluggable applications.\n *\n * @typeparam T - The type of the application shell.\n *\n * #### Notes\n * The `Application` class is useful when creating large, complex\n * UI applications with the ability to be safely extended by third\n * party code via plugins.\n */\nclass Application {\n    /**\n     * Construct a new application.\n     *\n     * @param options - The options for creating the application.\n     */\n    constructor(options) {\n        this._delegate = new PromiseDelegate();\n        this._plugins = new Map();\n        this._services = new Map();\n        this._started = false;\n        // Initialize the application state.\n        this.commands = new CommandRegistry();\n        this.contextMenu = new ContextMenu({\n            commands: this.commands,\n            renderer: options.contextMenuRenderer\n        });\n        this.shell = options.shell;\n    }\n    /**\n     * A promise which resolves after the application has started.\n     *\n     * #### Notes\n     * This promise will resolve after the `start()` method is called,\n     * when all the bootstrapping and shell mounting work is complete.\n     */\n    get started() {\n        return this._delegate.promise;\n    }\n    /**\n     * Get a plugin description.\n     *\n     * @param id - The ID of the plugin of interest.\n     *\n     * @returns The plugin description.\n     */\n    getPluginDescription(id) {\n        var _a, _b;\n        return (_b = (_a = this._plugins.get(id)) === null || _a === void 0 ? void 0 : _a.description) !== null && _b !== void 0 ? _b : '';\n    }\n    /**\n     * Test whether a plugin is registered with the application.\n     *\n     * @param id - The ID of the plugin of interest.\n     *\n     * @returns `true` if the plugin is registered, `false` otherwise.\n     */\n    hasPlugin(id) {\n        return this._plugins.has(id);\n    }\n    /**\n     * Test whether a plugin is activated with the application.\n     *\n     * @param id - The ID of the plugin of interest.\n     *\n     * @returns `true` if the plugin is activated, `false` otherwise.\n     */\n    isPluginActivated(id) {\n        var _a, _b;\n        return (_b = (_a = this._plugins.get(id)) === null || _a === void 0 ? void 0 : _a.activated) !== null && _b !== void 0 ? _b : false;\n    }\n    /**\n     * List the IDs of the plugins registered with the application.\n     *\n     * @returns A new array of the registered plugin IDs.\n     */\n    listPlugins() {\n        return Array.from(this._plugins.keys());\n    }\n    /**\n     * Register a plugin with the application.\n     *\n     * @param plugin - The plugin to register.\n     *\n     * #### Notes\n     * An error will be thrown if a plugin with the same ID is already\n     * registered, or if the plugin has a circular dependency.\n     *\n     * If the plugin provides a service which has already been provided\n     * by another plugin, the new service will override the old service.\n     */\n    registerPlugin(plugin) {\n        // Throw an error if the plugin ID is already registered.\n        if (this._plugins.has(plugin.id)) {\n            throw new TypeError(`Plugin '${plugin.id}' is already registered.`);\n        }\n        // Create the normalized plugin data.\n        const data = Private.createPluginData(plugin);\n        // Ensure the plugin does not cause a cyclic dependency.\n        Private.ensureNoCycle(data, this._plugins, this._services);\n        // Add the service token to the service map.\n        if (data.provides) {\n            this._services.set(data.provides, data.id);\n        }\n        // Add the plugin to the plugin map.\n        this._plugins.set(data.id, data);\n    }\n    /**\n     * Register multiple plugins with the application.\n     *\n     * @param plugins - The plugins to register.\n     *\n     * #### Notes\n     * This calls `registerPlugin()` for each of the given plugins.\n     */\n    registerPlugins(plugins) {\n        for (const plugin of plugins) {\n            this.registerPlugin(plugin);\n        }\n    }\n    /**\n     * Deregister a plugin with the application.\n     *\n     * @param id - The ID of the plugin of interest.\n     *\n     * @param force - Whether to deregister the plugin even if it is active.\n     */\n    deregisterPlugin(id, force) {\n        const plugin = this._plugins.get(id);\n        if (!plugin) {\n            return;\n        }\n        if (plugin.activated && !force) {\n            throw new Error(`Plugin '${id}' is still active.`);\n        }\n        this._plugins.delete(id);\n    }\n    /**\n     * Activate the plugin with the given ID.\n     *\n     * @param id - The ID of the plugin of interest.\n     *\n     * @returns A promise which resolves when the plugin is activated\n     *   or rejects with an error if it cannot be activated.\n     */\n    async activatePlugin(id) {\n        // Reject the promise if the plugin is not registered.\n        const plugin = this._plugins.get(id);\n        if (!plugin) {\n            throw new ReferenceError(`Plugin '${id}' is not registered.`);\n        }\n        // Resolve immediately if the plugin is already activated.\n        if (plugin.activated) {\n            return;\n        }\n        // Return the pending resolver promise if it exists.\n        if (plugin.promise) {\n            return plugin.promise;\n        }\n        // Resolve the required services for the plugin.\n        const required = plugin.requires.map(t => this.resolveRequiredService(t));\n        // Resolve the optional services for the plugin.\n        const optional = plugin.optional.map(t => this.resolveOptionalService(t));\n        // Setup the resolver promise for the plugin.\n        plugin.promise = Promise.all([...required, ...optional])\n            .then(services => plugin.activate.apply(undefined, [this, ...services]))\n            .then(service => {\n            plugin.service = service;\n            plugin.activated = true;\n            plugin.promise = null;\n        })\n            .catch(error => {\n            plugin.promise = null;\n            throw error;\n        });\n        // Return the pending resolver promise.\n        return plugin.promise;\n    }\n    /**\n     * Deactivate the plugin and its downstream dependents if and only if the\n     * plugin and its dependents all support `deactivate`.\n     *\n     * @param id - The ID of the plugin of interest.\n     *\n     * @returns A list of IDs of downstream plugins deactivated with this one.\n     */\n    async deactivatePlugin(id) {\n        // Reject the promise if the plugin is not registered.\n        const plugin = this._plugins.get(id);\n        if (!plugin) {\n            throw new ReferenceError(`Plugin '${id}' is not registered.`);\n        }\n        // Bail early if the plugin is not activated.\n        if (!plugin.activated) {\n            return [];\n        }\n        // Check that this plugin can deactivate.\n        if (!plugin.deactivate) {\n            throw new TypeError(`Plugin '${id}'#deactivate() method missing`);\n        }\n        // Find the optimal deactivation order for plugins downstream of this one.\n        const manifest = Private.findDependents(id, this._plugins, this._services);\n        const downstream = manifest.map(id => this._plugins.get(id));\n        // Check that all downstream plugins can deactivate.\n        for (const plugin of downstream) {\n            if (!plugin.deactivate) {\n                throw new TypeError(`Plugin ${plugin.id}#deactivate() method missing (depends on ${id})`);\n            }\n        }\n        // Deactivate all downstream plugins.\n        for (const plugin of downstream) {\n            const services = [...plugin.requires, ...plugin.optional].map(service => {\n                const id = this._services.get(service);\n                return id ? this._plugins.get(id).service : null;\n            });\n            // Await deactivation so the next plugins only receive active services.\n            await plugin.deactivate(this, ...services);\n            plugin.service = null;\n            plugin.activated = false;\n        }\n        // Remove plugin ID and return manifest of deactivated plugins.\n        manifest.pop();\n        return manifest;\n    }\n    /**\n     * Resolve a required service of a given type.\n     *\n     * @param token - The token for the service type of interest.\n     *\n     * @returns A promise which resolves to an instance of the requested\n     *   service, or rejects with an error if it cannot be resolved.\n     *\n     * #### Notes\n     * Services are singletons. The same instance will be returned each\n     * time a given service token is resolved.\n     *\n     * If the plugin which provides the service has not been activated,\n     * resolving the service will automatically activate the plugin.\n     *\n     * User code will not typically call this method directly. Instead,\n     * the required services for the user's plugins will be resolved\n     * automatically when the plugin is activated.\n     */\n    async resolveRequiredService(token) {\n        // Reject the promise if there is no provider for the type.\n        const id = this._services.get(token);\n        if (!id) {\n            throw new TypeError(`No provider for: ${token.name}.`);\n        }\n        // Activate the plugin if necessary.\n        const plugin = this._plugins.get(id);\n        if (!plugin.activated) {\n            await this.activatePlugin(id);\n        }\n        return plugin.service;\n    }\n    /**\n     * Resolve an optional service of a given type.\n     *\n     * @param token - The token for the service type of interest.\n     *\n     * @returns A promise which resolves to an instance of the requested\n     *   service, or `null` if it cannot be resolved.\n     *\n     * #### Notes\n     * Services are singletons. The same instance will be returned each\n     * time a given service token is resolved.\n     *\n     * If the plugin which provides the service has not been activated,\n     * resolving the service will automatically activate the plugin.\n     *\n     * User code will not typically call this method directly. Instead,\n     * the optional services for the user's plugins will be resolved\n     * automatically when the plugin is activated.\n     */\n    async resolveOptionalService(token) {\n        // Resolve with `null` if there is no provider for the type.\n        const id = this._services.get(token);\n        if (!id) {\n            return null;\n        }\n        // Activate the plugin if necessary.\n        const plugin = this._plugins.get(id);\n        if (!plugin.activated) {\n            try {\n                await this.activatePlugin(id);\n            }\n            catch (reason) {\n                console.error(reason);\n                return null;\n            }\n        }\n        return plugin.service;\n    }\n    /**\n     * Start the application.\n     *\n     * @param options - The options for starting the application.\n     *\n     * @returns A promise which resolves when all bootstrapping work\n     *   is complete and the shell is mounted to the DOM.\n     *\n     * #### Notes\n     * This should be called once by the application creator after all\n     * initial plugins have been registered.\n     *\n     * If a plugin fails to the load, the error will be logged and the\n     * other valid plugins will continue to be loaded.\n     *\n     * Bootstrapping the application consists of the following steps:\n     * 1. Activate the startup plugins\n     * 2. Wait for those plugins to activate\n     * 3. Attach the shell widget to the DOM\n     * 4. Add the application event listeners\n     */\n    start(options = {}) {\n        // Return immediately if the application is already started.\n        if (this._started) {\n            return this._delegate.promise;\n        }\n        // Mark the application as started;\n        this._started = true;\n        // Parse the host ID for attaching the shell.\n        const hostID = options.hostID || '';\n        // Collect the ids of the startup plugins.\n        const startups = Private.collectStartupPlugins(this._plugins, options);\n        // Generate the activation promises.\n        const promises = startups.map(id => {\n            return this.activatePlugin(id).catch(error => {\n                console.error(`Plugin '${id}' failed to activate.`);\n                console.error(error);\n            });\n        });\n        // Wait for the plugins to activate, then finalize startup.\n        Promise.all(promises).then(() => {\n            this.attachShell(hostID);\n            this.addEventListeners();\n            this._delegate.resolve();\n        });\n        // Return the pending delegate promise.\n        return this._delegate.promise;\n    }\n    /**\n     * The list of all the deferred plugins.\n     */\n    get deferredPlugins() {\n        return Array.from(this._plugins)\n            .filter(([id, plugin]) => plugin.autoStart === 'defer')\n            .map(([id, plugin]) => id);\n    }\n    /**\n     * Activate all the deferred plugins.\n     *\n     * @returns A promise which will resolve when each plugin is activated\n     * or rejects with an error if one cannot be activated.\n     */\n    async activateDeferredPlugins() {\n        const promises = this.deferredPlugins\n            .filter(pluginId => this._plugins.get(pluginId).autoStart)\n            .map(pluginId => {\n            return this.activatePlugin(pluginId);\n        });\n        await Promise.all(promises);\n    }\n    /**\n     * Handle the DOM events for the application.\n     *\n     * @param event - The DOM event sent to the application.\n     *\n     * #### Notes\n     * This method implements the DOM `EventListener` interface and is\n     * called in response to events registered for the application. It\n     * should not be called directly by user code.\n     */\n    handleEvent(event) {\n        switch (event.type) {\n            case 'resize':\n                this.evtResize(event);\n                break;\n            case 'keydown':\n                this.evtKeydown(event);\n                break;\n            case 'contextmenu':\n                this.evtContextMenu(event);\n                break;\n        }\n    }\n    /**\n     * Attach the application shell to the DOM.\n     *\n     * @param id - The ID of the host node for the shell, or `''`.\n     *\n     * #### Notes\n     * If the ID is not provided, the document body will be the host.\n     *\n     * A subclass may reimplement this method as needed.\n     */\n    attachShell(id) {\n        Widget.attach(this.shell, (id && document.getElementById(id)) || document.body);\n    }\n    /**\n     * Add the application event listeners.\n     *\n     * #### Notes\n     * The default implementation of this method adds listeners for\n     * `'keydown'` and `'resize'` events.\n     *\n     * A subclass may reimplement this method as needed.\n     */\n    addEventListeners() {\n        document.addEventListener('contextmenu', this);\n        document.addEventListener('keydown', this, true);\n        window.addEventListener('resize', this);\n    }\n    /**\n     * A method invoked on a document `'keydown'` event.\n     *\n     * #### Notes\n     * The default implementation of this method invokes the key down\n     * processing method of the application command registry.\n     *\n     * A subclass may reimplement this method as needed.\n     */\n    evtKeydown(event) {\n        this.commands.processKeydownEvent(event);\n    }\n    /**\n     * A method invoked on a document `'contextmenu'` event.\n     *\n     * #### Notes\n     * The default implementation of this method opens the application\n     * `contextMenu` at the current mouse position.\n     *\n     * If the application context menu has no matching content *or* if\n     * the shift key is pressed, the default browser context menu will\n     * be opened instead.\n     *\n     * A subclass may reimplement this method as needed.\n     */\n    evtContextMenu(event) {\n        if (event.shiftKey) {\n            return;\n        }\n        if (this.contextMenu.open(event)) {\n            event.preventDefault();\n            event.stopPropagation();\n        }\n    }\n    /**\n     * A method invoked on a window `'resize'` event.\n     *\n     * #### Notes\n     * The default implementation of this method updates the shell.\n     *\n     * A subclass may reimplement this method as needed.\n     */\n    evtResize(event) {\n        this.shell.update();\n    }\n}\n/**\n * The namespace for the module implementation details.\n */\nvar Private;\n(function (Private) {\n    /**\n     * Create a normalized plugin data object for the given plugin.\n     */\n    function createPluginData(plugin) {\n        var _a, _b, _c, _d;\n        return {\n            id: plugin.id,\n            description: (_a = plugin.description) !== null && _a !== void 0 ? _a : '',\n            service: null,\n            promise: null,\n            activated: false,\n            activate: plugin.activate,\n            deactivate: (_b = plugin.deactivate) !== null && _b !== void 0 ? _b : null,\n            provides: (_c = plugin.provides) !== null && _c !== void 0 ? _c : null,\n            autoStart: (_d = plugin.autoStart) !== null && _d !== void 0 ? _d : false,\n            requires: plugin.requires ? plugin.requires.slice() : [],\n            optional: plugin.optional ? plugin.optional.slice() : []\n        };\n    }\n    Private.createPluginData = createPluginData;\n    /**\n     * Ensure no cycle is present in the plugin resolution graph.\n     *\n     * If a cycle is detected, an error will be thrown.\n     */\n    function ensureNoCycle(plugin, plugins, services) {\n        const dependencies = [...plugin.requires, ...plugin.optional];\n        const visit = (token) => {\n            if (token === plugin.provides) {\n                return true;\n            }\n            const id = services.get(token);\n            if (!id) {\n                return false;\n            }\n            const visited = plugins.get(id);\n            const dependencies = [...visited.requires, ...visited.optional];\n            if (dependencies.length === 0) {\n                return false;\n            }\n            trace.push(id);\n            if (dependencies.some(visit)) {\n                return true;\n            }\n            trace.pop();\n            return false;\n        };\n        // Bail early if there cannot be a cycle.\n        if (!plugin.provides || dependencies.length === 0) {\n            return;\n        }\n        // Setup a stack to trace service resolution.\n        const trace = [plugin.id];\n        // Throw an exception if a cycle is present.\n        if (dependencies.some(visit)) {\n            throw new ReferenceError(`Cycle detected: ${trace.join(' -> ')}.`);\n        }\n    }\n    Private.ensureNoCycle = ensureNoCycle;\n    /**\n     * Find dependents in deactivation order.\n     *\n     * @param id - The ID of the plugin of interest.\n     *\n     * @param plugins - The map containing all plugins.\n     *\n     * @param services - The map containing all services.\n     *\n     * @returns A list of dependent plugin IDs in order of deactivation\n     *\n     * #### Notes\n     * The final item of the returned list is always the plugin of interest.\n     */\n    function findDependents(id, plugins, services) {\n        const edges = new Array();\n        const add = (id) => {\n            const plugin = plugins.get(id);\n            // FIXME In the case of missing optional dependencies, we may consider\n            // deactivating and reactivating the plugin without the missing service.\n            const dependencies = [...plugin.requires, ...plugin.optional];\n            edges.push(...dependencies.reduce((acc, dep) => {\n                const service = services.get(dep);\n                if (service) {\n                    // An edge is oriented from dependent to provider.\n                    acc.push([id, service]);\n                }\n                return acc;\n            }, []));\n        };\n        for (const id of plugins.keys()) {\n            add(id);\n        }\n        // Filter edges\n        // - Get all packages that dependent on the package to be deactivated\n        const newEdges = edges.filter(edge => edge[1] === id);\n        let oldSize = 0;\n        while (newEdges.length > oldSize) {\n            const previousSize = newEdges.length;\n            // Get all packages that dependent on packages that will be deactivated\n            const packagesOfInterest = new Set(newEdges.map(edge => edge[0]));\n            for (const poi of packagesOfInterest) {\n                edges\n                    .filter(edge => edge[1] === poi)\n                    .forEach(edge => {\n                    // We check it is not already included to deal with circular dependencies\n                    if (!newEdges.includes(edge)) {\n                        newEdges.push(edge);\n                    }\n                });\n            }\n            oldSize = previousSize;\n        }\n        const sorted = topologicSort(newEdges);\n        const index = sorted.findIndex(candidate => candidate === id);\n        if (index === -1) {\n            return [id];\n        }\n        return sorted.slice(0, index + 1);\n    }\n    Private.findDependents = findDependents;\n    /**\n     * Collect the IDs of the plugins to activate on startup.\n     */\n    function collectStartupPlugins(plugins, options) {\n        // Create a set to hold the plugin IDs.\n        const collection = new Set();\n        // Collect the auto-start (non deferred) plugins.\n        for (const id of plugins.keys()) {\n            if (plugins.get(id).autoStart === true) {\n                collection.add(id);\n            }\n        }\n        // Add the startup plugins.\n        if (options.startPlugins) {\n            for (const id of options.startPlugins) {\n                collection.add(id);\n            }\n        }\n        // Remove the ignored plugins.\n        if (options.ignorePlugins) {\n            for (const id of options.ignorePlugins) {\n                collection.delete(id);\n            }\n        }\n        // Return the collected startup plugins.\n        return Array.from(collection);\n    }\n    Private.collectStartupPlugins = collectStartupPlugins;\n})(Private || (Private = {}));\n\nexport { Application };\n//# sourceMappingURL=index.es6.js.map\n"],"names":["ArrayExt","Private$1","StringExt","Private","firstIndexOf","array","value","start","stop","span","n","length","Math","max","min","i","j","lastIndexOf","findFirstIndex","fn","findLastIndex","d","reverse","a","b","removeAt","index","findFirstValue","undefined","findLastValue","lowerBound","begin","half","middle","upperBound","shallowEqual","slice","options","step","Error","floor","result","move","fromIndex","toIndex","rotate","delta","pivot","fill","insert","removeFirstOf","removeLastOf","removeAllOf","count","removeFirstWhere","removeLastWhere","removeAllWhere","rangeLength","Infinity","ceil","findIndices","source","query","indices","Array","indexOf","matchSumOfSquares","score","matchSumOfDeltas","last","highlight","k","push","cmp","Application","constructor","this","_delegate","PromiseDelegate","_plugins","Map","_services","_started","commands","CommandRegistry","contextMenu","ContextMenu","renderer","contextMenuRenderer","shell","started","promise","getPluginDescription","id","_a","_b","get","description","hasPlugin","has","isPluginActivated","activated","listPlugins","from","keys","registerPlugin","plugin","TypeError","data","createPluginData","ensureNoCycle","provides","set","registerPlugins","plugins","deregisterPlugin","force","delete","activatePlugin","ReferenceError","required","requires","map","t","resolveRequiredService","optional","resolveOptionalService","Promise","all","then","services","activate","apply","service","catch","error","deactivatePlugin","deactivate","manifest","findDependents","downstream","pop","token","name","reason","console","hostID","promises","collectStartupPlugins","attachShell","addEventListeners","resolve","deferredPlugins","filter","autoStart","activateDeferredPlugins","pluginId","handleEvent","event","type","evtResize","evtKeydown","evtContextMenu","Widget","attach","document","getElementById","body","addEventListener","window","processKeydownEvent","shiftKey","open","preventDefault","stopPropagation","update","_c","_d","dependencies","visit","visited","trace","some","join","edges","add","reduce","acc","dep","newEdges","edge","oldSize","previousSize","packagesOfInterest","Set","poi","forEach","includes","sorted","graph","addEdge","fromNode","toNode","children","node","child","topologicSort","findIndex","candidate","collection","startPlugins","ignorePlugins"],"sourceRoot":""}